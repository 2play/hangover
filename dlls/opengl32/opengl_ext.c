/* Automatically generated from http://www.opengl.org/registry files; DO NOT EDIT! */

#include <windows.h>
#include <stdio.h>


#ifdef QEMU_DLL_GUEST


#include <GL/gl.h>
#include <GL/wglext.h>
#include <GL/glext.h>


#else


#define WGL_WGLEXT_PROTOTYPES
#include <wine/wgl.h>


#endif


#include "windows-user-services.h"
#include "dll_list.h"
#include "qemu_opengl32.h"


#ifndef QEMU_DLL_GUEST
#include <wine/debug.h>
WINE_DEFAULT_DEBUG_CHANNEL(qemu_opengl32);
#endif
const int extension_registry_size = 2694;

struct qemu_glAccumxOES
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAccumxOES( GLenum op, GLfixed value )
{
    struct qemu_glAccumxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACCUMXOES);
    call.op = op;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glAccumxOES(struct qemu_syscall *call)
{
    struct qemu_glAccumxOES *c = (struct qemu_glAccumxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glAccumxOES( c->op, c->value ));
}

#endif

struct qemu_glAcquireKeyedMutexWin32EXT
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t key;
    uint64_t timeout;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glAcquireKeyedMutexWin32EXT( GLuint memory, GLuint64 key, GLuint timeout )
{
    struct qemu_glAcquireKeyedMutexWin32EXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACQUIREKEYEDMUTEXWIN32EXT);
    call.memory = memory;
    call.key = key;
    call.timeout = timeout;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glAcquireKeyedMutexWin32EXT(struct qemu_syscall *call)
{
    struct qemu_glAcquireKeyedMutexWin32EXT *c = (struct qemu_glAcquireKeyedMutexWin32EXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glAcquireKeyedMutexWin32EXT( c->memory, c->key, c->timeout ));
}

#endif

struct qemu_glActiveProgramEXT
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveProgramEXT( GLuint program )
{
    struct qemu_glActiveProgramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVEPROGRAMEXT);
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveProgramEXT(struct qemu_syscall *call)
{
    struct qemu_glActiveProgramEXT *c = (struct qemu_glActiveProgramEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveProgramEXT( c->program ));
}

#endif

struct qemu_glActiveShaderProgram
{
    struct qemu_syscall super;
    uint64_t pipeline;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveShaderProgram( GLuint pipeline, GLuint program )
{
    struct qemu_glActiveShaderProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVESHADERPROGRAM);
    call.pipeline = pipeline;
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveShaderProgram(struct qemu_syscall *call)
{
    struct qemu_glActiveShaderProgram *c = (struct qemu_glActiveShaderProgram *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveShaderProgram( c->pipeline, c->program ));
}

#endif

struct qemu_glActiveStencilFaceEXT
{
    struct qemu_syscall super;
    uint64_t face;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveStencilFaceEXT( GLenum face )
{
    struct qemu_glActiveStencilFaceEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVESTENCILFACEEXT);
    call.face = face;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveStencilFaceEXT(struct qemu_syscall *call)
{
    struct qemu_glActiveStencilFaceEXT *c = (struct qemu_glActiveStencilFaceEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveStencilFaceEXT( c->face ));
}

#endif

struct qemu_glActiveTexture
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveTexture( GLenum texture )
{
    struct qemu_glActiveTexture call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVETEXTURE);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveTexture(struct qemu_syscall *call)
{
    struct qemu_glActiveTexture *c = (struct qemu_glActiveTexture *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveTexture( c->texture ));
}

#endif

struct qemu_glActiveTextureARB
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveTextureARB( GLenum texture )
{
    struct qemu_glActiveTextureARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVETEXTUREARB);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveTextureARB(struct qemu_syscall *call)
{
    struct qemu_glActiveTextureARB *c = (struct qemu_glActiveTextureARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveTextureARB( c->texture ));
}

#endif

struct qemu_glActiveVaryingNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glActiveVaryingNV( GLuint program, const GLchar *name )
{
    struct qemu_glActiveVaryingNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLACTIVEVARYINGNV);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glActiveVaryingNV(struct qemu_syscall *call)
{
    struct qemu_glActiveVaryingNV *c = (struct qemu_glActiveVaryingNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glActiveVaryingNV( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glAlphaFragmentOp1ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAlphaFragmentOp1ATI( GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod )
{
    struct qemu_glAlphaFragmentOp1ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLALPHAFRAGMENTOP1ATI);
    call.op = op;
    call.dst = dst;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glAlphaFragmentOp1ATI(struct qemu_syscall *call)
{
    struct qemu_glAlphaFragmentOp1ATI *c = (struct qemu_glAlphaFragmentOp1ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glAlphaFragmentOp1ATI( c->op, c->dst, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod ));
}

#endif

struct qemu_glAlphaFragmentOp2ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
    uint64_t arg2;
    uint64_t arg2Rep;
    uint64_t arg2Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAlphaFragmentOp2ATI( GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod )
{
    struct qemu_glAlphaFragmentOp2ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLALPHAFRAGMENTOP2ATI);
    call.op = op;
    call.dst = dst;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;
    call.arg2 = arg2;
    call.arg2Rep = arg2Rep;
    call.arg2Mod = arg2Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glAlphaFragmentOp2ATI(struct qemu_syscall *call)
{
    struct qemu_glAlphaFragmentOp2ATI *c = (struct qemu_glAlphaFragmentOp2ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glAlphaFragmentOp2ATI( c->op, c->dst, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod, c->arg2, c->arg2Rep, c->arg2Mod ));
}

#endif

struct qemu_glAlphaFragmentOp3ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
    uint64_t arg2;
    uint64_t arg2Rep;
    uint64_t arg2Mod;
    uint64_t arg3;
    uint64_t arg3Rep;
    uint64_t arg3Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAlphaFragmentOp3ATI( GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod )
{
    struct qemu_glAlphaFragmentOp3ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLALPHAFRAGMENTOP3ATI);
    call.op = op;
    call.dst = dst;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;
    call.arg2 = arg2;
    call.arg2Rep = arg2Rep;
    call.arg2Mod = arg2Mod;
    call.arg3 = arg3;
    call.arg3Rep = arg3Rep;
    call.arg3Mod = arg3Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glAlphaFragmentOp3ATI(struct qemu_syscall *call)
{
    struct qemu_glAlphaFragmentOp3ATI *c = (struct qemu_glAlphaFragmentOp3ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glAlphaFragmentOp3ATI( c->op, c->dst, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod, c->arg2, c->arg2Rep, c->arg2Mod, c->arg3, c->arg3Rep, c->arg3Mod ));
}

#endif

struct qemu_glAlphaFuncxOES
{
    struct qemu_syscall super;
    uint64_t func;
    uint64_t ref;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAlphaFuncxOES( GLenum func, GLfixed ref )
{
    struct qemu_glAlphaFuncxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLALPHAFUNCXOES);
    call.func = func;
    call.ref = ref;

    qemu_syscall(&call.super);
}

#else

void qemu_glAlphaFuncxOES(struct qemu_syscall *call)
{
    struct qemu_glAlphaFuncxOES *c = (struct qemu_glAlphaFuncxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glAlphaFuncxOES( c->func, c->ref ));
}

#endif

struct qemu_glAlphaToCoverageDitherControlNV
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAlphaToCoverageDitherControlNV( GLenum mode )
{
    struct qemu_glAlphaToCoverageDitherControlNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLALPHATOCOVERAGEDITHERCONTROLNV);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glAlphaToCoverageDitherControlNV(struct qemu_syscall *call)
{
    struct qemu_glAlphaToCoverageDitherControlNV *c = (struct qemu_glAlphaToCoverageDitherControlNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glAlphaToCoverageDitherControlNV( c->mode ));
}

#endif

struct qemu_glApplyFramebufferAttachmentCMAAINTEL
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glApplyFramebufferAttachmentCMAAINTEL(void)
{
    struct qemu_glApplyFramebufferAttachmentCMAAINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLAPPLYFRAMEBUFFERATTACHMENTCMAAINTEL);

    qemu_syscall(&call.super);
}

#else

void qemu_glApplyFramebufferAttachmentCMAAINTEL(struct qemu_syscall *call)
{
    struct qemu_glApplyFramebufferAttachmentCMAAINTEL *c = (struct qemu_glApplyFramebufferAttachmentCMAAINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glApplyFramebufferAttachmentCMAAINTEL());
}

#endif

struct qemu_glApplyTextureEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glApplyTextureEXT( GLenum mode )
{
    struct qemu_glApplyTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLAPPLYTEXTUREEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glApplyTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glApplyTextureEXT *c = (struct qemu_glApplyTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glApplyTextureEXT( c->mode ));
}

#endif

struct qemu_glAreProgramsResidentNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
    uint64_t residences;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glAreProgramsResidentNV( GLsizei n, const GLuint *programs, GLboolean *residences )
{
    struct qemu_glAreProgramsResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLAREPROGRAMSRESIDENTNV);
    call.n = n;
    call.programs = (ULONG_PTR)programs;
    call.residences = (ULONG_PTR)residences;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glAreProgramsResidentNV(struct qemu_syscall *call)
{
    struct qemu_glAreProgramsResidentNV *c = (struct qemu_glAreProgramsResidentNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glAreProgramsResidentNV( c->n, QEMU_G2H(c->programs), QEMU_G2H(c->residences) ));
}

#endif

struct qemu_glAreTexturesResidentEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t textures;
    uint64_t residences;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glAreTexturesResidentEXT( GLsizei n, const GLuint *textures, GLboolean *residences )
{
    struct qemu_glAreTexturesResidentEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLARETEXTURESRESIDENTEXT);
    call.n = n;
    call.textures = (ULONG_PTR)textures;
    call.residences = (ULONG_PTR)residences;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glAreTexturesResidentEXT(struct qemu_syscall *call)
{
    struct qemu_glAreTexturesResidentEXT *c = (struct qemu_glAreTexturesResidentEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glAreTexturesResidentEXT( c->n, QEMU_G2H(c->textures), QEMU_G2H(c->residences) ));
}

#endif

struct qemu_glArrayElementEXT
{
    struct qemu_syscall super;
    uint64_t i;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glArrayElementEXT( GLint i )
{
    struct qemu_glArrayElementEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLARRAYELEMENTEXT);
    call.i = i;

    qemu_syscall(&call.super);
}

#else

void qemu_glArrayElementEXT(struct qemu_syscall *call)
{
    struct qemu_glArrayElementEXT *c = (struct qemu_glArrayElementEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glArrayElementEXT( c->i ));
}

#endif

struct qemu_glArrayObjectATI
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t buffer;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glArrayObjectATI( GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset )
{
    struct qemu_glArrayObjectATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLARRAYOBJECTATI);
    call.array = array;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.buffer = buffer;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glArrayObjectATI(struct qemu_syscall *call)
{
    struct qemu_glArrayObjectATI *c = (struct qemu_glArrayObjectATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glArrayObjectATI( c->array, c->size, c->type, c->stride, c->buffer, c->offset ));
}

#endif

struct qemu_glAsyncCopyBufferSubDataNVX
{
    struct qemu_syscall super;
    uint64_t waitSemaphoreCount;
    uint64_t waitSemaphoreArray;
    uint64_t fenceValueArray;
    uint64_t readGpu;
    uint64_t writeGpuMask;
    uint64_t readBuffer;
    uint64_t writeBuffer;
    uint64_t readOffset;
    uint64_t writeOffset;
    uint64_t size;
    uint64_t signalSemaphoreCount;
    uint64_t signalSemaphoreArray;
    uint64_t signalValueArray;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glAsyncCopyBufferSubDataNVX( GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray )
{
    struct qemu_glAsyncCopyBufferSubDataNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLASYNCCOPYBUFFERSUBDATANVX);
    call.waitSemaphoreCount = waitSemaphoreCount;
    call.waitSemaphoreArray = (ULONG_PTR)waitSemaphoreArray;
    call.fenceValueArray = (ULONG_PTR)fenceValueArray;
    call.readGpu = readGpu;
    call.writeGpuMask = writeGpuMask;
    call.readBuffer = readBuffer;
    call.writeBuffer = writeBuffer;
    call.readOffset = readOffset;
    call.writeOffset = writeOffset;
    call.size = size;
    call.signalSemaphoreCount = signalSemaphoreCount;
    call.signalSemaphoreArray = (ULONG_PTR)signalSemaphoreArray;
    call.signalValueArray = (ULONG_PTR)signalValueArray;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glAsyncCopyBufferSubDataNVX(struct qemu_syscall *call)
{
    struct qemu_glAsyncCopyBufferSubDataNVX *c = (struct qemu_glAsyncCopyBufferSubDataNVX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glAsyncCopyBufferSubDataNVX( c->waitSemaphoreCount, QEMU_G2H(c->waitSemaphoreArray), QEMU_G2H(c->fenceValueArray), c->readGpu, c->writeGpuMask, c->readBuffer, c->writeBuffer, c->readOffset, c->writeOffset, c->size, c->signalSemaphoreCount, QEMU_G2H(c->signalSemaphoreArray), QEMU_G2H(c->signalValueArray) ));
}

#endif

struct qemu_glAsyncCopyImageSubDataNVX
{
    struct qemu_syscall super;
    uint64_t waitSemaphoreCount;
    uint64_t waitSemaphoreArray;
    uint64_t waitValueArray;
    uint64_t srcGpu;
    uint64_t dstGpuMask;
    uint64_t srcName;
    uint64_t srcTarget;
    uint64_t srcLevel;
    uint64_t srcX;
    uint64_t srcY;
    uint64_t srcZ;
    uint64_t dstName;
    uint64_t dstTarget;
    uint64_t dstLevel;
    uint64_t dstX;
    uint64_t dstY;
    uint64_t dstZ;
    uint64_t srcWidth;
    uint64_t srcHeight;
    uint64_t srcDepth;
    uint64_t signalSemaphoreCount;
    uint64_t signalSemaphoreArray;
    uint64_t signalValueArray;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glAsyncCopyImageSubDataNVX( GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray )
{
    struct qemu_glAsyncCopyImageSubDataNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLASYNCCOPYIMAGESUBDATANVX);
    call.waitSemaphoreCount = waitSemaphoreCount;
    call.waitSemaphoreArray = (ULONG_PTR)waitSemaphoreArray;
    call.waitValueArray = (ULONG_PTR)waitValueArray;
    call.srcGpu = srcGpu;
    call.dstGpuMask = dstGpuMask;
    call.srcName = srcName;
    call.srcTarget = srcTarget;
    call.srcLevel = srcLevel;
    call.srcX = srcX;
    call.srcY = srcY;
    call.srcZ = srcZ;
    call.dstName = dstName;
    call.dstTarget = dstTarget;
    call.dstLevel = dstLevel;
    call.dstX = dstX;
    call.dstY = dstY;
    call.dstZ = dstZ;
    call.srcWidth = srcWidth;
    call.srcHeight = srcHeight;
    call.srcDepth = srcDepth;
    call.signalSemaphoreCount = signalSemaphoreCount;
    call.signalSemaphoreArray = (ULONG_PTR)signalSemaphoreArray;
    call.signalValueArray = (ULONG_PTR)signalValueArray;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glAsyncCopyImageSubDataNVX(struct qemu_syscall *call)
{
    struct qemu_glAsyncCopyImageSubDataNVX *c = (struct qemu_glAsyncCopyImageSubDataNVX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glAsyncCopyImageSubDataNVX( c->waitSemaphoreCount, QEMU_G2H(c->waitSemaphoreArray), QEMU_G2H(c->waitValueArray), c->srcGpu, c->dstGpuMask, c->srcName, c->srcTarget, c->srcLevel, c->srcX, c->srcY, c->srcZ, c->dstName, c->dstTarget, c->dstLevel, c->dstX, c->dstY, c->dstZ, c->srcWidth, c->srcHeight, c->srcDepth, c->signalSemaphoreCount, QEMU_G2H(c->signalSemaphoreArray), QEMU_G2H(c->signalValueArray) ));
}

#endif

struct qemu_glAsyncMarkerSGIX
{
    struct qemu_syscall super;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAsyncMarkerSGIX( GLuint marker )
{
    struct qemu_glAsyncMarkerSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLASYNCMARKERSGIX);
    call.marker = marker;

    qemu_syscall(&call.super);
}

#else

void qemu_glAsyncMarkerSGIX(struct qemu_syscall *call)
{
    struct qemu_glAsyncMarkerSGIX *c = (struct qemu_glAsyncMarkerSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glAsyncMarkerSGIX( c->marker ));
}

#endif

struct qemu_glAttachObjectARB
{
    struct qemu_syscall super;
    uint64_t containerObj;
    uint64_t obj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAttachObjectARB( GLhandleARB containerObj, GLhandleARB obj )
{
    struct qemu_glAttachObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLATTACHOBJECTARB);
    call.containerObj = containerObj;
    call.obj = obj;

    qemu_syscall(&call.super);
}

#else

void qemu_glAttachObjectARB(struct qemu_syscall *call)
{
    struct qemu_glAttachObjectARB *c = (struct qemu_glAttachObjectARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glAttachObjectARB( c->containerObj, c->obj ));
}

#endif

struct qemu_glAttachShader
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shader;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glAttachShader( GLuint program, GLuint shader )
{
    struct qemu_glAttachShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLATTACHSHADER);
    call.program = program;
    call.shader = shader;

    qemu_syscall(&call.super);
}

#else

void qemu_glAttachShader(struct qemu_syscall *call)
{
    struct qemu_glAttachShader *c = (struct qemu_glAttachShader *)call;
    WINE_FIXME("Unverified\n");
    (p_glAttachShader( c->program, c->shader ));
}

#endif

struct qemu_glBeginConditionalRender
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginConditionalRender( GLuint id, GLenum mode )
{
    struct qemu_glBeginConditionalRender call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINCONDITIONALRENDER);
    call.id = id;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginConditionalRender(struct qemu_syscall *call)
{
    struct qemu_glBeginConditionalRender *c = (struct qemu_glBeginConditionalRender *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginConditionalRender( c->id, c->mode ));
}

#endif

struct qemu_glBeginConditionalRenderNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginConditionalRenderNV( GLuint id, GLenum mode )
{
    struct qemu_glBeginConditionalRenderNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINCONDITIONALRENDERNV);
    call.id = id;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginConditionalRenderNV(struct qemu_syscall *call)
{
    struct qemu_glBeginConditionalRenderNV *c = (struct qemu_glBeginConditionalRenderNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginConditionalRenderNV( c->id, c->mode ));
}

#endif

struct qemu_glBeginConditionalRenderNVX
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginConditionalRenderNVX( GLuint id )
{
    struct qemu_glBeginConditionalRenderNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINCONDITIONALRENDERNVX);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginConditionalRenderNVX(struct qemu_syscall *call)
{
    struct qemu_glBeginConditionalRenderNVX *c = (struct qemu_glBeginConditionalRenderNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginConditionalRenderNVX( c->id ));
}

#endif

struct qemu_glBeginFragmentShaderATI
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginFragmentShaderATI(void)
{
    struct qemu_glBeginFragmentShaderATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINFRAGMENTSHADERATI);

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginFragmentShaderATI(struct qemu_syscall *call)
{
    struct qemu_glBeginFragmentShaderATI *c = (struct qemu_glBeginFragmentShaderATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginFragmentShaderATI());
}

#endif

struct qemu_glBeginOcclusionQueryNV
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginOcclusionQueryNV( GLuint id )
{
    struct qemu_glBeginOcclusionQueryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINOCCLUSIONQUERYNV);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginOcclusionQueryNV(struct qemu_syscall *call)
{
    struct qemu_glBeginOcclusionQueryNV *c = (struct qemu_glBeginOcclusionQueryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginOcclusionQueryNV( c->id ));
}

#endif

struct qemu_glBeginPerfMonitorAMD
{
    struct qemu_syscall super;
    uint64_t monitor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginPerfMonitorAMD( GLuint monitor )
{
    struct qemu_glBeginPerfMonitorAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINPERFMONITORAMD);
    call.monitor = monitor;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginPerfMonitorAMD(struct qemu_syscall *call)
{
    struct qemu_glBeginPerfMonitorAMD *c = (struct qemu_glBeginPerfMonitorAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginPerfMonitorAMD( c->monitor ));
}

#endif

struct qemu_glBeginPerfQueryINTEL
{
    struct qemu_syscall super;
    uint64_t queryHandle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginPerfQueryINTEL( GLuint queryHandle )
{
    struct qemu_glBeginPerfQueryINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINPERFQUERYINTEL);
    call.queryHandle = queryHandle;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginPerfQueryINTEL(struct qemu_syscall *call)
{
    struct qemu_glBeginPerfQueryINTEL *c = (struct qemu_glBeginPerfQueryINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginPerfQueryINTEL( c->queryHandle ));
}

#endif

struct qemu_glBeginQuery
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginQuery( GLenum target, GLuint id )
{
    struct qemu_glBeginQuery call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINQUERY);
    call.target = target;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginQuery(struct qemu_syscall *call)
{
    struct qemu_glBeginQuery *c = (struct qemu_glBeginQuery *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginQuery( c->target, c->id ));
}

#endif

struct qemu_glBeginQueryARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginQueryARB( GLenum target, GLuint id )
{
    struct qemu_glBeginQueryARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINQUERYARB);
    call.target = target;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginQueryARB(struct qemu_syscall *call)
{
    struct qemu_glBeginQueryARB *c = (struct qemu_glBeginQueryARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginQueryARB( c->target, c->id ));
}

#endif

struct qemu_glBeginQueryIndexed
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginQueryIndexed( GLenum target, GLuint index, GLuint id )
{
    struct qemu_glBeginQueryIndexed call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINQUERYINDEXED);
    call.target = target;
    call.index = index;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginQueryIndexed(struct qemu_syscall *call)
{
    struct qemu_glBeginQueryIndexed *c = (struct qemu_glBeginQueryIndexed *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginQueryIndexed( c->target, c->index, c->id ));
}

#endif

struct qemu_glBeginTransformFeedback
{
    struct qemu_syscall super;
    uint64_t primitiveMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginTransformFeedback( GLenum primitiveMode )
{
    struct qemu_glBeginTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINTRANSFORMFEEDBACK);
    call.primitiveMode = primitiveMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glBeginTransformFeedback *c = (struct qemu_glBeginTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginTransformFeedback( c->primitiveMode ));
}

#endif

struct qemu_glBeginTransformFeedbackEXT
{
    struct qemu_syscall super;
    uint64_t primitiveMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginTransformFeedbackEXT( GLenum primitiveMode )
{
    struct qemu_glBeginTransformFeedbackEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINTRANSFORMFEEDBACKEXT);
    call.primitiveMode = primitiveMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginTransformFeedbackEXT(struct qemu_syscall *call)
{
    struct qemu_glBeginTransformFeedbackEXT *c = (struct qemu_glBeginTransformFeedbackEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginTransformFeedbackEXT( c->primitiveMode ));
}

#endif

struct qemu_glBeginTransformFeedbackNV
{
    struct qemu_syscall super;
    uint64_t primitiveMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginTransformFeedbackNV( GLenum primitiveMode )
{
    struct qemu_glBeginTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINTRANSFORMFEEDBACKNV);
    call.primitiveMode = primitiveMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glBeginTransformFeedbackNV *c = (struct qemu_glBeginTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginTransformFeedbackNV( c->primitiveMode ));
}

#endif

struct qemu_glBeginVertexShaderEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginVertexShaderEXT(void)
{
    struct qemu_glBeginVertexShaderEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINVERTEXSHADEREXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginVertexShaderEXT(struct qemu_syscall *call)
{
    struct qemu_glBeginVertexShaderEXT *c = (struct qemu_glBeginVertexShaderEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginVertexShaderEXT());
}

#endif

struct qemu_glBeginVideoCaptureNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBeginVideoCaptureNV( GLuint video_capture_slot )
{
    struct qemu_glBeginVideoCaptureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBEGINVIDEOCAPTURENV);
    call.video_capture_slot = video_capture_slot;

    qemu_syscall(&call.super);
}

#else

void qemu_glBeginVideoCaptureNV(struct qemu_syscall *call)
{
    struct qemu_glBeginVideoCaptureNV *c = (struct qemu_glBeginVideoCaptureNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBeginVideoCaptureNV( c->video_capture_slot ));
}

#endif

struct qemu_glBindAttribLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindAttribLocation( GLuint program, GLuint index, const GLchar *name )
{
    struct qemu_glBindAttribLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDATTRIBLOCATION);
    call.program = program;
    call.index = index;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindAttribLocation(struct qemu_syscall *call)
{
    struct qemu_glBindAttribLocation *c = (struct qemu_glBindAttribLocation *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindAttribLocation( c->program, c->index, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glBindAttribLocationARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t index;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindAttribLocationARB( GLhandleARB programObj, GLuint index, const GLcharARB *name )
{
    struct qemu_glBindAttribLocationARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDATTRIBLOCATIONARB);
    call.programObj = programObj;
    call.index = index;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindAttribLocationARB(struct qemu_syscall *call)
{
    struct qemu_glBindAttribLocationARB *c = (struct qemu_glBindAttribLocationARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindAttribLocationARB( c->programObj, c->index, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glBindBuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBuffer( GLenum target, GLuint buffer )
{
    struct qemu_glBindBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFER);
    call.target = target;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBuffer(struct qemu_syscall *call)
{
    struct qemu_glBindBuffer *c = (struct qemu_glBindBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBuffer( c->target, c->buffer ));
}

#endif

struct qemu_glBindBufferARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferARB( GLenum target, GLuint buffer )
{
    struct qemu_glBindBufferARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERARB);
    call.target = target;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferARB(struct qemu_syscall *call)
{
    struct qemu_glBindBufferARB *c = (struct qemu_glBindBufferARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferARB( c->target, c->buffer ));
}

#endif

struct qemu_glBindBufferBase
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferBase( GLenum target, GLuint index, GLuint buffer )
{
    struct qemu_glBindBufferBase call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERBASE);
    call.target = target;
    call.index = index;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferBase(struct qemu_syscall *call)
{
    struct qemu_glBindBufferBase *c = (struct qemu_glBindBufferBase *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferBase( c->target, c->index, c->buffer ));
}

#endif

struct qemu_glBindBufferBaseEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferBaseEXT( GLenum target, GLuint index, GLuint buffer )
{
    struct qemu_glBindBufferBaseEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERBASEEXT);
    call.target = target;
    call.index = index;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferBaseEXT(struct qemu_syscall *call)
{
    struct qemu_glBindBufferBaseEXT *c = (struct qemu_glBindBufferBaseEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferBaseEXT( c->target, c->index, c->buffer ));
}

#endif

struct qemu_glBindBufferBaseNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferBaseNV( GLenum target, GLuint index, GLuint buffer )
{
    struct qemu_glBindBufferBaseNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERBASENV);
    call.target = target;
    call.index = index;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferBaseNV(struct qemu_syscall *call)
{
    struct qemu_glBindBufferBaseNV *c = (struct qemu_glBindBufferBaseNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferBaseNV( c->target, c->index, c->buffer ));
}

#endif

struct qemu_glBindBufferOffsetEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferOffsetEXT( GLenum target, GLuint index, GLuint buffer, GLintptr offset )
{
    struct qemu_glBindBufferOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFEROFFSETEXT);
    call.target = target;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glBindBufferOffsetEXT *c = (struct qemu_glBindBufferOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferOffsetEXT( c->target, c->index, c->buffer, c->offset ));
}

#endif

struct qemu_glBindBufferOffsetNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferOffsetNV( GLenum target, GLuint index, GLuint buffer, GLintptr offset )
{
    struct qemu_glBindBufferOffsetNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFEROFFSETNV);
    call.target = target;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferOffsetNV(struct qemu_syscall *call)
{
    struct qemu_glBindBufferOffsetNV *c = (struct qemu_glBindBufferOffsetNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferOffsetNV( c->target, c->index, c->buffer, c->offset ));
}

#endif

struct qemu_glBindBufferRange
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferRange( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glBindBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERRANGE);
    call.target = target;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferRange(struct qemu_syscall *call)
{
    struct qemu_glBindBufferRange *c = (struct qemu_glBindBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferRange( c->target, c->index, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glBindBufferRangeEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferRangeEXT( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glBindBufferRangeEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERRANGEEXT);
    call.target = target;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferRangeEXT(struct qemu_syscall *call)
{
    struct qemu_glBindBufferRangeEXT *c = (struct qemu_glBindBufferRangeEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferRangeEXT( c->target, c->index, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glBindBufferRangeNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBufferRangeNV( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glBindBufferRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERRANGENV);
    call.target = target;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBufferRangeNV(struct qemu_syscall *call)
{
    struct qemu_glBindBufferRangeNV *c = (struct qemu_glBindBufferRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBufferRangeNV( c->target, c->index, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glBindBuffersBase
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t first;
    uint64_t count;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBuffersBase( GLenum target, GLuint first, GLsizei count, const GLuint *buffers )
{
    struct qemu_glBindBuffersBase call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERSBASE);
    call.target = target;
    call.first = first;
    call.count = count;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBuffersBase(struct qemu_syscall *call)
{
    struct qemu_glBindBuffersBase *c = (struct qemu_glBindBuffersBase *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBuffersBase( c->target, c->first, c->count, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glBindBuffersRange
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t first;
    uint64_t count;
    uint64_t buffers;
    uint64_t offsets;
    uint64_t sizes;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindBuffersRange( GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes )
{
    struct qemu_glBindBuffersRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDBUFFERSRANGE);
    call.target = target;
    call.first = first;
    call.count = count;
    call.buffers = (ULONG_PTR)buffers;
    call.offsets = (ULONG_PTR)offsets;
    call.sizes = (ULONG_PTR)sizes;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindBuffersRange(struct qemu_syscall *call)
{
    struct qemu_glBindBuffersRange *c = (struct qemu_glBindBuffersRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindBuffersRange( c->target, c->first, c->count, QEMU_G2H(c->buffers), QEMU_G2H(c->offsets), QEMU_G2H(c->sizes) ));
}

#endif

struct qemu_glBindFragDataLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t color;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFragDataLocation( GLuint program, GLuint color, const GLchar *name )
{
    struct qemu_glBindFragDataLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAGDATALOCATION);
    call.program = program;
    call.color = color;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFragDataLocation(struct qemu_syscall *call)
{
    struct qemu_glBindFragDataLocation *c = (struct qemu_glBindFragDataLocation *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFragDataLocation( c->program, c->color, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glBindFragDataLocationEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t color;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFragDataLocationEXT( GLuint program, GLuint color, const GLchar *name )
{
    struct qemu_glBindFragDataLocationEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAGDATALOCATIONEXT);
    call.program = program;
    call.color = color;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFragDataLocationEXT(struct qemu_syscall *call)
{
    struct qemu_glBindFragDataLocationEXT *c = (struct qemu_glBindFragDataLocationEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFragDataLocationEXT( c->program, c->color, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glBindFragDataLocationIndexed
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t colorNumber;
    uint64_t index;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFragDataLocationIndexed( GLuint program, GLuint colorNumber, GLuint index, const GLchar *name )
{
    struct qemu_glBindFragDataLocationIndexed call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAGDATALOCATIONINDEXED);
    call.program = program;
    call.colorNumber = colorNumber;
    call.index = index;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFragDataLocationIndexed(struct qemu_syscall *call)
{
    struct qemu_glBindFragDataLocationIndexed *c = (struct qemu_glBindFragDataLocationIndexed *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFragDataLocationIndexed( c->program, c->colorNumber, c->index, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glBindFragmentShaderATI
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFragmentShaderATI( GLuint id )
{
    struct qemu_glBindFragmentShaderATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAGMENTSHADERATI);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFragmentShaderATI(struct qemu_syscall *call)
{
    struct qemu_glBindFragmentShaderATI *c = (struct qemu_glBindFragmentShaderATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFragmentShaderATI( c->id ));
}

#endif

struct qemu_glBindFramebuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t framebuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFramebuffer( GLenum target, GLuint framebuffer )
{
    struct qemu_glBindFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAMEBUFFER);
    call.target = target;
    call.framebuffer = framebuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glBindFramebuffer *c = (struct qemu_glBindFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFramebuffer( c->target, c->framebuffer ));
}

#endif

struct qemu_glBindFramebufferEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t framebuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindFramebufferEXT( GLenum target, GLuint framebuffer )
{
    struct qemu_glBindFramebufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDFRAMEBUFFEREXT);
    call.target = target;
    call.framebuffer = framebuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindFramebufferEXT(struct qemu_syscall *call)
{
    struct qemu_glBindFramebufferEXT *c = (struct qemu_glBindFramebufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindFramebufferEXT( c->target, c->framebuffer ));
}

#endif

struct qemu_glBindImageTexture
{
    struct qemu_syscall super;
    uint64_t unit;
    uint64_t texture;
    uint64_t level;
    uint64_t layered;
    uint64_t layer;
    uint64_t access;
    uint64_t format;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindImageTexture( GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format )
{
    struct qemu_glBindImageTexture call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDIMAGETEXTURE);
    call.unit = unit;
    call.texture = texture;
    call.level = level;
    call.layered = layered;
    call.layer = layer;
    call.access = access;
    call.format = format;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindImageTexture(struct qemu_syscall *call)
{
    struct qemu_glBindImageTexture *c = (struct qemu_glBindImageTexture *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindImageTexture( c->unit, c->texture, c->level, c->layered, c->layer, c->access, c->format ));
}

#endif

struct qemu_glBindImageTextureEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t texture;
    uint64_t level;
    uint64_t layered;
    uint64_t layer;
    uint64_t access;
    uint64_t format;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindImageTextureEXT( GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format )
{
    struct qemu_glBindImageTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDIMAGETEXTUREEXT);
    call.index = index;
    call.texture = texture;
    call.level = level;
    call.layered = layered;
    call.layer = layer;
    call.access = access;
    call.format = format;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindImageTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glBindImageTextureEXT *c = (struct qemu_glBindImageTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindImageTextureEXT( c->index, c->texture, c->level, c->layered, c->layer, c->access, c->format ));
}

#endif

struct qemu_glBindImageTextures
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t textures;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindImageTextures( GLuint first, GLsizei count, const GLuint *textures )
{
    struct qemu_glBindImageTextures call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDIMAGETEXTURES);
    call.first = first;
    call.count = count;
    call.textures = (ULONG_PTR)textures;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindImageTextures(struct qemu_syscall *call)
{
    struct qemu_glBindImageTextures *c = (struct qemu_glBindImageTextures *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindImageTextures( c->first, c->count, QEMU_G2H(c->textures) ));
}

#endif

struct qemu_glBindLightParameterEXT
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBindLightParameterEXT( GLenum light, GLenum value )
{
    struct qemu_glBindLightParameterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDLIGHTPARAMETEREXT);
    call.light = light;
    call.value = value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBindLightParameterEXT(struct qemu_syscall *call)
{
    struct qemu_glBindLightParameterEXT *c = (struct qemu_glBindLightParameterEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBindLightParameterEXT( c->light, c->value ));
}

#endif

struct qemu_glBindMaterialParameterEXT
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBindMaterialParameterEXT( GLenum face, GLenum value )
{
    struct qemu_glBindMaterialParameterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDMATERIALPARAMETEREXT);
    call.face = face;
    call.value = value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBindMaterialParameterEXT(struct qemu_syscall *call)
{
    struct qemu_glBindMaterialParameterEXT *c = (struct qemu_glBindMaterialParameterEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBindMaterialParameterEXT( c->face, c->value ));
}

#endif

struct qemu_glBindMultiTextureEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindMultiTextureEXT( GLenum texunit, GLenum target, GLuint texture )
{
    struct qemu_glBindMultiTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDMULTITEXTUREEXT);
    call.texunit = texunit;
    call.target = target;
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindMultiTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glBindMultiTextureEXT *c = (struct qemu_glBindMultiTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindMultiTextureEXT( c->texunit, c->target, c->texture ));
}

#endif

struct qemu_glBindParameterEXT
{
    struct qemu_syscall super;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBindParameterEXT( GLenum value )
{
    struct qemu_glBindParameterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDPARAMETEREXT);
    call.value = value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBindParameterEXT(struct qemu_syscall *call)
{
    struct qemu_glBindParameterEXT *c = (struct qemu_glBindParameterEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBindParameterEXT( c->value ));
}

#endif

struct qemu_glBindProgramARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindProgramARB( GLenum target, GLuint program )
{
    struct qemu_glBindProgramARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDPROGRAMARB);
    call.target = target;
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindProgramARB(struct qemu_syscall *call)
{
    struct qemu_glBindProgramARB *c = (struct qemu_glBindProgramARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindProgramARB( c->target, c->program ));
}

#endif

struct qemu_glBindProgramNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindProgramNV( GLenum target, GLuint id )
{
    struct qemu_glBindProgramNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDPROGRAMNV);
    call.target = target;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindProgramNV(struct qemu_syscall *call)
{
    struct qemu_glBindProgramNV *c = (struct qemu_glBindProgramNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindProgramNV( c->target, c->id ));
}

#endif

struct qemu_glBindProgramPipeline
{
    struct qemu_syscall super;
    uint64_t pipeline;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindProgramPipeline( GLuint pipeline )
{
    struct qemu_glBindProgramPipeline call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDPROGRAMPIPELINE);
    call.pipeline = pipeline;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindProgramPipeline(struct qemu_syscall *call)
{
    struct qemu_glBindProgramPipeline *c = (struct qemu_glBindProgramPipeline *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindProgramPipeline( c->pipeline ));
}

#endif

struct qemu_glBindRenderbuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindRenderbuffer( GLenum target, GLuint renderbuffer )
{
    struct qemu_glBindRenderbuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDRENDERBUFFER);
    call.target = target;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindRenderbuffer(struct qemu_syscall *call)
{
    struct qemu_glBindRenderbuffer *c = (struct qemu_glBindRenderbuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindRenderbuffer( c->target, c->renderbuffer ));
}

#endif

struct qemu_glBindRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindRenderbufferEXT( GLenum target, GLuint renderbuffer )
{
    struct qemu_glBindRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDRENDERBUFFEREXT);
    call.target = target;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glBindRenderbufferEXT *c = (struct qemu_glBindRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindRenderbufferEXT( c->target, c->renderbuffer ));
}

#endif

struct qemu_glBindSampler
{
    struct qemu_syscall super;
    uint64_t unit;
    uint64_t sampler;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindSampler( GLuint unit, GLuint sampler )
{
    struct qemu_glBindSampler call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDSAMPLER);
    call.unit = unit;
    call.sampler = sampler;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindSampler(struct qemu_syscall *call)
{
    struct qemu_glBindSampler *c = (struct qemu_glBindSampler *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindSampler( c->unit, c->sampler ));
}

#endif

struct qemu_glBindSamplers
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t samplers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindSamplers( GLuint first, GLsizei count, const GLuint *samplers )
{
    struct qemu_glBindSamplers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDSAMPLERS);
    call.first = first;
    call.count = count;
    call.samplers = (ULONG_PTR)samplers;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindSamplers(struct qemu_syscall *call)
{
    struct qemu_glBindSamplers *c = (struct qemu_glBindSamplers *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindSamplers( c->first, c->count, QEMU_G2H(c->samplers) ));
}

#endif

struct qemu_glBindShadingRateImageNV
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindShadingRateImageNV( GLuint texture )
{
    struct qemu_glBindShadingRateImageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDSHADINGRATEIMAGENV);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindShadingRateImageNV(struct qemu_syscall *call)
{
    struct qemu_glBindShadingRateImageNV *c = (struct qemu_glBindShadingRateImageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindShadingRateImageNV( c->texture ));
}

#endif

struct qemu_glBindTexGenParameterEXT
{
    struct qemu_syscall super;
    uint64_t unit;
    uint64_t coord;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBindTexGenParameterEXT( GLenum unit, GLenum coord, GLenum value )
{
    struct qemu_glBindTexGenParameterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTEXGENPARAMETEREXT);
    call.unit = unit;
    call.coord = coord;
    call.value = value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBindTexGenParameterEXT(struct qemu_syscall *call)
{
    struct qemu_glBindTexGenParameterEXT *c = (struct qemu_glBindTexGenParameterEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBindTexGenParameterEXT( c->unit, c->coord, c->value ));
}

#endif

struct qemu_glBindTextureEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindTextureEXT( GLenum target, GLuint texture )
{
    struct qemu_glBindTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTEXTUREEXT);
    call.target = target;
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glBindTextureEXT *c = (struct qemu_glBindTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindTextureEXT( c->target, c->texture ));
}

#endif

struct qemu_glBindTextureUnit
{
    struct qemu_syscall super;
    uint64_t unit;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindTextureUnit( GLuint unit, GLuint texture )
{
    struct qemu_glBindTextureUnit call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTEXTUREUNIT);
    call.unit = unit;
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindTextureUnit(struct qemu_syscall *call)
{
    struct qemu_glBindTextureUnit *c = (struct qemu_glBindTextureUnit *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindTextureUnit( c->unit, c->texture ));
}

#endif

struct qemu_glBindTextureUnitParameterEXT
{
    struct qemu_syscall super;
    uint64_t unit;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBindTextureUnitParameterEXT( GLenum unit, GLenum value )
{
    struct qemu_glBindTextureUnitParameterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTEXTUREUNITPARAMETEREXT);
    call.unit = unit;
    call.value = value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBindTextureUnitParameterEXT(struct qemu_syscall *call)
{
    struct qemu_glBindTextureUnitParameterEXT *c = (struct qemu_glBindTextureUnitParameterEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBindTextureUnitParameterEXT( c->unit, c->value ));
}

#endif

struct qemu_glBindTextures
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t textures;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindTextures( GLuint first, GLsizei count, const GLuint *textures )
{
    struct qemu_glBindTextures call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTEXTURES);
    call.first = first;
    call.count = count;
    call.textures = (ULONG_PTR)textures;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindTextures(struct qemu_syscall *call)
{
    struct qemu_glBindTextures *c = (struct qemu_glBindTextures *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindTextures( c->first, c->count, QEMU_G2H(c->textures) ));
}

#endif

struct qemu_glBindTransformFeedback
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindTransformFeedback( GLenum target, GLuint id )
{
    struct qemu_glBindTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTRANSFORMFEEDBACK);
    call.target = target;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glBindTransformFeedback *c = (struct qemu_glBindTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindTransformFeedback( c->target, c->id ));
}

#endif

struct qemu_glBindTransformFeedbackNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindTransformFeedbackNV( GLenum target, GLuint id )
{
    struct qemu_glBindTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDTRANSFORMFEEDBACKNV);
    call.target = target;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glBindTransformFeedbackNV *c = (struct qemu_glBindTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindTransformFeedbackNV( c->target, c->id ));
}

#endif

struct qemu_glBindVertexArray
{
    struct qemu_syscall super;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVertexArray( GLuint array )
{
    struct qemu_glBindVertexArray call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVERTEXARRAY);
    call.array = array;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVertexArray(struct qemu_syscall *call)
{
    struct qemu_glBindVertexArray *c = (struct qemu_glBindVertexArray *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVertexArray( c->array ));
}

#endif

struct qemu_glBindVertexArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVertexArrayAPPLE( GLuint array )
{
    struct qemu_glBindVertexArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVERTEXARRAYAPPLE);
    call.array = array;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVertexArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glBindVertexArrayAPPLE *c = (struct qemu_glBindVertexArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVertexArrayAPPLE( c->array ));
}

#endif

struct qemu_glBindVertexBuffer
{
    struct qemu_syscall super;
    uint64_t bindingindex;
    uint64_t buffer;
    uint64_t offset;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVertexBuffer( GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride )
{
    struct qemu_glBindVertexBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVERTEXBUFFER);
    call.bindingindex = bindingindex;
    call.buffer = buffer;
    call.offset = offset;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVertexBuffer(struct qemu_syscall *call)
{
    struct qemu_glBindVertexBuffer *c = (struct qemu_glBindVertexBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVertexBuffer( c->bindingindex, c->buffer, c->offset, c->stride ));
}

#endif

struct qemu_glBindVertexBuffers
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t buffers;
    uint64_t offsets;
    uint64_t strides;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVertexBuffers( GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides )
{
    struct qemu_glBindVertexBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVERTEXBUFFERS);
    call.first = first;
    call.count = count;
    call.buffers = (ULONG_PTR)buffers;
    call.offsets = (ULONG_PTR)offsets;
    call.strides = (ULONG_PTR)strides;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVertexBuffers(struct qemu_syscall *call)
{
    struct qemu_glBindVertexBuffers *c = (struct qemu_glBindVertexBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVertexBuffers( c->first, c->count, QEMU_G2H(c->buffers), QEMU_G2H(c->offsets), QEMU_G2H(c->strides) ));
}

#endif

struct qemu_glBindVertexShaderEXT
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVertexShaderEXT( GLuint id )
{
    struct qemu_glBindVertexShaderEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVERTEXSHADEREXT);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVertexShaderEXT(struct qemu_syscall *call)
{
    struct qemu_glBindVertexShaderEXT *c = (struct qemu_glBindVertexShaderEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVertexShaderEXT( c->id ));
}

#endif

struct qemu_glBindVideoCaptureStreamBufferNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t frame_region;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVideoCaptureStreamBufferNV( GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset )
{
    struct qemu_glBindVideoCaptureStreamBufferNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVIDEOCAPTURESTREAMBUFFERNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.frame_region = frame_region;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVideoCaptureStreamBufferNV(struct qemu_syscall *call)
{
    struct qemu_glBindVideoCaptureStreamBufferNV *c = (struct qemu_glBindVideoCaptureStreamBufferNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVideoCaptureStreamBufferNV( c->video_capture_slot, c->stream, c->frame_region, c->offset ));
}

#endif

struct qemu_glBindVideoCaptureStreamTextureNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t frame_region;
    uint64_t target;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBindVideoCaptureStreamTextureNV( GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture )
{
    struct qemu_glBindVideoCaptureStreamTextureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINDVIDEOCAPTURESTREAMTEXTURENV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.frame_region = frame_region;
    call.target = target;
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glBindVideoCaptureStreamTextureNV(struct qemu_syscall *call)
{
    struct qemu_glBindVideoCaptureStreamTextureNV *c = (struct qemu_glBindVideoCaptureStreamTextureNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBindVideoCaptureStreamTextureNV( c->video_capture_slot, c->stream, c->frame_region, c->target, c->texture ));
}

#endif

struct qemu_glBinormal3bEXT
{
    struct qemu_syscall super;
    uint64_t bx;
    uint64_t by;
    uint64_t bz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3bEXT( GLbyte bx, GLbyte by, GLbyte bz )
{
    struct qemu_glBinormal3bEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3BEXT);
    call.bx = bx;
    call.by = by;
    call.bz = bz;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3bEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3bEXT *c = (struct qemu_glBinormal3bEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3bEXT( c->bx, c->by, c->bz ));
}

#endif

struct qemu_glBinormal3bvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3bvEXT( const GLbyte *v )
{
    struct qemu_glBinormal3bvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3BVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3bvEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3bvEXT *c = (struct qemu_glBinormal3bvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3bvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glBinormal3dEXT
{
    struct qemu_syscall super;
    double bx;
    double by;
    double bz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3dEXT( GLdouble bx, GLdouble by, GLdouble bz )
{
    struct qemu_glBinormal3dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3DEXT);
    call.bx = bx;
    call.by = by;
    call.bz = bz;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3dEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3dEXT *c = (struct qemu_glBinormal3dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3dEXT( c->bx, c->by, c->bz ));
}

#endif

struct qemu_glBinormal3dvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3dvEXT( const GLdouble *v )
{
    struct qemu_glBinormal3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3DVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3dvEXT *c = (struct qemu_glBinormal3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3dvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glBinormal3fEXT
{
    struct qemu_syscall super;
    double bx;
    double by;
    double bz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3fEXT( GLfloat bx, GLfloat by, GLfloat bz )
{
    struct qemu_glBinormal3fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3FEXT);
    call.bx = bx;
    call.by = by;
    call.bz = bz;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3fEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3fEXT *c = (struct qemu_glBinormal3fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3fEXT( c->bx, c->by, c->bz ));
}

#endif

struct qemu_glBinormal3fvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3fvEXT( const GLfloat *v )
{
    struct qemu_glBinormal3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3FVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3fvEXT *c = (struct qemu_glBinormal3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3fvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glBinormal3iEXT
{
    struct qemu_syscall super;
    uint64_t bx;
    uint64_t by;
    uint64_t bz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3iEXT( GLint bx, GLint by, GLint bz )
{
    struct qemu_glBinormal3iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3IEXT);
    call.bx = bx;
    call.by = by;
    call.bz = bz;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3iEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3iEXT *c = (struct qemu_glBinormal3iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3iEXT( c->bx, c->by, c->bz ));
}

#endif

struct qemu_glBinormal3ivEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3ivEXT( const GLint *v )
{
    struct qemu_glBinormal3ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3IVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3ivEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3ivEXT *c = (struct qemu_glBinormal3ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3ivEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glBinormal3sEXT
{
    struct qemu_syscall super;
    uint64_t bx;
    uint64_t by;
    uint64_t bz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3sEXT( GLshort bx, GLshort by, GLshort bz )
{
    struct qemu_glBinormal3sEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3SEXT);
    call.bx = bx;
    call.by = by;
    call.bz = bz;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3sEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3sEXT *c = (struct qemu_glBinormal3sEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3sEXT( c->bx, c->by, c->bz ));
}

#endif

struct qemu_glBinormal3svEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormal3svEXT( const GLshort *v )
{
    struct qemu_glBinormal3svEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMAL3SVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormal3svEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormal3svEXT *c = (struct qemu_glBinormal3svEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormal3svEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glBinormalPointerEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBinormalPointerEXT( GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glBinormalPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBINORMALPOINTEREXT);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glBinormalPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glBinormalPointerEXT *c = (struct qemu_glBinormalPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBinormalPointerEXT( c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glBitmapxOES
{
    struct qemu_syscall super;
    uint64_t width;
    uint64_t height;
    uint64_t xorig;
    uint64_t yorig;
    uint64_t xmove;
    uint64_t ymove;
    uint64_t bitmap;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBitmapxOES( GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap )
{
    struct qemu_glBitmapxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBITMAPXOES);
    call.width = width;
    call.height = height;
    call.xorig = xorig;
    call.yorig = yorig;
    call.xmove = xmove;
    call.ymove = ymove;
    call.bitmap = (ULONG_PTR)bitmap;

    qemu_syscall(&call.super);
}

#else

void qemu_glBitmapxOES(struct qemu_syscall *call)
{
    struct qemu_glBitmapxOES *c = (struct qemu_glBitmapxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glBitmapxOES( c->width, c->height, c->xorig, c->yorig, c->xmove, c->ymove, QEMU_G2H(c->bitmap) ));
}

#endif

struct qemu_glBlendBarrierKHR
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendBarrierKHR(void)
{
    struct qemu_glBlendBarrierKHR call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDBARRIERKHR);

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendBarrierKHR(struct qemu_syscall *call)
{
    struct qemu_glBlendBarrierKHR *c = (struct qemu_glBlendBarrierKHR *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendBarrierKHR());
}

#endif

struct qemu_glBlendBarrierNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendBarrierNV(void)
{
    struct qemu_glBlendBarrierNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDBARRIERNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendBarrierNV(struct qemu_syscall *call)
{
    struct qemu_glBlendBarrierNV *c = (struct qemu_glBlendBarrierNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendBarrierNV());
}

#endif

struct qemu_glBlendColor
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
    double alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendColor( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
    struct qemu_glBlendColor call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDCOLOR);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendColor(struct qemu_syscall *call)
{
    struct qemu_glBlendColor *c = (struct qemu_glBlendColor *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendColor( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glBlendColorEXT
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
    double alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendColorEXT( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
    struct qemu_glBlendColorEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDCOLOREXT);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendColorEXT(struct qemu_syscall *call)
{
    struct qemu_glBlendColorEXT *c = (struct qemu_glBlendColorEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendColorEXT( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glBlendColorxOES
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendColorxOES( GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha )
{
    struct qemu_glBlendColorxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDCOLORXOES);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendColorxOES(struct qemu_syscall *call)
{
    struct qemu_glBlendColorxOES *c = (struct qemu_glBlendColorxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendColorxOES( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glBlendEquation
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquation( GLenum mode )
{
    struct qemu_glBlendEquation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATION);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquation(struct qemu_syscall *call)
{
    struct qemu_glBlendEquation *c = (struct qemu_glBlendEquation *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquation( c->mode ));
}

#endif

struct qemu_glBlendEquationEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationEXT( GLenum mode )
{
    struct qemu_glBlendEquationEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationEXT(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationEXT *c = (struct qemu_glBlendEquationEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationEXT( c->mode ));
}

#endif

struct qemu_glBlendEquationIndexedAMD
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationIndexedAMD( GLuint buf, GLenum mode )
{
    struct qemu_glBlendEquationIndexedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONINDEXEDAMD);
    call.buf = buf;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationIndexedAMD(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationIndexedAMD *c = (struct qemu_glBlendEquationIndexedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationIndexedAMD( c->buf, c->mode ));
}

#endif

struct qemu_glBlendEquationSeparate
{
    struct qemu_syscall super;
    uint64_t modeRGB;
    uint64_t modeAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationSeparate( GLenum modeRGB, GLenum modeAlpha )
{
    struct qemu_glBlendEquationSeparate call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONSEPARATE);
    call.modeRGB = modeRGB;
    call.modeAlpha = modeAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationSeparate(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationSeparate *c = (struct qemu_glBlendEquationSeparate *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationSeparate( c->modeRGB, c->modeAlpha ));
}

#endif

struct qemu_glBlendEquationSeparateEXT
{
    struct qemu_syscall super;
    uint64_t modeRGB;
    uint64_t modeAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationSeparateEXT( GLenum modeRGB, GLenum modeAlpha )
{
    struct qemu_glBlendEquationSeparateEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONSEPARATEEXT);
    call.modeRGB = modeRGB;
    call.modeAlpha = modeAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationSeparateEXT(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationSeparateEXT *c = (struct qemu_glBlendEquationSeparateEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationSeparateEXT( c->modeRGB, c->modeAlpha ));
}

#endif

struct qemu_glBlendEquationSeparateIndexedAMD
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t modeRGB;
    uint64_t modeAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationSeparateIndexedAMD( GLuint buf, GLenum modeRGB, GLenum modeAlpha )
{
    struct qemu_glBlendEquationSeparateIndexedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONSEPARATEINDEXEDAMD);
    call.buf = buf;
    call.modeRGB = modeRGB;
    call.modeAlpha = modeAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationSeparateIndexedAMD(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationSeparateIndexedAMD *c = (struct qemu_glBlendEquationSeparateIndexedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationSeparateIndexedAMD( c->buf, c->modeRGB, c->modeAlpha ));
}

#endif

struct qemu_glBlendEquationSeparatei
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t modeRGB;
    uint64_t modeAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationSeparatei( GLuint buf, GLenum modeRGB, GLenum modeAlpha )
{
    struct qemu_glBlendEquationSeparatei call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONSEPARATEI);
    call.buf = buf;
    call.modeRGB = modeRGB;
    call.modeAlpha = modeAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationSeparatei(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationSeparatei *c = (struct qemu_glBlendEquationSeparatei *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationSeparatei( c->buf, c->modeRGB, c->modeAlpha ));
}

#endif

struct qemu_glBlendEquationSeparateiARB
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t modeRGB;
    uint64_t modeAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationSeparateiARB( GLuint buf, GLenum modeRGB, GLenum modeAlpha )
{
    struct qemu_glBlendEquationSeparateiARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONSEPARATEIARB);
    call.buf = buf;
    call.modeRGB = modeRGB;
    call.modeAlpha = modeAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationSeparateiARB(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationSeparateiARB *c = (struct qemu_glBlendEquationSeparateiARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationSeparateiARB( c->buf, c->modeRGB, c->modeAlpha ));
}

#endif

struct qemu_glBlendEquationi
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationi( GLuint buf, GLenum mode )
{
    struct qemu_glBlendEquationi call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONI);
    call.buf = buf;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationi(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationi *c = (struct qemu_glBlendEquationi *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationi( c->buf, c->mode ));
}

#endif

struct qemu_glBlendEquationiARB
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendEquationiARB( GLuint buf, GLenum mode )
{
    struct qemu_glBlendEquationiARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDEQUATIONIARB);
    call.buf = buf;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendEquationiARB(struct qemu_syscall *call)
{
    struct qemu_glBlendEquationiARB *c = (struct qemu_glBlendEquationiARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendEquationiARB( c->buf, c->mode ));
}

#endif

struct qemu_glBlendFuncIndexedAMD
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t src;
    uint64_t dst;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncIndexedAMD( GLuint buf, GLenum src, GLenum dst )
{
    struct qemu_glBlendFuncIndexedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCINDEXEDAMD);
    call.buf = buf;
    call.src = src;
    call.dst = dst;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncIndexedAMD(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncIndexedAMD *c = (struct qemu_glBlendFuncIndexedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncIndexedAMD( c->buf, c->src, c->dst ));
}

#endif

struct qemu_glBlendFuncSeparate
{
    struct qemu_syscall super;
    uint64_t sfactorRGB;
    uint64_t dfactorRGB;
    uint64_t sfactorAlpha;
    uint64_t dfactorAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparate( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha )
{
    struct qemu_glBlendFuncSeparate call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATE);
    call.sfactorRGB = sfactorRGB;
    call.dfactorRGB = dfactorRGB;
    call.sfactorAlpha = sfactorAlpha;
    call.dfactorAlpha = dfactorAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparate(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparate *c = (struct qemu_glBlendFuncSeparate *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparate( c->sfactorRGB, c->dfactorRGB, c->sfactorAlpha, c->dfactorAlpha ));
}

#endif

struct qemu_glBlendFuncSeparateEXT
{
    struct qemu_syscall super;
    uint64_t sfactorRGB;
    uint64_t dfactorRGB;
    uint64_t sfactorAlpha;
    uint64_t dfactorAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparateEXT( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha )
{
    struct qemu_glBlendFuncSeparateEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATEEXT);
    call.sfactorRGB = sfactorRGB;
    call.dfactorRGB = dfactorRGB;
    call.sfactorAlpha = sfactorAlpha;
    call.dfactorAlpha = dfactorAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparateEXT(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparateEXT *c = (struct qemu_glBlendFuncSeparateEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparateEXT( c->sfactorRGB, c->dfactorRGB, c->sfactorAlpha, c->dfactorAlpha ));
}

#endif

struct qemu_glBlendFuncSeparateINGR
{
    struct qemu_syscall super;
    uint64_t sfactorRGB;
    uint64_t dfactorRGB;
    uint64_t sfactorAlpha;
    uint64_t dfactorAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparateINGR( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha )
{
    struct qemu_glBlendFuncSeparateINGR call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATEINGR);
    call.sfactorRGB = sfactorRGB;
    call.dfactorRGB = dfactorRGB;
    call.sfactorAlpha = sfactorAlpha;
    call.dfactorAlpha = dfactorAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparateINGR(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparateINGR *c = (struct qemu_glBlendFuncSeparateINGR *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparateINGR( c->sfactorRGB, c->dfactorRGB, c->sfactorAlpha, c->dfactorAlpha ));
}

#endif

struct qemu_glBlendFuncSeparateIndexedAMD
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t srcRGB;
    uint64_t dstRGB;
    uint64_t srcAlpha;
    uint64_t dstAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparateIndexedAMD( GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha )
{
    struct qemu_glBlendFuncSeparateIndexedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATEINDEXEDAMD);
    call.buf = buf;
    call.srcRGB = srcRGB;
    call.dstRGB = dstRGB;
    call.srcAlpha = srcAlpha;
    call.dstAlpha = dstAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparateIndexedAMD(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparateIndexedAMD *c = (struct qemu_glBlendFuncSeparateIndexedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparateIndexedAMD( c->buf, c->srcRGB, c->dstRGB, c->srcAlpha, c->dstAlpha ));
}

#endif

struct qemu_glBlendFuncSeparatei
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t srcRGB;
    uint64_t dstRGB;
    uint64_t srcAlpha;
    uint64_t dstAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparatei( GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha )
{
    struct qemu_glBlendFuncSeparatei call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATEI);
    call.buf = buf;
    call.srcRGB = srcRGB;
    call.dstRGB = dstRGB;
    call.srcAlpha = srcAlpha;
    call.dstAlpha = dstAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparatei(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparatei *c = (struct qemu_glBlendFuncSeparatei *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparatei( c->buf, c->srcRGB, c->dstRGB, c->srcAlpha, c->dstAlpha ));
}

#endif

struct qemu_glBlendFuncSeparateiARB
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t srcRGB;
    uint64_t dstRGB;
    uint64_t srcAlpha;
    uint64_t dstAlpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFuncSeparateiARB( GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha )
{
    struct qemu_glBlendFuncSeparateiARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCSEPARATEIARB);
    call.buf = buf;
    call.srcRGB = srcRGB;
    call.dstRGB = dstRGB;
    call.srcAlpha = srcAlpha;
    call.dstAlpha = dstAlpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFuncSeparateiARB(struct qemu_syscall *call)
{
    struct qemu_glBlendFuncSeparateiARB *c = (struct qemu_glBlendFuncSeparateiARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFuncSeparateiARB( c->buf, c->srcRGB, c->dstRGB, c->srcAlpha, c->dstAlpha ));
}

#endif

struct qemu_glBlendFunci
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t src;
    uint64_t dst;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFunci( GLuint buf, GLenum src, GLenum dst )
{
    struct qemu_glBlendFunci call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCI);
    call.buf = buf;
    call.src = src;
    call.dst = dst;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFunci(struct qemu_syscall *call)
{
    struct qemu_glBlendFunci *c = (struct qemu_glBlendFunci *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFunci( c->buf, c->src, c->dst ));
}

#endif

struct qemu_glBlendFunciARB
{
    struct qemu_syscall super;
    uint64_t buf;
    uint64_t src;
    uint64_t dst;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendFunciARB( GLuint buf, GLenum src, GLenum dst )
{
    struct qemu_glBlendFunciARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDFUNCIARB);
    call.buf = buf;
    call.src = src;
    call.dst = dst;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendFunciARB(struct qemu_syscall *call)
{
    struct qemu_glBlendFunciARB *c = (struct qemu_glBlendFunciARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendFunciARB( c->buf, c->src, c->dst ));
}

#endif

struct qemu_glBlendParameteriNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlendParameteriNV( GLenum pname, GLint value )
{
    struct qemu_glBlendParameteriNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLENDPARAMETERINV);
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlendParameteriNV(struct qemu_syscall *call)
{
    struct qemu_glBlendParameteriNV *c = (struct qemu_glBlendParameteriNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlendParameteriNV( c->pname, c->value ));
}

#endif

struct qemu_glBlitFramebuffer
{
    struct qemu_syscall super;
    uint64_t srcX0;
    uint64_t srcY0;
    uint64_t srcX1;
    uint64_t srcY1;
    uint64_t dstX0;
    uint64_t dstY0;
    uint64_t dstX1;
    uint64_t dstY1;
    uint64_t mask;
    uint64_t filter;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlitFramebuffer( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter )
{
    struct qemu_glBlitFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLITFRAMEBUFFER);
    call.srcX0 = srcX0;
    call.srcY0 = srcY0;
    call.srcX1 = srcX1;
    call.srcY1 = srcY1;
    call.dstX0 = dstX0;
    call.dstY0 = dstY0;
    call.dstX1 = dstX1;
    call.dstY1 = dstY1;
    call.mask = mask;
    call.filter = filter;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlitFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glBlitFramebuffer *c = (struct qemu_glBlitFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlitFramebuffer( c->srcX0, c->srcY0, c->srcX1, c->srcY1, c->dstX0, c->dstY0, c->dstX1, c->dstY1, c->mask, c->filter ));
}

#endif

struct qemu_glBlitFramebufferEXT
{
    struct qemu_syscall super;
    uint64_t srcX0;
    uint64_t srcY0;
    uint64_t srcX1;
    uint64_t srcY1;
    uint64_t dstX0;
    uint64_t dstY0;
    uint64_t dstX1;
    uint64_t dstY1;
    uint64_t mask;
    uint64_t filter;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlitFramebufferEXT( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter )
{
    struct qemu_glBlitFramebufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLITFRAMEBUFFEREXT);
    call.srcX0 = srcX0;
    call.srcY0 = srcY0;
    call.srcX1 = srcX1;
    call.srcY1 = srcY1;
    call.dstX0 = dstX0;
    call.dstY0 = dstY0;
    call.dstX1 = dstX1;
    call.dstY1 = dstY1;
    call.mask = mask;
    call.filter = filter;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlitFramebufferEXT(struct qemu_syscall *call)
{
    struct qemu_glBlitFramebufferEXT *c = (struct qemu_glBlitFramebufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlitFramebufferEXT( c->srcX0, c->srcY0, c->srcX1, c->srcY1, c->dstX0, c->dstY0, c->dstX1, c->dstY1, c->mask, c->filter ));
}

#endif

struct qemu_glBlitNamedFramebuffer
{
    struct qemu_syscall super;
    uint64_t readFramebuffer;
    uint64_t drawFramebuffer;
    uint64_t srcX0;
    uint64_t srcY0;
    uint64_t srcX1;
    uint64_t srcY1;
    uint64_t dstX0;
    uint64_t dstY0;
    uint64_t dstX1;
    uint64_t dstY1;
    uint64_t mask;
    uint64_t filter;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBlitNamedFramebuffer( GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter )
{
    struct qemu_glBlitNamedFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBLITNAMEDFRAMEBUFFER);
    call.readFramebuffer = readFramebuffer;
    call.drawFramebuffer = drawFramebuffer;
    call.srcX0 = srcX0;
    call.srcY0 = srcY0;
    call.srcX1 = srcX1;
    call.srcY1 = srcY1;
    call.dstX0 = dstX0;
    call.dstY0 = dstY0;
    call.dstX1 = dstX1;
    call.dstY1 = dstY1;
    call.mask = mask;
    call.filter = filter;

    qemu_syscall(&call.super);
}

#else

void qemu_glBlitNamedFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glBlitNamedFramebuffer *c = (struct qemu_glBlitNamedFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glBlitNamedFramebuffer( c->readFramebuffer, c->drawFramebuffer, c->srcX0, c->srcY0, c->srcX1, c->srcY1, c->dstX0, c->dstY0, c->dstX1, c->dstY1, c->mask, c->filter ));
}

#endif

struct qemu_glBufferAddressRangeNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t address;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferAddressRangeNV( GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length )
{
    struct qemu_glBufferAddressRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERADDRESSRANGENV);
    call.pname = pname;
    call.index = index;
    call.address = address;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferAddressRangeNV(struct qemu_syscall *call)
{
    struct qemu_glBufferAddressRangeNV *c = (struct qemu_glBufferAddressRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferAddressRangeNV( c->pname, c->index, c->address, c->length ));
}

#endif

struct qemu_glBufferAttachMemoryNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferAttachMemoryNV( GLenum target, GLuint memory, GLuint64 offset )
{
    struct qemu_glBufferAttachMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERATTACHMEMORYNV);
    call.target = target;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferAttachMemoryNV(struct qemu_syscall *call)
{
    struct qemu_glBufferAttachMemoryNV *c = (struct qemu_glBufferAttachMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferAttachMemoryNV( c->target, c->memory, c->offset ));
}

#endif

struct qemu_glBufferData
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t size;
    uint64_t data;
    uint64_t usage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferData( GLenum target, GLsizeiptr size, const void *data, GLenum usage )
{
    struct qemu_glBufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERDATA);
    call.target = target;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.usage = usage;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferData(struct qemu_syscall *call)
{
    struct qemu_glBufferData *c = (struct qemu_glBufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferData( c->target, c->size, QEMU_G2H(c->data), c->usage ));
}

#endif

struct qemu_glBufferDataARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t size;
    uint64_t data;
    uint64_t usage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferDataARB( GLenum target, GLsizeiptrARB size, const void *data, GLenum usage )
{
    struct qemu_glBufferDataARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERDATAARB);
    call.target = target;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.usage = usage;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferDataARB(struct qemu_syscall *call)
{
    struct qemu_glBufferDataARB *c = (struct qemu_glBufferDataARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferDataARB( c->target, c->size, QEMU_G2H(c->data), c->usage ));
}

#endif

struct qemu_glBufferPageCommitmentARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t commit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferPageCommitmentARB( GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit )
{
    struct qemu_glBufferPageCommitmentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERPAGECOMMITMENTARB);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.commit = commit;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferPageCommitmentARB(struct qemu_syscall *call)
{
    struct qemu_glBufferPageCommitmentARB *c = (struct qemu_glBufferPageCommitmentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferPageCommitmentARB( c->target, c->offset, c->size, c->commit ));
}

#endif

struct qemu_glBufferParameteriAPPLE
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferParameteriAPPLE( GLenum target, GLenum pname, GLint param )
{
    struct qemu_glBufferParameteriAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERPARAMETERIAPPLE);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferParameteriAPPLE(struct qemu_syscall *call)
{
    struct qemu_glBufferParameteriAPPLE *c = (struct qemu_glBufferParameteriAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferParameteriAPPLE( c->target, c->pname, c->param ));
}

#endif

struct qemu_glBufferRegionEnabled
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glBufferRegionEnabled(void)
{
    struct qemu_glBufferRegionEnabled call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERREGIONENABLED);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glBufferRegionEnabled(struct qemu_syscall *call)
{
    struct qemu_glBufferRegionEnabled *c = (struct qemu_glBufferRegionEnabled *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glBufferRegionEnabled());
}

#endif

struct qemu_glBufferStorage
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t size;
    uint64_t data;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferStorage( GLenum target, GLsizeiptr size, const void *data, GLbitfield flags )
{
    struct qemu_glBufferStorage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERSTORAGE);
    call.target = target;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferStorage(struct qemu_syscall *call)
{
    struct qemu_glBufferStorage *c = (struct qemu_glBufferStorage *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferStorage( c->target, c->size, QEMU_G2H(c->data), c->flags ));
}

#endif

struct qemu_glBufferStorageExternalEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t clientBuffer;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferStorageExternalEXT( GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags )
{
    struct qemu_glBufferStorageExternalEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERSTORAGEEXTERNALEXT);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.clientBuffer = (ULONG_PTR)clientBuffer;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferStorageExternalEXT(struct qemu_syscall *call)
{
    struct qemu_glBufferStorageExternalEXT *c = (struct qemu_glBufferStorageExternalEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferStorageExternalEXT( c->target, c->offset, c->size, QEMU_G2H(c->clientBuffer), c->flags ));
}

#endif

struct qemu_glBufferStorageMemEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t size;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferStorageMemEXT( GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset )
{
    struct qemu_glBufferStorageMemEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERSTORAGEMEMEXT);
    call.target = target;
    call.size = size;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferStorageMemEXT(struct qemu_syscall *call)
{
    struct qemu_glBufferStorageMemEXT *c = (struct qemu_glBufferStorageMemEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferStorageMemEXT( c->target, c->size, c->memory, c->offset ));
}

#endif

struct qemu_glBufferSubData
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferSubData( GLenum target, GLintptr offset, GLsizeiptr size, const void *data )
{
    struct qemu_glBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERSUBDATA);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glBufferSubData *c = (struct qemu_glBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferSubData( c->target, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glBufferSubDataARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glBufferSubDataARB( GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data )
{
    struct qemu_glBufferSubDataARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLBUFFERSUBDATAARB);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glBufferSubDataARB(struct qemu_syscall *call)
{
    struct qemu_glBufferSubDataARB *c = (struct qemu_glBufferSubDataARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glBufferSubDataARB( c->target, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCallCommandListNV
{
    struct qemu_syscall super;
    uint64_t list;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCallCommandListNV( GLuint list )
{
    struct qemu_glCallCommandListNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCALLCOMMANDLISTNV);
    call.list = list;

    qemu_syscall(&call.super);
}

#else

void qemu_glCallCommandListNV(struct qemu_syscall *call)
{
    struct qemu_glCallCommandListNV *c = (struct qemu_glCallCommandListNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCallCommandListNV( c->list ));
}

#endif

struct qemu_glCheckFramebufferStatus
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glCheckFramebufferStatus( GLenum target )
{
    struct qemu_glCheckFramebufferStatus call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCHECKFRAMEBUFFERSTATUS);
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCheckFramebufferStatus(struct qemu_syscall *call)
{
    struct qemu_glCheckFramebufferStatus *c = (struct qemu_glCheckFramebufferStatus *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCheckFramebufferStatus( c->target ));
}

#endif

struct qemu_glCheckFramebufferStatusEXT
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glCheckFramebufferStatusEXT( GLenum target )
{
    struct qemu_glCheckFramebufferStatusEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCHECKFRAMEBUFFERSTATUSEXT);
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCheckFramebufferStatusEXT(struct qemu_syscall *call)
{
    struct qemu_glCheckFramebufferStatusEXT *c = (struct qemu_glCheckFramebufferStatusEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCheckFramebufferStatusEXT( c->target ));
}

#endif

struct qemu_glCheckNamedFramebufferStatus
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glCheckNamedFramebufferStatus( GLuint framebuffer, GLenum target )
{
    struct qemu_glCheckNamedFramebufferStatus call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCHECKNAMEDFRAMEBUFFERSTATUS);
    call.framebuffer = framebuffer;
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCheckNamedFramebufferStatus(struct qemu_syscall *call)
{
    struct qemu_glCheckNamedFramebufferStatus *c = (struct qemu_glCheckNamedFramebufferStatus *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCheckNamedFramebufferStatus( c->framebuffer, c->target ));
}

#endif

struct qemu_glCheckNamedFramebufferStatusEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glCheckNamedFramebufferStatusEXT( GLuint framebuffer, GLenum target )
{
    struct qemu_glCheckNamedFramebufferStatusEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT);
    call.framebuffer = framebuffer;
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCheckNamedFramebufferStatusEXT(struct qemu_syscall *call)
{
    struct qemu_glCheckNamedFramebufferStatusEXT *c = (struct qemu_glCheckNamedFramebufferStatusEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCheckNamedFramebufferStatusEXT( c->framebuffer, c->target ));
}

#endif

struct qemu_glClampColor
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t clamp;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClampColor( GLenum target, GLenum clamp )
{
    struct qemu_glClampColor call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLAMPCOLOR);
    call.target = target;
    call.clamp = clamp;

    qemu_syscall(&call.super);
}

#else

void qemu_glClampColor(struct qemu_syscall *call)
{
    struct qemu_glClampColor *c = (struct qemu_glClampColor *)call;
    WINE_FIXME("Unverified\n");
    (p_glClampColor( c->target, c->clamp ));
}

#endif

struct qemu_glClampColorARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t clamp;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClampColorARB( GLenum target, GLenum clamp )
{
    struct qemu_glClampColorARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLAMPCOLORARB);
    call.target = target;
    call.clamp = clamp;

    qemu_syscall(&call.super);
}

#else

void qemu_glClampColorARB(struct qemu_syscall *call)
{
    struct qemu_glClampColorARB *c = (struct qemu_glClampColorARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glClampColorARB( c->target, c->clamp ));
}

#endif

struct qemu_glClearAccumxOES
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearAccumxOES( GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha )
{
    struct qemu_glClearAccumxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARACCUMXOES);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearAccumxOES(struct qemu_syscall *call)
{
    struct qemu_glClearAccumxOES *c = (struct qemu_glClearAccumxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearAccumxOES( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glClearBufferData
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferData( GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearBufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERDATA);
    call.target = target;
    call.internalformat = internalformat;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferData(struct qemu_syscall *call)
{
    struct qemu_glClearBufferData *c = (struct qemu_glClearBufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferData( c->target, c->internalformat, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearBufferSubData
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t offset;
    uint64_t size;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferSubData( GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERSUBDATA);
    call.target = target;
    call.internalformat = internalformat;
    call.offset = offset;
    call.size = size;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glClearBufferSubData *c = (struct qemu_glClearBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferSubData( c->target, c->internalformat, c->offset, c->size, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearBufferfi
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t drawbuffer;
    double depth;
    uint64_t stencil;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferfi( GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil )
{
    struct qemu_glClearBufferfi call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERFI);
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.depth = depth;
    call.stencil = stencil;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferfi(struct qemu_syscall *call)
{
    struct qemu_glClearBufferfi *c = (struct qemu_glClearBufferfi *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferfi( c->buffer, c->drawbuffer, c->depth, c->stencil ));
}

#endif

struct qemu_glClearBufferfv
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferfv( GLenum buffer, GLint drawbuffer, const GLfloat *value )
{
    struct qemu_glClearBufferfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERFV);
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferfv(struct qemu_syscall *call)
{
    struct qemu_glClearBufferfv *c = (struct qemu_glClearBufferfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferfv( c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearBufferiv
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferiv( GLenum buffer, GLint drawbuffer, const GLint *value )
{
    struct qemu_glClearBufferiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERIV);
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferiv(struct qemu_syscall *call)
{
    struct qemu_glClearBufferiv *c = (struct qemu_glClearBufferiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferiv( c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearBufferuiv
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearBufferuiv( GLenum buffer, GLint drawbuffer, const GLuint *value )
{
    struct qemu_glClearBufferuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARBUFFERUIV);
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearBufferuiv(struct qemu_syscall *call)
{
    struct qemu_glClearBufferuiv *c = (struct qemu_glClearBufferuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearBufferuiv( c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearColorIiEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearColorIiEXT( GLint red, GLint green, GLint blue, GLint alpha )
{
    struct qemu_glClearColorIiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARCOLORIIEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearColorIiEXT(struct qemu_syscall *call)
{
    struct qemu_glClearColorIiEXT *c = (struct qemu_glClearColorIiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearColorIiEXT( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glClearColorIuiEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearColorIuiEXT( GLuint red, GLuint green, GLuint blue, GLuint alpha )
{
    struct qemu_glClearColorIuiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARCOLORIUIEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearColorIuiEXT(struct qemu_syscall *call)
{
    struct qemu_glClearColorIuiEXT *c = (struct qemu_glClearColorIuiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearColorIuiEXT( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glClearColorxOES
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearColorxOES( GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha )
{
    struct qemu_glClearColorxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARCOLORXOES);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearColorxOES(struct qemu_syscall *call)
{
    struct qemu_glClearColorxOES *c = (struct qemu_glClearColorxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearColorxOES( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glClearDepthdNV
{
    struct qemu_syscall super;
    double depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearDepthdNV( GLdouble depth )
{
    struct qemu_glClearDepthdNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARDEPTHDNV);
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearDepthdNV(struct qemu_syscall *call)
{
    struct qemu_glClearDepthdNV *c = (struct qemu_glClearDepthdNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearDepthdNV( c->depth ));
}

#endif

struct qemu_glClearDepthf
{
    struct qemu_syscall super;
    double d;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearDepthf( GLfloat d )
{
    struct qemu_glClearDepthf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARDEPTHF);
    call.d = d;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearDepthf(struct qemu_syscall *call)
{
    struct qemu_glClearDepthf *c = (struct qemu_glClearDepthf *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearDepthf( c->d ));
}

#endif

struct qemu_glClearDepthfOES
{
    struct qemu_syscall super;
    double depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearDepthfOES( GLclampf depth )
{
    struct qemu_glClearDepthfOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARDEPTHFOES);
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearDepthfOES(struct qemu_syscall *call)
{
    struct qemu_glClearDepthfOES *c = (struct qemu_glClearDepthfOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearDepthfOES( c->depth ));
}

#endif

struct qemu_glClearDepthxOES
{
    struct qemu_syscall super;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearDepthxOES( GLfixed depth )
{
    struct qemu_glClearDepthxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARDEPTHXOES);
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearDepthxOES(struct qemu_syscall *call)
{
    struct qemu_glClearDepthxOES *c = (struct qemu_glClearDepthxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearDepthxOES( c->depth ));
}

#endif

struct qemu_glClearNamedBufferData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t internalformat;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedBufferData( GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearNamedBufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDBUFFERDATA);
    call.buffer = buffer;
    call.internalformat = internalformat;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedBufferData(struct qemu_syscall *call)
{
    struct qemu_glClearNamedBufferData *c = (struct qemu_glClearNamedBufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedBufferData( c->buffer, c->internalformat, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearNamedBufferDataEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t internalformat;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedBufferDataEXT( GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearNamedBufferDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDBUFFERDATAEXT);
    call.buffer = buffer;
    call.internalformat = internalformat;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedBufferDataEXT(struct qemu_syscall *call)
{
    struct qemu_glClearNamedBufferDataEXT *c = (struct qemu_glClearNamedBufferDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedBufferDataEXT( c->buffer, c->internalformat, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearNamedBufferSubData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t internalformat;
    uint64_t offset;
    uint64_t size;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedBufferSubData( GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearNamedBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDBUFFERSUBDATA);
    call.buffer = buffer;
    call.internalformat = internalformat;
    call.offset = offset;
    call.size = size;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glClearNamedBufferSubData *c = (struct qemu_glClearNamedBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedBufferSubData( c->buffer, c->internalformat, c->offset, c->size, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearNamedBufferSubDataEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t internalformat;
    uint64_t offset;
    uint64_t size;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedBufferSubDataEXT( GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearNamedBufferSubDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDBUFFERSUBDATAEXT);
    call.buffer = buffer;
    call.internalformat = internalformat;
    call.offset = offset;
    call.size = size;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedBufferSubDataEXT(struct qemu_syscall *call)
{
    struct qemu_glClearNamedBufferSubDataEXT *c = (struct qemu_glClearNamedBufferSubDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedBufferSubDataEXT( c->buffer, c->internalformat, c->offset, c->size, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearNamedFramebufferfi
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t buffer;
    uint64_t drawbuffer;
    double depth;
    uint64_t stencil;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedFramebufferfi( GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil )
{
    struct qemu_glClearNamedFramebufferfi call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDFRAMEBUFFERFI);
    call.framebuffer = framebuffer;
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.depth = depth;
    call.stencil = stencil;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedFramebufferfi(struct qemu_syscall *call)
{
    struct qemu_glClearNamedFramebufferfi *c = (struct qemu_glClearNamedFramebufferfi *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedFramebufferfi( c->framebuffer, c->buffer, c->drawbuffer, c->depth, c->stencil ));
}

#endif

struct qemu_glClearNamedFramebufferfv
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedFramebufferfv( GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value )
{
    struct qemu_glClearNamedFramebufferfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDFRAMEBUFFERFV);
    call.framebuffer = framebuffer;
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedFramebufferfv(struct qemu_syscall *call)
{
    struct qemu_glClearNamedFramebufferfv *c = (struct qemu_glClearNamedFramebufferfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedFramebufferfv( c->framebuffer, c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearNamedFramebufferiv
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedFramebufferiv( GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value )
{
    struct qemu_glClearNamedFramebufferiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDFRAMEBUFFERIV);
    call.framebuffer = framebuffer;
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedFramebufferiv(struct qemu_syscall *call)
{
    struct qemu_glClearNamedFramebufferiv *c = (struct qemu_glClearNamedFramebufferiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedFramebufferiv( c->framebuffer, c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearNamedFramebufferuiv
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t buffer;
    uint64_t drawbuffer;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearNamedFramebufferuiv( GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value )
{
    struct qemu_glClearNamedFramebufferuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARNAMEDFRAMEBUFFERUIV);
    call.framebuffer = framebuffer;
    call.buffer = buffer;
    call.drawbuffer = drawbuffer;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearNamedFramebufferuiv(struct qemu_syscall *call)
{
    struct qemu_glClearNamedFramebufferuiv *c = (struct qemu_glClearNamedFramebufferuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearNamedFramebufferuiv( c->framebuffer, c->buffer, c->drawbuffer, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glClearTexImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearTexImage( GLuint texture, GLint level, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearTexImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARTEXIMAGE);
    call.texture = texture;
    call.level = level;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearTexImage(struct qemu_syscall *call)
{
    struct qemu_glClearTexImage *c = (struct qemu_glClearTexImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearTexImage( c->texture, c->level, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClearTexSubImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClearTexSubImage( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data )
{
    struct qemu_glClearTexSubImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLEARTEXSUBIMAGE);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glClearTexSubImage(struct qemu_syscall *call)
{
    struct qemu_glClearTexSubImage *c = (struct qemu_glClearTexSubImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glClearTexSubImage( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glClientActiveTexture
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClientActiveTexture( GLenum texture )
{
    struct qemu_glClientActiveTexture call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTACTIVETEXTURE);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glClientActiveTexture(struct qemu_syscall *call)
{
    struct qemu_glClientActiveTexture *c = (struct qemu_glClientActiveTexture *)call;
    WINE_FIXME("Unverified\n");
    (p_glClientActiveTexture( c->texture ));
}

#endif

struct qemu_glClientActiveTextureARB
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClientActiveTextureARB( GLenum texture )
{
    struct qemu_glClientActiveTextureARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTACTIVETEXTUREARB);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glClientActiveTextureARB(struct qemu_syscall *call)
{
    struct qemu_glClientActiveTextureARB *c = (struct qemu_glClientActiveTextureARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glClientActiveTextureARB( c->texture ));
}

#endif

struct qemu_glClientActiveVertexStreamATI
{
    struct qemu_syscall super;
    uint64_t stream;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClientActiveVertexStreamATI( GLenum stream )
{
    struct qemu_glClientActiveVertexStreamATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTACTIVEVERTEXSTREAMATI);
    call.stream = stream;

    qemu_syscall(&call.super);
}

#else

void qemu_glClientActiveVertexStreamATI(struct qemu_syscall *call)
{
    struct qemu_glClientActiveVertexStreamATI *c = (struct qemu_glClientActiveVertexStreamATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glClientActiveVertexStreamATI( c->stream ));
}

#endif

struct qemu_glClientAttribDefaultEXT
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClientAttribDefaultEXT( GLbitfield mask )
{
    struct qemu_glClientAttribDefaultEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTATTRIBDEFAULTEXT);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glClientAttribDefaultEXT(struct qemu_syscall *call)
{
    struct qemu_glClientAttribDefaultEXT *c = (struct qemu_glClientAttribDefaultEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glClientAttribDefaultEXT( c->mask ));
}

#endif

struct qemu_glClientWaitSemaphoreui64NVX
{
    struct qemu_syscall super;
    uint64_t fenceObjectCount;
    uint64_t semaphoreArray;
    uint64_t fenceValueArray;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClientWaitSemaphoreui64NVX( GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray )
{
    struct qemu_glClientWaitSemaphoreui64NVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTWAITSEMAPHOREUI64NVX);
    call.fenceObjectCount = fenceObjectCount;
    call.semaphoreArray = (ULONG_PTR)semaphoreArray;
    call.fenceValueArray = (ULONG_PTR)fenceValueArray;

    qemu_syscall(&call.super);
}

#else

void qemu_glClientWaitSemaphoreui64NVX(struct qemu_syscall *call)
{
    struct qemu_glClientWaitSemaphoreui64NVX *c = (struct qemu_glClientWaitSemaphoreui64NVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glClientWaitSemaphoreui64NVX( c->fenceObjectCount, QEMU_G2H(c->semaphoreArray), QEMU_G2H(c->fenceValueArray) ));
}

#endif

struct qemu_glClientWaitSync
{
    struct qemu_syscall super;
    uint64_t sync;
    uint64_t flags;
    uint64_t timeout;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glClientWaitSync( GLsync sync, GLbitfield flags, GLuint64 timeout )
{
    struct qemu_glClientWaitSync call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIENTWAITSYNC);
    call.sync = (ULONG_PTR)sync;
    call.flags = flags;
    call.timeout = timeout;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glClientWaitSync(struct qemu_syscall *call)
{
    struct qemu_glClientWaitSync *c = (struct qemu_glClientWaitSync *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glClientWaitSync( QEMU_G2H(c->sync), c->flags, c->timeout ));
}

#endif

struct qemu_glClipControl
{
    struct qemu_syscall super;
    uint64_t origin;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClipControl( GLenum origin, GLenum depth )
{
    struct qemu_glClipControl call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIPCONTROL);
    call.origin = origin;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glClipControl(struct qemu_syscall *call)
{
    struct qemu_glClipControl *c = (struct qemu_glClipControl *)call;
    WINE_FIXME("Unverified\n");
    (p_glClipControl( c->origin, c->depth ));
}

#endif

struct qemu_glClipPlanefOES
{
    struct qemu_syscall super;
    uint64_t plane;
    uint64_t equation;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClipPlanefOES( GLenum plane, const GLfloat *equation )
{
    struct qemu_glClipPlanefOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIPPLANEFOES);
    call.plane = plane;
    call.equation = (ULONG_PTR)equation;

    qemu_syscall(&call.super);
}

#else

void qemu_glClipPlanefOES(struct qemu_syscall *call)
{
    struct qemu_glClipPlanefOES *c = (struct qemu_glClipPlanefOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClipPlanefOES( c->plane, QEMU_G2H(c->equation) ));
}

#endif

struct qemu_glClipPlanexOES
{
    struct qemu_syscall super;
    uint64_t plane;
    uint64_t equation;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glClipPlanexOES( GLenum plane, const GLfixed *equation )
{
    struct qemu_glClipPlanexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCLIPPLANEXOES);
    call.plane = plane;
    call.equation = (ULONG_PTR)equation;

    qemu_syscall(&call.super);
}

#else

void qemu_glClipPlanexOES(struct qemu_syscall *call)
{
    struct qemu_glClipPlanexOES *c = (struct qemu_glClipPlanexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glClipPlanexOES( c->plane, QEMU_G2H(c->equation) ));
}

#endif

struct qemu_glColor3fVertex3fSUN
{
    struct qemu_syscall super;
    double r;
    double g;
    double b;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3fVertex3fSUN( GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glColor3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3FVERTEX3FSUN);
    call.r = r;
    call.g = g;
    call.b = b;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glColor3fVertex3fSUN *c = (struct qemu_glColor3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3fVertex3fSUN( c->r, c->g, c->b, c->x, c->y, c->z ));
}

#endif

struct qemu_glColor3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3fVertex3fvSUN( const GLfloat *c, const GLfloat *v )
{
    struct qemu_glColor3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3FVERTEX3FVSUN);
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glColor3fVertex3fvSUN *c = (struct qemu_glColor3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3fVertex3fvSUN( QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor3hNV
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3hNV( GLhalfNV red, GLhalfNV green, GLhalfNV blue )
{
    struct qemu_glColor3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3HNV);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3hNV(struct qemu_syscall *call)
{
    struct qemu_glColor3hNV *c = (struct qemu_glColor3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3hNV( c->red, c->green, c->blue ));
}

#endif

struct qemu_glColor3hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3hvNV( const GLhalfNV *v )
{
    struct qemu_glColor3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3hvNV(struct qemu_syscall *call)
{
    struct qemu_glColor3hvNV *c = (struct qemu_glColor3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor3xOES
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3xOES( GLfixed red, GLfixed green, GLfixed blue )
{
    struct qemu_glColor3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3XOES);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3xOES(struct qemu_syscall *call)
{
    struct qemu_glColor3xOES *c = (struct qemu_glColor3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3xOES( c->red, c->green, c->blue ));
}

#endif

struct qemu_glColor3xvOES
{
    struct qemu_syscall super;
    uint64_t components;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor3xvOES( const GLfixed *components )
{
    struct qemu_glColor3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR3XVOES);
    call.components = (ULONG_PTR)components;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor3xvOES(struct qemu_syscall *call)
{
    struct qemu_glColor3xvOES *c = (struct qemu_glColor3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor3xvOES( QEMU_G2H(c->components) ));
}

#endif

struct qemu_glColor4fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    double r;
    double g;
    double b;
    double a;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4fNormal3fVertex3fSUN( GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glColor4fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4FNORMAL3FVERTEX3FSUN);
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4fNormal3fVertex3fSUN *c = (struct qemu_glColor4fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4fNormal3fVertex3fSUN( c->r, c->g, c->b, c->a, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glColor4fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t c;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4fNormal3fVertex3fvSUN( const GLfloat *c, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glColor4fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4FNORMAL3FVERTEX3FVSUN);
    call.c = (ULONG_PTR)c;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4fNormal3fVertex3fvSUN *c = (struct qemu_glColor4fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4fNormal3fVertex3fvSUN( QEMU_G2H(c->c), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor4hNV
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4hNV( GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha )
{
    struct qemu_glColor4hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4HNV);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4hNV(struct qemu_syscall *call)
{
    struct qemu_glColor4hNV *c = (struct qemu_glColor4hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4hNV( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glColor4hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4hvNV( const GLhalfNV *v )
{
    struct qemu_glColor4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4hvNV(struct qemu_syscall *call)
{
    struct qemu_glColor4hvNV *c = (struct qemu_glColor4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor4ubVertex2fSUN
{
    struct qemu_syscall super;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4ubVertex2fSUN( GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y )
{
    struct qemu_glColor4ubVertex2fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4UBVERTEX2FSUN);
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4ubVertex2fSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4ubVertex2fSUN *c = (struct qemu_glColor4ubVertex2fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4ubVertex2fSUN( c->r, c->g, c->b, c->a, c->x, c->y ));
}

#endif

struct qemu_glColor4ubVertex2fvSUN
{
    struct qemu_syscall super;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4ubVertex2fvSUN( const GLubyte *c, const GLfloat *v )
{
    struct qemu_glColor4ubVertex2fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4UBVERTEX2FVSUN);
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4ubVertex2fvSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4ubVertex2fvSUN *c = (struct qemu_glColor4ubVertex2fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4ubVertex2fvSUN( QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor4ubVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4ubVertex3fSUN( GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glColor4ubVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4UBVERTEX3FSUN);
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4ubVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4ubVertex3fSUN *c = (struct qemu_glColor4ubVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4ubVertex3fSUN( c->r, c->g, c->b, c->a, c->x, c->y, c->z ));
}

#endif

struct qemu_glColor4ubVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4ubVertex3fvSUN( const GLubyte *c, const GLfloat *v )
{
    struct qemu_glColor4ubVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4UBVERTEX3FVSUN);
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4ubVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glColor4ubVertex3fvSUN *c = (struct qemu_glColor4ubVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4ubVertex3fvSUN( QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glColor4xOES
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4xOES( GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha )
{
    struct qemu_glColor4xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4XOES);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4xOES(struct qemu_syscall *call)
{
    struct qemu_glColor4xOES *c = (struct qemu_glColor4xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4xOES( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glColor4xvOES
{
    struct qemu_syscall super;
    uint64_t components;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColor4xvOES( const GLfixed *components )
{
    struct qemu_glColor4xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLOR4XVOES);
    call.components = (ULONG_PTR)components;

    qemu_syscall(&call.super);
}

#else

void qemu_glColor4xvOES(struct qemu_syscall *call)
{
    struct qemu_glColor4xvOES *c = (struct qemu_glColor4xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glColor4xvOES( QEMU_G2H(c->components) ));
}

#endif

struct qemu_glColorFormatNV
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorFormatNV( GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glColorFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORFORMATNV);
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorFormatNV(struct qemu_syscall *call)
{
    struct qemu_glColorFormatNV *c = (struct qemu_glColorFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorFormatNV( c->size, c->type, c->stride ));
}

#endif

struct qemu_glColorFragmentOp1ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMask;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorFragmentOp1ATI( GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod )
{
    struct qemu_glColorFragmentOp1ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORFRAGMENTOP1ATI);
    call.op = op;
    call.dst = dst;
    call.dstMask = dstMask;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorFragmentOp1ATI(struct qemu_syscall *call)
{
    struct qemu_glColorFragmentOp1ATI *c = (struct qemu_glColorFragmentOp1ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorFragmentOp1ATI( c->op, c->dst, c->dstMask, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod ));
}

#endif

struct qemu_glColorFragmentOp2ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMask;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
    uint64_t arg2;
    uint64_t arg2Rep;
    uint64_t arg2Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorFragmentOp2ATI( GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod )
{
    struct qemu_glColorFragmentOp2ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORFRAGMENTOP2ATI);
    call.op = op;
    call.dst = dst;
    call.dstMask = dstMask;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;
    call.arg2 = arg2;
    call.arg2Rep = arg2Rep;
    call.arg2Mod = arg2Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorFragmentOp2ATI(struct qemu_syscall *call)
{
    struct qemu_glColorFragmentOp2ATI *c = (struct qemu_glColorFragmentOp2ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorFragmentOp2ATI( c->op, c->dst, c->dstMask, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod, c->arg2, c->arg2Rep, c->arg2Mod ));
}

#endif

struct qemu_glColorFragmentOp3ATI
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t dst;
    uint64_t dstMask;
    uint64_t dstMod;
    uint64_t arg1;
    uint64_t arg1Rep;
    uint64_t arg1Mod;
    uint64_t arg2;
    uint64_t arg2Rep;
    uint64_t arg2Mod;
    uint64_t arg3;
    uint64_t arg3Rep;
    uint64_t arg3Mod;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorFragmentOp3ATI( GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod )
{
    struct qemu_glColorFragmentOp3ATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORFRAGMENTOP3ATI);
    call.op = op;
    call.dst = dst;
    call.dstMask = dstMask;
    call.dstMod = dstMod;
    call.arg1 = arg1;
    call.arg1Rep = arg1Rep;
    call.arg1Mod = arg1Mod;
    call.arg2 = arg2;
    call.arg2Rep = arg2Rep;
    call.arg2Mod = arg2Mod;
    call.arg3 = arg3;
    call.arg3Rep = arg3Rep;
    call.arg3Mod = arg3Mod;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorFragmentOp3ATI(struct qemu_syscall *call)
{
    struct qemu_glColorFragmentOp3ATI *c = (struct qemu_glColorFragmentOp3ATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorFragmentOp3ATI( c->op, c->dst, c->dstMask, c->dstMod, c->arg1, c->arg1Rep, c->arg1Mod, c->arg2, c->arg2Rep, c->arg2Mod, c->arg3, c->arg3Rep, c->arg3Mod ));
}

#endif

struct qemu_glColorMaskIndexedEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorMaskIndexedEXT( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a )
{
    struct qemu_glColorMaskIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORMASKINDEXEDEXT);
    call.index = index;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorMaskIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glColorMaskIndexedEXT *c = (struct qemu_glColorMaskIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorMaskIndexedEXT( c->index, c->r, c->g, c->b, c->a ));
}

#endif

struct qemu_glColorMaski
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorMaski( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a )
{
    struct qemu_glColorMaski call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORMASKI);
    call.index = index;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorMaski(struct qemu_syscall *call)
{
    struct qemu_glColorMaski *c = (struct qemu_glColorMaski *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorMaski( c->index, c->r, c->g, c->b, c->a ));
}

#endif

struct qemu_glColorP3ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorP3ui( GLenum type, GLuint color )
{
    struct qemu_glColorP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORP3UI);
    call.type = type;
    call.color = color;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorP3ui(struct qemu_syscall *call)
{
    struct qemu_glColorP3ui *c = (struct qemu_glColorP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorP3ui( c->type, c->color ));
}

#endif

struct qemu_glColorP3uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorP3uiv( GLenum type, const GLuint *color )
{
    struct qemu_glColorP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORP3UIV);
    call.type = type;
    call.color = (ULONG_PTR)color;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorP3uiv(struct qemu_syscall *call)
{
    struct qemu_glColorP3uiv *c = (struct qemu_glColorP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorP3uiv( c->type, QEMU_G2H(c->color) ));
}

#endif

struct qemu_glColorP4ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorP4ui( GLenum type, GLuint color )
{
    struct qemu_glColorP4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORP4UI);
    call.type = type;
    call.color = color;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorP4ui(struct qemu_syscall *call)
{
    struct qemu_glColorP4ui *c = (struct qemu_glColorP4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorP4ui( c->type, c->color ));
}

#endif

struct qemu_glColorP4uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorP4uiv( GLenum type, const GLuint *color )
{
    struct qemu_glColorP4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORP4UIV);
    call.type = type;
    call.color = (ULONG_PTR)color;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorP4uiv(struct qemu_syscall *call)
{
    struct qemu_glColorP4uiv *c = (struct qemu_glColorP4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorP4uiv( c->type, QEMU_G2H(c->color) ));
}

#endif

struct qemu_glColorPointerEXT
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorPointerEXT( GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer )
{
    struct qemu_glColorPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORPOINTEREXT);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glColorPointerEXT *c = (struct qemu_glColorPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorPointerEXT( c->size, c->type, c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glColorPointerListIBM
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorPointerListIBM( GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glColorPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORPOINTERLISTIBM);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glColorPointerListIBM *c = (struct qemu_glColorPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorPointerListIBM( c->size, c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glColorPointervINTEL
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorPointervINTEL( GLint size, GLenum type, const void **pointer )
{
    struct qemu_glColorPointervINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORPOINTERVINTEL);
    call.size = size;
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorPointervINTEL(struct qemu_syscall *call)
{
    struct qemu_glColorPointervINTEL *c = (struct qemu_glColorPointervINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorPointervINTEL( c->size, c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glColorSubTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t count;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorSubTable( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data )
{
    struct qemu_glColorSubTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORSUBTABLE);
    call.target = target;
    call.start = start;
    call.count = count;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorSubTable(struct qemu_syscall *call)
{
    struct qemu_glColorSubTable *c = (struct qemu_glColorSubTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorSubTable( c->target, c->start, c->count, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glColorSubTableEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t count;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data )
{
    struct qemu_glColorSubTableEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORSUBTABLEEXT);
    call.target = target;
    call.start = start;
    call.count = count;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorSubTableEXT(struct qemu_syscall *call)
{
    struct qemu_glColorSubTableEXT *c = (struct qemu_glColorSubTableEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorSubTableEXT( c->target, c->start, c->count, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glColorTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTable( GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table )
{
    struct qemu_glColorTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLE);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.format = format;
    call.type = type;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTable(struct qemu_syscall *call)
{
    struct qemu_glColorTable *c = (struct qemu_glColorTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTable( c->target, c->internalformat, c->width, c->format, c->type, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glColorTableEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table )
{
    struct qemu_glColorTableEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLEEXT);
    call.target = target;
    call.internalFormat = internalFormat;
    call.width = width;
    call.format = format;
    call.type = type;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableEXT(struct qemu_syscall *call)
{
    struct qemu_glColorTableEXT *c = (struct qemu_glColorTableEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableEXT( c->target, c->internalFormat, c->width, c->format, c->type, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glColorTableParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableParameterfv( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glColorTableParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLEPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableParameterfv(struct qemu_syscall *call)
{
    struct qemu_glColorTableParameterfv *c = (struct qemu_glColorTableParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glColorTableParameterfvSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableParameterfvSGI( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glColorTableParameterfvSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLEPARAMETERFVSGI);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableParameterfvSGI(struct qemu_syscall *call)
{
    struct qemu_glColorTableParameterfvSGI *c = (struct qemu_glColorTableParameterfvSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableParameterfvSGI( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glColorTableParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableParameteriv( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glColorTableParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLEPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableParameteriv(struct qemu_syscall *call)
{
    struct qemu_glColorTableParameteriv *c = (struct qemu_glColorTableParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glColorTableParameterivSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableParameterivSGI( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glColorTableParameterivSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLEPARAMETERIVSGI);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableParameterivSGI(struct qemu_syscall *call)
{
    struct qemu_glColorTableParameterivSGI *c = (struct qemu_glColorTableParameterivSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableParameterivSGI( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glColorTableSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glColorTableSGI( GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table )
{
    struct qemu_glColorTableSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOLORTABLESGI);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.format = format;
    call.type = type;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glColorTableSGI(struct qemu_syscall *call)
{
    struct qemu_glColorTableSGI *c = (struct qemu_glColorTableSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glColorTableSGI( c->target, c->internalformat, c->width, c->format, c->type, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glCombinerInputNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t variable;
    uint64_t input;
    uint64_t mapping;
    uint64_t componentUsage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerInputNV( GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
    struct qemu_glCombinerInputNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERINPUTNV);
    call.stage = stage;
    call.portion = portion;
    call.variable = variable;
    call.input = input;
    call.mapping = mapping;
    call.componentUsage = componentUsage;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerInputNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerInputNV *c = (struct qemu_glCombinerInputNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerInputNV( c->stage, c->portion, c->variable, c->input, c->mapping, c->componentUsage ));
}

#endif

struct qemu_glCombinerOutputNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t abOutput;
    uint64_t cdOutput;
    uint64_t sumOutput;
    uint64_t scale;
    uint64_t bias;
    uint64_t abDotProduct;
    uint64_t cdDotProduct;
    uint64_t muxSum;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerOutputNV( GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum )
{
    struct qemu_glCombinerOutputNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINEROUTPUTNV);
    call.stage = stage;
    call.portion = portion;
    call.abOutput = abOutput;
    call.cdOutput = cdOutput;
    call.sumOutput = sumOutput;
    call.scale = scale;
    call.bias = bias;
    call.abDotProduct = abDotProduct;
    call.cdDotProduct = cdDotProduct;
    call.muxSum = muxSum;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerOutputNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerOutputNV *c = (struct qemu_glCombinerOutputNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerOutputNV( c->stage, c->portion, c->abOutput, c->cdOutput, c->sumOutput, c->scale, c->bias, c->abDotProduct, c->cdDotProduct, c->muxSum ));
}

#endif

struct qemu_glCombinerParameterfNV
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerParameterfNV( GLenum pname, GLfloat param )
{
    struct qemu_glCombinerParameterfNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERPARAMETERFNV);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerParameterfNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerParameterfNV *c = (struct qemu_glCombinerParameterfNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerParameterfNV( c->pname, c->param ));
}

#endif

struct qemu_glCombinerParameterfvNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerParameterfvNV( GLenum pname, const GLfloat *params )
{
    struct qemu_glCombinerParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERPARAMETERFVNV);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerParameterfvNV *c = (struct qemu_glCombinerParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerParameterfvNV( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCombinerParameteriNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerParameteriNV( GLenum pname, GLint param )
{
    struct qemu_glCombinerParameteriNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERPARAMETERINV);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerParameteriNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerParameteriNV *c = (struct qemu_glCombinerParameteriNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerParameteriNV( c->pname, c->param ));
}

#endif

struct qemu_glCombinerParameterivNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerParameterivNV( GLenum pname, const GLint *params )
{
    struct qemu_glCombinerParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERPARAMETERIVNV);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerParameterivNV *c = (struct qemu_glCombinerParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerParameterivNV( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCombinerStageParameterfvNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCombinerStageParameterfvNV( GLenum stage, GLenum pname, const GLfloat *params )
{
    struct qemu_glCombinerStageParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMBINERSTAGEPARAMETERFVNV);
    call.stage = stage;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glCombinerStageParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glCombinerStageParameterfvNV *c = (struct qemu_glCombinerStageParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCombinerStageParameterfvNV( c->stage, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCommandListSegmentsNV
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t segments;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCommandListSegmentsNV( GLuint list, GLuint segments )
{
    struct qemu_glCommandListSegmentsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMMANDLISTSEGMENTSNV);
    call.list = list;
    call.segments = segments;

    qemu_syscall(&call.super);
}

#else

void qemu_glCommandListSegmentsNV(struct qemu_syscall *call)
{
    struct qemu_glCommandListSegmentsNV *c = (struct qemu_glCommandListSegmentsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCommandListSegmentsNV( c->list, c->segments ));
}

#endif

struct qemu_glCompileCommandListNV
{
    struct qemu_syscall super;
    uint64_t list;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompileCommandListNV( GLuint list )
{
    struct qemu_glCompileCommandListNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPILECOMMANDLISTNV);
    call.list = list;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompileCommandListNV(struct qemu_syscall *call)
{
    struct qemu_glCompileCommandListNV *c = (struct qemu_glCompileCommandListNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompileCommandListNV( c->list ));
}

#endif

struct qemu_glCompileShader
{
    struct qemu_syscall super;
    uint64_t shader;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompileShader( GLuint shader )
{
    struct qemu_glCompileShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPILESHADER);
    call.shader = shader;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompileShader(struct qemu_syscall *call)
{
    struct qemu_glCompileShader *c = (struct qemu_glCompileShader *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompileShader( c->shader ));
}

#endif

struct qemu_glCompileShaderARB
{
    struct qemu_syscall super;
    uint64_t shaderObj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompileShaderARB( GLhandleARB shaderObj )
{
    struct qemu_glCompileShaderARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPILESHADERARB);
    call.shaderObj = shaderObj;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompileShaderARB(struct qemu_syscall *call)
{
    struct qemu_glCompileShaderARB *c = (struct qemu_glCompileShaderARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompileShaderARB( c->shaderObj ));
}

#endif

struct qemu_glCompileShaderIncludeARB
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t count;
    uint64_t path;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompileShaderIncludeARB( GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length )
{
    struct qemu_glCompileShaderIncludeARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPILESHADERINCLUDEARB);
    call.shader = shader;
    call.count = count;
    call.path = (ULONG_PTR)path;
    call.length = (ULONG_PTR)length;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompileShaderIncludeARB(struct qemu_syscall *call)
{
    struct qemu_glCompileShaderIncludeARB *c = (struct qemu_glCompileShaderIncludeARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompileShaderIncludeARB( c->shader, c->count, QEMU_G2H(c->path), QEMU_G2H(c->length) ));
}

#endif

struct qemu_glCompressedMultiTexImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexImage1DEXT( GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexImage1DEXT *c = (struct qemu_glCompressedMultiTexImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexImage1DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedMultiTexImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexImage2DEXT( GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexImage2DEXT *c = (struct qemu_glCompressedMultiTexImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexImage2DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->height, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedMultiTexImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexImage3DEXT( GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXIMAGE3DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexImage3DEXT *c = (struct qemu_glCompressedMultiTexImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexImage3DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedMultiTexSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexSubImage1DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexSubImage1DEXT *c = (struct qemu_glCompressedMultiTexSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexSubImage1DEXT( c->texunit, c->target, c->level, c->xoffset, c->width, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedMultiTexSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexSubImage2DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexSubImage2DEXT *c = (struct qemu_glCompressedMultiTexSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexSubImage2DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedMultiTexSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedMultiTexSubImage3DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedMultiTexSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedMultiTexSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedMultiTexSubImage3DEXT *c = (struct qemu_glCompressedMultiTexSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedMultiTexSubImage3DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTexImage1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE1D);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage1D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage1D *c = (struct qemu_glCompressedTexImage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage1D( c->target, c->level, c->internalformat, c->width, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexImage1DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage1DARB( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage1DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE1DARB);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage1DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage1DARB *c = (struct qemu_glCompressedTexImage1DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage1DARB( c->target, c->level, c->internalformat, c->width, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexImage2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage2D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE2D);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage2D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage2D *c = (struct qemu_glCompressedTexImage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage2D( c->target, c->level, c->internalformat, c->width, c->height, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexImage2DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage2DARB( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage2DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE2DARB);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage2DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage2DARB *c = (struct qemu_glCompressedTexImage2DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage2DARB( c->target, c->level, c->internalformat, c->width, c->height, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexImage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage3D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE3D);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage3D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage3D *c = (struct qemu_glCompressedTexImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage3D( c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexImage3DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexImage3DARB( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexImage3DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXIMAGE3DARB);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexImage3DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexImage3DARB *c = (struct qemu_glCompressedTexImage3DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexImage3DARB( c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE1D);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage1D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage1D *c = (struct qemu_glCompressedTexSubImage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage1D( c->target, c->level, c->xoffset, c->width, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage1DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage1DARB( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage1DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE1DARB);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage1DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage1DARB *c = (struct qemu_glCompressedTexSubImage1DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage1DARB( c->target, c->level, c->xoffset, c->width, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE2D);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage2D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage2D *c = (struct qemu_glCompressedTexSubImage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage2D( c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage2DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage2DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage2DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE2DARB);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage2DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage2DARB *c = (struct qemu_glCompressedTexSubImage2DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage2DARB( c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE3D);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage3D *c = (struct qemu_glCompressedTexSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage3D( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTexSubImage3DARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTexSubImage3DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTexSubImage3DARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXSUBIMAGE3DARB);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTexSubImage3DARB(struct qemu_syscall *call)
{
    struct qemu_glCompressedTexSubImage3DARB *c = (struct qemu_glCompressedTexSubImage3DARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTexSubImage3DARB( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTextureImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureImage1DEXT( GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTUREIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureImage1DEXT *c = (struct qemu_glCompressedTextureImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureImage1DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTextureImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureImage2DEXT( GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTUREIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureImage2DEXT *c = (struct qemu_glCompressedTextureImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureImage2DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->height, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTextureImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureImage3DEXT( GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTUREIMAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureImage3DEXT *c = (struct qemu_glCompressedTextureImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureImage3DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTextureSubImage1D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage1D( GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTextureSubImage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE1D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage1D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage1D *c = (struct qemu_glCompressedTextureSubImage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage1D( c->texture, c->level, c->xoffset, c->width, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTextureSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage1DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage1DEXT *c = (struct qemu_glCompressedTextureSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage1DEXT( c->texture, c->target, c->level, c->xoffset, c->width, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTextureSubImage2D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage2D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTextureSubImage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE2D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage2D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage2D *c = (struct qemu_glCompressedTextureSubImage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage2D( c->texture, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTextureSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage2DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage2DEXT *c = (struct qemu_glCompressedTextureSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage2DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glCompressedTextureSubImage3D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t imageSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage3D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data )
{
    struct qemu_glCompressedTextureSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE3D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.imageSize = imageSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage3D *c = (struct qemu_glCompressedTextureSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage3D( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->imageSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glCompressedTextureSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t imageSize;
    uint64_t bits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCompressedTextureSubImage3DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits )
{
    struct qemu_glCompressedTextureSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.imageSize = imageSize;
    call.bits = (ULONG_PTR)bits;

    qemu_syscall(&call.super);
}

#else

void qemu_glCompressedTextureSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCompressedTextureSubImage3DEXT *c = (struct qemu_glCompressedTextureSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCompressedTextureSubImage3DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->imageSize, QEMU_G2H(c->bits) ));
}

#endif

struct qemu_glConservativeRasterParameterfNV
{
    struct qemu_syscall super;
    uint64_t pname;
    double value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConservativeRasterParameterfNV( GLenum pname, GLfloat value )
{
    struct qemu_glConservativeRasterParameterfNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONSERVATIVERASTERPARAMETERFNV);
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glConservativeRasterParameterfNV(struct qemu_syscall *call)
{
    struct qemu_glConservativeRasterParameterfNV *c = (struct qemu_glConservativeRasterParameterfNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glConservativeRasterParameterfNV( c->pname, c->value ));
}

#endif

struct qemu_glConservativeRasterParameteriNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConservativeRasterParameteriNV( GLenum pname, GLint param )
{
    struct qemu_glConservativeRasterParameteriNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONSERVATIVERASTERPARAMETERINV);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glConservativeRasterParameteriNV(struct qemu_syscall *call)
{
    struct qemu_glConservativeRasterParameteriNV *c = (struct qemu_glConservativeRasterParameteriNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glConservativeRasterParameteriNV( c->pname, c->param ));
}

#endif

struct qemu_glConvolutionFilter1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionFilter1D( GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image )
{
    struct qemu_glConvolutionFilter1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONFILTER1D);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionFilter1D(struct qemu_syscall *call)
{
    struct qemu_glConvolutionFilter1D *c = (struct qemu_glConvolutionFilter1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionFilter1D( c->target, c->internalformat, c->width, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glConvolutionFilter1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionFilter1DEXT( GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image )
{
    struct qemu_glConvolutionFilter1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONFILTER1DEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionFilter1DEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionFilter1DEXT *c = (struct qemu_glConvolutionFilter1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionFilter1DEXT( c->target, c->internalformat, c->width, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glConvolutionFilter2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionFilter2D( GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image )
{
    struct qemu_glConvolutionFilter2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONFILTER2D);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionFilter2D(struct qemu_syscall *call)
{
    struct qemu_glConvolutionFilter2D *c = (struct qemu_glConvolutionFilter2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionFilter2D( c->target, c->internalformat, c->width, c->height, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glConvolutionFilter2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionFilter2DEXT( GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image )
{
    struct qemu_glConvolutionFilter2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONFILTER2DEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionFilter2DEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionFilter2DEXT *c = (struct qemu_glConvolutionFilter2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionFilter2DEXT( c->target, c->internalformat, c->width, c->height, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glConvolutionParameterf
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    double params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterf( GLenum target, GLenum pname, GLfloat params )
{
    struct qemu_glConvolutionParameterf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERF);
    call.target = target;
    call.pname = pname;
    call.params = params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterf(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterf *c = (struct qemu_glConvolutionParameterf *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterf( c->target, c->pname, c->params ));
}

#endif

struct qemu_glConvolutionParameterfEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    double params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterfEXT( GLenum target, GLenum pname, GLfloat params )
{
    struct qemu_glConvolutionParameterfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERFEXT);
    call.target = target;
    call.pname = pname;
    call.params = params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterfEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterfEXT *c = (struct qemu_glConvolutionParameterfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterfEXT( c->target, c->pname, c->params ));
}

#endif

struct qemu_glConvolutionParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterfv( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glConvolutionParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterfv(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterfv *c = (struct qemu_glConvolutionParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glConvolutionParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterfvEXT( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glConvolutionParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterfvEXT *c = (struct qemu_glConvolutionParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glConvolutionParameteri
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameteri( GLenum target, GLenum pname, GLint params )
{
    struct qemu_glConvolutionParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERI);
    call.target = target;
    call.pname = pname;
    call.params = params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameteri(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameteri *c = (struct qemu_glConvolutionParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameteri( c->target, c->pname, c->params ));
}

#endif

struct qemu_glConvolutionParameteriEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameteriEXT( GLenum target, GLenum pname, GLint params )
{
    struct qemu_glConvolutionParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERIEXT);
    call.target = target;
    call.pname = pname;
    call.params = params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameteriEXT *c = (struct qemu_glConvolutionParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameteriEXT( c->target, c->pname, c->params ));
}

#endif

struct qemu_glConvolutionParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameteriv( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glConvolutionParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameteriv(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameteriv *c = (struct qemu_glConvolutionParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glConvolutionParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterivEXT( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glConvolutionParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterivEXT *c = (struct qemu_glConvolutionParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glConvolutionParameterxOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterxOES( GLenum target, GLenum pname, GLfixed param )
{
    struct qemu_glConvolutionParameterxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERXOES);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterxOES(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterxOES *c = (struct qemu_glConvolutionParameterxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterxOES( c->target, c->pname, c->param ));
}

#endif

struct qemu_glConvolutionParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glConvolutionParameterxvOES( GLenum target, GLenum pname, const GLfixed *params )
{
    struct qemu_glConvolutionParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCONVOLUTIONPARAMETERXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glConvolutionParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glConvolutionParameterxvOES *c = (struct qemu_glConvolutionParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glConvolutionParameterxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCopyBufferSubData
{
    struct qemu_syscall super;
    uint64_t readTarget;
    uint64_t writeTarget;
    uint64_t readOffset;
    uint64_t writeOffset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyBufferSubData( GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size )
{
    struct qemu_glCopyBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYBUFFERSUBDATA);
    call.readTarget = readTarget;
    call.writeTarget = writeTarget;
    call.readOffset = readOffset;
    call.writeOffset = writeOffset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glCopyBufferSubData *c = (struct qemu_glCopyBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyBufferSubData( c->readTarget, c->writeTarget, c->readOffset, c->writeOffset, c->size ));
}

#endif

struct qemu_glCopyColorSubTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyColorSubTable( GLenum target, GLsizei start, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyColorSubTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCOLORSUBTABLE);
    call.target = target;
    call.start = start;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyColorSubTable(struct qemu_syscall *call)
{
    struct qemu_glCopyColorSubTable *c = (struct qemu_glCopyColorSubTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyColorSubTable( c->target, c->start, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyColorSubTableEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyColorSubTableEXT( GLenum target, GLsizei start, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyColorSubTableEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCOLORSUBTABLEEXT);
    call.target = target;
    call.start = start;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyColorSubTableEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyColorSubTableEXT *c = (struct qemu_glCopyColorSubTableEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyColorSubTableEXT( c->target, c->start, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyColorTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyColorTable( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyColorTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCOLORTABLE);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyColorTable(struct qemu_syscall *call)
{
    struct qemu_glCopyColorTable *c = (struct qemu_glCopyColorTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyColorTable( c->target, c->internalformat, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyColorTableSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyColorTableSGI( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyColorTableSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCOLORTABLESGI);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyColorTableSGI(struct qemu_syscall *call)
{
    struct qemu_glCopyColorTableSGI *c = (struct qemu_glCopyColorTableSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyColorTableSGI( c->target, c->internalformat, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyConvolutionFilter1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyConvolutionFilter1D( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyConvolutionFilter1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCONVOLUTIONFILTER1D);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyConvolutionFilter1D(struct qemu_syscall *call)
{
    struct qemu_glCopyConvolutionFilter1D *c = (struct qemu_glCopyConvolutionFilter1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyConvolutionFilter1D( c->target, c->internalformat, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyConvolutionFilter1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyConvolutionFilter1DEXT( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyConvolutionFilter1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCONVOLUTIONFILTER1DEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyConvolutionFilter1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyConvolutionFilter1DEXT *c = (struct qemu_glCopyConvolutionFilter1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyConvolutionFilter1DEXT( c->target, c->internalformat, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyConvolutionFilter2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyConvolutionFilter2D( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyConvolutionFilter2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCONVOLUTIONFILTER2D);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyConvolutionFilter2D(struct qemu_syscall *call)
{
    struct qemu_glCopyConvolutionFilter2D *c = (struct qemu_glCopyConvolutionFilter2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyConvolutionFilter2D( c->target, c->internalformat, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyConvolutionFilter2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyConvolutionFilter2DEXT( GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyConvolutionFilter2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYCONVOLUTIONFILTER2DEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyConvolutionFilter2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyConvolutionFilter2DEXT *c = (struct qemu_glCopyConvolutionFilter2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyConvolutionFilter2DEXT( c->target, c->internalformat, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyImageSubData
{
    struct qemu_syscall super;
    uint64_t srcName;
    uint64_t srcTarget;
    uint64_t srcLevel;
    uint64_t srcX;
    uint64_t srcY;
    uint64_t srcZ;
    uint64_t dstName;
    uint64_t dstTarget;
    uint64_t dstLevel;
    uint64_t dstX;
    uint64_t dstY;
    uint64_t dstZ;
    uint64_t srcWidth;
    uint64_t srcHeight;
    uint64_t srcDepth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyImageSubData( GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth )
{
    struct qemu_glCopyImageSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYIMAGESUBDATA);
    call.srcName = srcName;
    call.srcTarget = srcTarget;
    call.srcLevel = srcLevel;
    call.srcX = srcX;
    call.srcY = srcY;
    call.srcZ = srcZ;
    call.dstName = dstName;
    call.dstTarget = dstTarget;
    call.dstLevel = dstLevel;
    call.dstX = dstX;
    call.dstY = dstY;
    call.dstZ = dstZ;
    call.srcWidth = srcWidth;
    call.srcHeight = srcHeight;
    call.srcDepth = srcDepth;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyImageSubData(struct qemu_syscall *call)
{
    struct qemu_glCopyImageSubData *c = (struct qemu_glCopyImageSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyImageSubData( c->srcName, c->srcTarget, c->srcLevel, c->srcX, c->srcY, c->srcZ, c->dstName, c->dstTarget, c->dstLevel, c->dstX, c->dstY, c->dstZ, c->srcWidth, c->srcHeight, c->srcDepth ));
}

#endif

struct qemu_glCopyImageSubDataNV
{
    struct qemu_syscall super;
    uint64_t srcName;
    uint64_t srcTarget;
    uint64_t srcLevel;
    uint64_t srcX;
    uint64_t srcY;
    uint64_t srcZ;
    uint64_t dstName;
    uint64_t dstTarget;
    uint64_t dstLevel;
    uint64_t dstX;
    uint64_t dstY;
    uint64_t dstZ;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyImageSubDataNV( GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glCopyImageSubDataNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYIMAGESUBDATANV);
    call.srcName = srcName;
    call.srcTarget = srcTarget;
    call.srcLevel = srcLevel;
    call.srcX = srcX;
    call.srcY = srcY;
    call.srcZ = srcZ;
    call.dstName = dstName;
    call.dstTarget = dstTarget;
    call.dstLevel = dstLevel;
    call.dstX = dstX;
    call.dstY = dstY;
    call.dstZ = dstZ;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyImageSubDataNV(struct qemu_syscall *call)
{
    struct qemu_glCopyImageSubDataNV *c = (struct qemu_glCopyImageSubDataNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyImageSubDataNV( c->srcName, c->srcTarget, c->srcLevel, c->srcX, c->srcY, c->srcZ, c->dstName, c->dstTarget, c->dstLevel, c->dstX, c->dstY, c->dstZ, c->width, c->height, c->depth ));
}

#endif

struct qemu_glCopyMultiTexImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyMultiTexImage1DEXT( GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border )
{
    struct qemu_glCopyMultiTexImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYMULTITEXIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyMultiTexImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyMultiTexImage1DEXT *c = (struct qemu_glCopyMultiTexImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyMultiTexImage1DEXT( c->texunit, c->target, c->level, c->internalformat, c->x, c->y, c->width, c->border ));
}

#endif

struct qemu_glCopyMultiTexImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyMultiTexImage2DEXT( GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
    struct qemu_glCopyMultiTexImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYMULTITEXIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyMultiTexImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyMultiTexImage2DEXT *c = (struct qemu_glCopyMultiTexImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyMultiTexImage2DEXT( c->texunit, c->target, c->level, c->internalformat, c->x, c->y, c->width, c->height, c->border ));
}

#endif

struct qemu_glCopyMultiTexSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyMultiTexSubImage1DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyMultiTexSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYMULTITEXSUBIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyMultiTexSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyMultiTexSubImage1DEXT *c = (struct qemu_glCopyMultiTexSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyMultiTexSubImage1DEXT( c->texunit, c->target, c->level, c->xoffset, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyMultiTexSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyMultiTexSubImage2DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyMultiTexSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYMULTITEXSUBIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyMultiTexSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyMultiTexSubImage2DEXT *c = (struct qemu_glCopyMultiTexSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyMultiTexSubImage2DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyMultiTexSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyMultiTexSubImage3DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyMultiTexSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYMULTITEXSUBIMAGE3DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyMultiTexSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyMultiTexSubImage3DEXT *c = (struct qemu_glCopyMultiTexSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyMultiTexSubImage3DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyNamedBufferSubData
{
    struct qemu_syscall super;
    uint64_t readBuffer;
    uint64_t writeBuffer;
    uint64_t readOffset;
    uint64_t writeOffset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyNamedBufferSubData( GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size )
{
    struct qemu_glCopyNamedBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYNAMEDBUFFERSUBDATA);
    call.readBuffer = readBuffer;
    call.writeBuffer = writeBuffer;
    call.readOffset = readOffset;
    call.writeOffset = writeOffset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyNamedBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glCopyNamedBufferSubData *c = (struct qemu_glCopyNamedBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyNamedBufferSubData( c->readBuffer, c->writeBuffer, c->readOffset, c->writeOffset, c->size ));
}

#endif

struct qemu_glCopyPathNV
{
    struct qemu_syscall super;
    uint64_t resultPath;
    uint64_t srcPath;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyPathNV( GLuint resultPath, GLuint srcPath )
{
    struct qemu_glCopyPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYPATHNV);
    call.resultPath = resultPath;
    call.srcPath = srcPath;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyPathNV(struct qemu_syscall *call)
{
    struct qemu_glCopyPathNV *c = (struct qemu_glCopyPathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyPathNV( c->resultPath, c->srcPath ));
}

#endif

struct qemu_glCopyTexImage1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexImage1DEXT( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border )
{
    struct qemu_glCopyTexImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXIMAGE1DEXT);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTexImage1DEXT *c = (struct qemu_glCopyTexImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexImage1DEXT( c->target, c->level, c->internalformat, c->x, c->y, c->width, c->border ));
}

#endif

struct qemu_glCopyTexImage2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexImage2DEXT( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
    struct qemu_glCopyTexImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXIMAGE2DEXT);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTexImage2DEXT *c = (struct qemu_glCopyTexImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexImage2DEXT( c->target, c->level, c->internalformat, c->x, c->y, c->width, c->height, c->border ));
}

#endif

struct qemu_glCopyTexSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexSubImage1DEXT( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyTexSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXSUBIMAGE1DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTexSubImage1DEXT *c = (struct qemu_glCopyTexSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexSubImage1DEXT( c->target, c->level, c->xoffset, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyTexSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexSubImage2DEXT( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTexSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXSUBIMAGE2DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTexSubImage2DEXT *c = (struct qemu_glCopyTexSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexSubImage2DEXT( c->target, c->level, c->xoffset, c->yoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTexSubImage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTexSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXSUBIMAGE3D);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glCopyTexSubImage3D *c = (struct qemu_glCopyTexSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexSubImage3D( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTexSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTexSubImage3DEXT( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTexSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXSUBIMAGE3DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTexSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTexSubImage3DEXT *c = (struct qemu_glCopyTexSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTexSubImage3DEXT( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTextureImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureImage1DEXT( GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border )
{
    struct qemu_glCopyTextureImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTUREIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureImage1DEXT *c = (struct qemu_glCopyTextureImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureImage1DEXT( c->texture, c->target, c->level, c->internalformat, c->x, c->y, c->width, c->border ));
}

#endif

struct qemu_glCopyTextureImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t border;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureImage2DEXT( GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
    struct qemu_glCopyTextureImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTUREIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.border = border;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureImage2DEXT *c = (struct qemu_glCopyTextureImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureImage2DEXT( c->texture, c->target, c->level, c->internalformat, c->x, c->y, c->width, c->height, c->border ));
}

#endif

struct qemu_glCopyTextureSubImage1D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage1D( GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyTextureSubImage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE1D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage1D(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage1D *c = (struct qemu_glCopyTextureSubImage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage1D( c->texture, c->level, c->xoffset, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyTextureSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage1DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
    struct qemu_glCopyTextureSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.x = x;
    call.y = y;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage1DEXT *c = (struct qemu_glCopyTextureSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage1DEXT( c->texture, c->target, c->level, c->xoffset, c->x, c->y, c->width ));
}

#endif

struct qemu_glCopyTextureSubImage2D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage2D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTextureSubImage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE2D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage2D(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage2D *c = (struct qemu_glCopyTextureSubImage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage2D( c->texture, c->level, c->xoffset, c->yoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTextureSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage2DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTextureSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage2DEXT *c = (struct qemu_glCopyTextureSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage2DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTextureSubImage3D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage3D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTextureSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE3D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage3D *c = (struct qemu_glCopyTextureSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage3D( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCopyTextureSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCopyTextureSubImage3DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glCopyTextureSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOPYTEXTURESUBIMAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glCopyTextureSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glCopyTextureSubImage3DEXT *c = (struct qemu_glCopyTextureSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCopyTextureSubImage3DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glCoverFillPathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t coverMode;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverFillPathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glCoverFillPathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERFILLPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.coverMode = coverMode;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverFillPathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glCoverFillPathInstancedNV *c = (struct qemu_glCoverFillPathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverFillPathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->coverMode, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glCoverFillPathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t coverMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverFillPathNV( GLuint path, GLenum coverMode )
{
    struct qemu_glCoverFillPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERFILLPATHNV);
    call.path = path;
    call.coverMode = coverMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverFillPathNV(struct qemu_syscall *call)
{
    struct qemu_glCoverFillPathNV *c = (struct qemu_glCoverFillPathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverFillPathNV( c->path, c->coverMode ));
}

#endif

struct qemu_glCoverStrokePathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t coverMode;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverStrokePathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glCoverStrokePathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERSTROKEPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.coverMode = coverMode;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverStrokePathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glCoverStrokePathInstancedNV *c = (struct qemu_glCoverStrokePathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverStrokePathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->coverMode, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glCoverStrokePathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t coverMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverStrokePathNV( GLuint path, GLenum coverMode )
{
    struct qemu_glCoverStrokePathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERSTROKEPATHNV);
    call.path = path;
    call.coverMode = coverMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverStrokePathNV(struct qemu_syscall *call)
{
    struct qemu_glCoverStrokePathNV *c = (struct qemu_glCoverStrokePathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverStrokePathNV( c->path, c->coverMode ));
}

#endif

struct qemu_glCoverageModulationNV
{
    struct qemu_syscall super;
    uint64_t components;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverageModulationNV( GLenum components )
{
    struct qemu_glCoverageModulationNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERAGEMODULATIONNV);
    call.components = components;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverageModulationNV(struct qemu_syscall *call)
{
    struct qemu_glCoverageModulationNV *c = (struct qemu_glCoverageModulationNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverageModulationNV( c->components ));
}

#endif

struct qemu_glCoverageModulationTableNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCoverageModulationTableNV( GLsizei n, const GLfloat *v )
{
    struct qemu_glCoverageModulationTableNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCOVERAGEMODULATIONTABLENV);
    call.n = n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glCoverageModulationTableNV(struct qemu_syscall *call)
{
    struct qemu_glCoverageModulationTableNV *c = (struct qemu_glCoverageModulationTableNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCoverageModulationTableNV( c->n, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glCreateBuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateBuffers( GLsizei n, GLuint *buffers )
{
    struct qemu_glCreateBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEBUFFERS);
    call.n = n;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateBuffers(struct qemu_syscall *call)
{
    struct qemu_glCreateBuffers *c = (struct qemu_glCreateBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateBuffers( c->n, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glCreateCommandListsNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t lists;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateCommandListsNV( GLsizei n, GLuint *lists )
{
    struct qemu_glCreateCommandListsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATECOMMANDLISTSNV);
    call.n = n;
    call.lists = (ULONG_PTR)lists;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateCommandListsNV(struct qemu_syscall *call)
{
    struct qemu_glCreateCommandListsNV *c = (struct qemu_glCreateCommandListsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateCommandListsNV( c->n, QEMU_G2H(c->lists) ));
}

#endif

struct qemu_glCreateFramebuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t framebuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateFramebuffers( GLsizei n, GLuint *framebuffers )
{
    struct qemu_glCreateFramebuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEFRAMEBUFFERS);
    call.n = n;
    call.framebuffers = (ULONG_PTR)framebuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateFramebuffers(struct qemu_syscall *call)
{
    struct qemu_glCreateFramebuffers *c = (struct qemu_glCreateFramebuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateFramebuffers( c->n, QEMU_G2H(c->framebuffers) ));
}

#endif

struct qemu_glCreateMemoryObjectsEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t memoryObjects;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateMemoryObjectsEXT( GLsizei n, GLuint *memoryObjects )
{
    struct qemu_glCreateMemoryObjectsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEMEMORYOBJECTSEXT);
    call.n = n;
    call.memoryObjects = (ULONG_PTR)memoryObjects;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateMemoryObjectsEXT(struct qemu_syscall *call)
{
    struct qemu_glCreateMemoryObjectsEXT *c = (struct qemu_glCreateMemoryObjectsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateMemoryObjectsEXT( c->n, QEMU_G2H(c->memoryObjects) ));
}

#endif

struct qemu_glCreatePerfQueryINTEL
{
    struct qemu_syscall super;
    uint64_t queryId;
    uint64_t queryHandle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreatePerfQueryINTEL( GLuint queryId, GLuint *queryHandle )
{
    struct qemu_glCreatePerfQueryINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEPERFQUERYINTEL);
    call.queryId = queryId;
    call.queryHandle = (ULONG_PTR)queryHandle;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreatePerfQueryINTEL(struct qemu_syscall *call)
{
    struct qemu_glCreatePerfQueryINTEL *c = (struct qemu_glCreatePerfQueryINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreatePerfQueryINTEL( c->queryId, QEMU_G2H(c->queryHandle) ));
}

#endif

struct qemu_glCreateProgram
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glCreateProgram(void)
{
    struct qemu_glCreateProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEPROGRAM);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateProgram(struct qemu_syscall *call)
{
    struct qemu_glCreateProgram *c = (struct qemu_glCreateProgram *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateProgram());
}

#endif

struct qemu_glCreateProgramObjectARB
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLhandleARB WINAPI glCreateProgramObjectARB(void)
{
    struct qemu_glCreateProgramObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEPROGRAMOBJECTARB);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateProgramObjectARB(struct qemu_syscall *call)
{
    struct qemu_glCreateProgramObjectARB *c = (struct qemu_glCreateProgramObjectARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateProgramObjectARB());
}

#endif

struct qemu_glCreateProgramPipelines
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t pipelines;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateProgramPipelines( GLsizei n, GLuint *pipelines )
{
    struct qemu_glCreateProgramPipelines call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEPROGRAMPIPELINES);
    call.n = n;
    call.pipelines = (ULONG_PTR)pipelines;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateProgramPipelines(struct qemu_syscall *call)
{
    struct qemu_glCreateProgramPipelines *c = (struct qemu_glCreateProgramPipelines *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateProgramPipelines( c->n, QEMU_G2H(c->pipelines) ));
}

#endif

struct qemu_glCreateProgressFenceNVX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glCreateProgressFenceNVX(void)
{
    struct qemu_glCreateProgressFenceNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEPROGRESSFENCENVX);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateProgressFenceNVX(struct qemu_syscall *call)
{
    struct qemu_glCreateProgressFenceNVX *c = (struct qemu_glCreateProgressFenceNVX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateProgressFenceNVX());
}

#endif

struct qemu_glCreateQueries
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateQueries( GLenum target, GLsizei n, GLuint *ids )
{
    struct qemu_glCreateQueries call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEQUERIES);
    call.target = target;
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateQueries(struct qemu_syscall *call)
{
    struct qemu_glCreateQueries *c = (struct qemu_glCreateQueries *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateQueries( c->target, c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glCreateRenderbuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t renderbuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateRenderbuffers( GLsizei n, GLuint *renderbuffers )
{
    struct qemu_glCreateRenderbuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATERENDERBUFFERS);
    call.n = n;
    call.renderbuffers = (ULONG_PTR)renderbuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateRenderbuffers(struct qemu_syscall *call)
{
    struct qemu_glCreateRenderbuffers *c = (struct qemu_glCreateRenderbuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateRenderbuffers( c->n, QEMU_G2H(c->renderbuffers) ));
}

#endif

struct qemu_glCreateSamplers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t samplers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateSamplers( GLsizei n, GLuint *samplers )
{
    struct qemu_glCreateSamplers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESAMPLERS);
    call.n = n;
    call.samplers = (ULONG_PTR)samplers;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateSamplers(struct qemu_syscall *call)
{
    struct qemu_glCreateSamplers *c = (struct qemu_glCreateSamplers *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateSamplers( c->n, QEMU_G2H(c->samplers) ));
}

#endif

struct qemu_glCreateShader
{
    struct qemu_syscall super;
    uint64_t type;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glCreateShader( GLenum type )
{
    struct qemu_glCreateShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESHADER);
    call.type = type;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateShader(struct qemu_syscall *call)
{
    struct qemu_glCreateShader *c = (struct qemu_glCreateShader *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateShader( c->type ));
}

#endif

struct qemu_glCreateShaderObjectARB
{
    struct qemu_syscall super;
    uint64_t shaderType;
};

#ifdef QEMU_DLL_GUEST

GLhandleARB WINAPI glCreateShaderObjectARB( GLenum shaderType )
{
    struct qemu_glCreateShaderObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESHADEROBJECTARB);
    call.shaderType = shaderType;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateShaderObjectARB(struct qemu_syscall *call)
{
    struct qemu_glCreateShaderObjectARB *c = (struct qemu_glCreateShaderObjectARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateShaderObjectARB( c->shaderType ));
}

#endif

struct qemu_glCreateShaderProgramEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glCreateShaderProgramEXT( GLenum type, const GLchar *string )
{
    struct qemu_glCreateShaderProgramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESHADERPROGRAMEXT);
    call.type = type;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateShaderProgramEXT(struct qemu_syscall *call)
{
    struct qemu_glCreateShaderProgramEXT *c = (struct qemu_glCreateShaderProgramEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateShaderProgramEXT( c->type, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glCreateShaderProgramv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t count;
    uint64_t strings;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glCreateShaderProgramv( GLenum type, GLsizei count, const GLchar *const*strings )
{
    struct qemu_glCreateShaderProgramv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESHADERPROGRAMV);
    call.type = type;
    call.count = count;
    call.strings = (ULONG_PTR)strings;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glCreateShaderProgramv(struct qemu_syscall *call)
{
    struct qemu_glCreateShaderProgramv *c = (struct qemu_glCreateShaderProgramv *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glCreateShaderProgramv( c->type, c->count, QEMU_G2H(c->strings) ));
}

#endif

struct qemu_glCreateStatesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t states;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateStatesNV( GLsizei n, GLuint *states )
{
    struct qemu_glCreateStatesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESTATESNV);
    call.n = n;
    call.states = (ULONG_PTR)states;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateStatesNV(struct qemu_syscall *call)
{
    struct qemu_glCreateStatesNV *c = (struct qemu_glCreateStatesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateStatesNV( c->n, QEMU_G2H(c->states) ));
}

#endif

struct qemu_glCreateSyncFromCLeventARB
{
    struct qemu_syscall super;
    uint64_t context;
    uint64_t event;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

GLsync WINAPI glCreateSyncFromCLeventARB( struct _cl_context *context, struct _cl_event *event, GLbitfield flags )
{
    struct qemu_glCreateSyncFromCLeventARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATESYNCFROMCLEVENTARB);
    call.context = (ULONG_PTR)context;
    call.event = (ULONG_PTR)event;
    call.flags = flags;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glCreateSyncFromCLeventARB(struct qemu_syscall *call)
{
    struct qemu_glCreateSyncFromCLeventARB *c = (struct qemu_glCreateSyncFromCLeventARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glCreateSyncFromCLeventARB( QEMU_G2H(c->context), QEMU_G2H(c->event), c->flags ));
}

#endif

struct qemu_glCreateTextures
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t n;
    uint64_t textures;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateTextures( GLenum target, GLsizei n, GLuint *textures )
{
    struct qemu_glCreateTextures call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATETEXTURES);
    call.target = target;
    call.n = n;
    call.textures = (ULONG_PTR)textures;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateTextures(struct qemu_syscall *call)
{
    struct qemu_glCreateTextures *c = (struct qemu_glCreateTextures *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateTextures( c->target, c->n, QEMU_G2H(c->textures) ));
}

#endif

struct qemu_glCreateTransformFeedbacks
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateTransformFeedbacks( GLsizei n, GLuint *ids )
{
    struct qemu_glCreateTransformFeedbacks call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATETRANSFORMFEEDBACKS);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateTransformFeedbacks(struct qemu_syscall *call)
{
    struct qemu_glCreateTransformFeedbacks *c = (struct qemu_glCreateTransformFeedbacks *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateTransformFeedbacks( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glCreateVertexArrays
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t arrays;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCreateVertexArrays( GLsizei n, GLuint *arrays )
{
    struct qemu_glCreateVertexArrays call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCREATEVERTEXARRAYS);
    call.n = n;
    call.arrays = (ULONG_PTR)arrays;

    qemu_syscall(&call.super);
}

#else

void qemu_glCreateVertexArrays(struct qemu_syscall *call)
{
    struct qemu_glCreateVertexArrays *c = (struct qemu_glCreateVertexArrays *)call;
    WINE_FIXME("Unverified\n");
    (p_glCreateVertexArrays( c->n, QEMU_G2H(c->arrays) ));
}

#endif

struct qemu_glCullParameterdvEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCullParameterdvEXT( GLenum pname, GLdouble *params )
{
    struct qemu_glCullParameterdvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCULLPARAMETERDVEXT);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glCullParameterdvEXT(struct qemu_syscall *call)
{
    struct qemu_glCullParameterdvEXT *c = (struct qemu_glCullParameterdvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCullParameterdvEXT( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCullParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCullParameterfvEXT( GLenum pname, GLfloat *params )
{
    struct qemu_glCullParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCULLPARAMETERFVEXT);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glCullParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glCullParameterfvEXT *c = (struct qemu_glCullParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glCullParameterfvEXT( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glCurrentPaletteMatrixARB
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glCurrentPaletteMatrixARB( GLint index )
{
    struct qemu_glCurrentPaletteMatrixARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLCURRENTPALETTEMATRIXARB);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glCurrentPaletteMatrixARB(struct qemu_syscall *call)
{
    struct qemu_glCurrentPaletteMatrixARB *c = (struct qemu_glCurrentPaletteMatrixARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glCurrentPaletteMatrixARB( c->index ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_glDebugMessageControl
{
    struct qemu_syscall super;
    uint64_t source;
    uint64_t type;
    uint64_t severity;
    uint64_t count;
    uint64_t ids;
    uint64_t enabled;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageControl( GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled )
{
    struct qemu_glDebugMessageControl call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGECONTROL);
    call.source = source;
    call.type = type;
    call.severity = severity;
    call.count = count;
    call.ids = (ULONG_PTR)ids;
    call.enabled = enabled;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageControl(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageControl *c = (struct qemu_glDebugMessageControl *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageControl( c->source, c->type, c->severity, c->count, QEMU_G2H(c->ids), c->enabled ));
}

#endif

struct qemu_glDebugMessageControlARB
{
    struct qemu_syscall super;
    uint64_t source;
    uint64_t type;
    uint64_t severity;
    uint64_t count;
    uint64_t ids;
    uint64_t enabled;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageControlARB( GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled )
{
    struct qemu_glDebugMessageControlARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGECONTROLARB);
    call.source = source;
    call.type = type;
    call.severity = severity;
    call.count = count;
    call.ids = (ULONG_PTR)ids;
    call.enabled = enabled;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageControlARB(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageControlARB *c = (struct qemu_glDebugMessageControlARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageControlARB( c->source, c->type, c->severity, c->count, QEMU_G2H(c->ids), c->enabled ));
}

#endif

struct qemu_glDebugMessageEnableAMD
{
    struct qemu_syscall super;
    uint64_t category;
    uint64_t severity;
    uint64_t count;
    uint64_t ids;
    uint64_t enabled;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageEnableAMD( GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled )
{
    struct qemu_glDebugMessageEnableAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGEENABLEAMD);
    call.category = category;
    call.severity = severity;
    call.count = count;
    call.ids = (ULONG_PTR)ids;
    call.enabled = enabled;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageEnableAMD(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageEnableAMD *c = (struct qemu_glDebugMessageEnableAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageEnableAMD( c->category, c->severity, c->count, QEMU_G2H(c->ids), c->enabled ));
}

#endif

struct qemu_glDebugMessageInsert
{
    struct qemu_syscall super;
    uint64_t source;
    uint64_t type;
    uint64_t id;
    uint64_t severity;
    uint64_t length;
    uint64_t buf;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageInsert( GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf )
{
    struct qemu_glDebugMessageInsert call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGEINSERT);
    call.source = source;
    call.type = type;
    call.id = id;
    call.severity = severity;
    call.length = length;
    call.buf = (ULONG_PTR)buf;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageInsert(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageInsert *c = (struct qemu_glDebugMessageInsert *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageInsert( c->source, c->type, c->id, c->severity, c->length, QEMU_G2H(c->buf) ));
}

#endif

struct qemu_glDebugMessageInsertAMD
{
    struct qemu_syscall super;
    uint64_t category;
    uint64_t severity;
    uint64_t id;
    uint64_t length;
    uint64_t buf;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageInsertAMD( GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf )
{
    struct qemu_glDebugMessageInsertAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGEINSERTAMD);
    call.category = category;
    call.severity = severity;
    call.id = id;
    call.length = length;
    call.buf = (ULONG_PTR)buf;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageInsertAMD(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageInsertAMD *c = (struct qemu_glDebugMessageInsertAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageInsertAMD( c->category, c->severity, c->id, c->length, QEMU_G2H(c->buf) ));
}

#endif

struct qemu_glDebugMessageInsertARB
{
    struct qemu_syscall super;
    uint64_t source;
    uint64_t type;
    uint64_t id;
    uint64_t severity;
    uint64_t length;
    uint64_t buf;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDebugMessageInsertARB( GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf )
{
    struct qemu_glDebugMessageInsertARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEBUGMESSAGEINSERTARB);
    call.source = source;
    call.type = type;
    call.id = id;
    call.severity = severity;
    call.length = length;
    call.buf = (ULONG_PTR)buf;

    qemu_syscall(&call.super);
}

#else

void qemu_glDebugMessageInsertARB(struct qemu_syscall *call)
{
    struct qemu_glDebugMessageInsertARB *c = (struct qemu_glDebugMessageInsertARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDebugMessageInsertARB( c->source, c->type, c->id, c->severity, c->length, QEMU_G2H(c->buf) ));
}

#endif

struct qemu_glDeformSGIX
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeformSGIX( GLbitfield mask )
{
    struct qemu_glDeformSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEFORMSGIX);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeformSGIX(struct qemu_syscall *call)
{
    struct qemu_glDeformSGIX *c = (struct qemu_glDeformSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeformSGIX( c->mask ));
}

#endif

struct qemu_glDeformationMap3dSGIX
{
    struct qemu_syscall super;
    uint64_t target;
    double u1;
    double u2;
    uint64_t ustride;
    uint64_t uorder;
    double v1;
    double v2;
    uint64_t vstride;
    uint64_t vorder;
    double w1;
    double w2;
    uint64_t wstride;
    uint64_t worder;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeformationMap3dSGIX( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points )
{
    struct qemu_glDeformationMap3dSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEFORMATIONMAP3DSGIX);
    call.target = target;
    call.u1 = u1;
    call.u2 = u2;
    call.ustride = ustride;
    call.uorder = uorder;
    call.v1 = v1;
    call.v2 = v2;
    call.vstride = vstride;
    call.vorder = vorder;
    call.w1 = w1;
    call.w2 = w2;
    call.wstride = wstride;
    call.worder = worder;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeformationMap3dSGIX(struct qemu_syscall *call)
{
    struct qemu_glDeformationMap3dSGIX *c = (struct qemu_glDeformationMap3dSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeformationMap3dSGIX( c->target, c->u1, c->u2, c->ustride, c->uorder, c->v1, c->v2, c->vstride, c->vorder, c->w1, c->w2, c->wstride, c->worder, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glDeformationMap3fSGIX
{
    struct qemu_syscall super;
    uint64_t target;
    double u1;
    double u2;
    uint64_t ustride;
    uint64_t uorder;
    double v1;
    double v2;
    uint64_t vstride;
    uint64_t vorder;
    double w1;
    double w2;
    uint64_t wstride;
    uint64_t worder;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeformationMap3fSGIX( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points )
{
    struct qemu_glDeformationMap3fSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEFORMATIONMAP3FSGIX);
    call.target = target;
    call.u1 = u1;
    call.u2 = u2;
    call.ustride = ustride;
    call.uorder = uorder;
    call.v1 = v1;
    call.v2 = v2;
    call.vstride = vstride;
    call.vorder = vorder;
    call.w1 = w1;
    call.w2 = w2;
    call.wstride = wstride;
    call.worder = worder;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeformationMap3fSGIX(struct qemu_syscall *call)
{
    struct qemu_glDeformationMap3fSGIX *c = (struct qemu_glDeformationMap3fSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeformationMap3fSGIX( c->target, c->u1, c->u2, c->ustride, c->uorder, c->v1, c->v2, c->vstride, c->vorder, c->w1, c->w2, c->wstride, c->worder, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glDeleteAsyncMarkersSGIX
{
    struct qemu_syscall super;
    uint64_t marker;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteAsyncMarkersSGIX( GLuint marker, GLsizei range )
{
    struct qemu_glDeleteAsyncMarkersSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEASYNCMARKERSSGIX);
    call.marker = marker;
    call.range = range;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteAsyncMarkersSGIX(struct qemu_syscall *call)
{
    struct qemu_glDeleteAsyncMarkersSGIX *c = (struct qemu_glDeleteAsyncMarkersSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteAsyncMarkersSGIX( c->marker, c->range ));
}

#endif

struct qemu_glDeleteBufferRegion
{
    struct qemu_syscall super;
    uint64_t region;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteBufferRegion( GLenum region )
{
    struct qemu_glDeleteBufferRegion call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEBUFFERREGION);
    call.region = region;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteBufferRegion(struct qemu_syscall *call)
{
    struct qemu_glDeleteBufferRegion *c = (struct qemu_glDeleteBufferRegion *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteBufferRegion( c->region ));
}

#endif

struct qemu_glDeleteBuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteBuffers( GLsizei n, const GLuint *buffers )
{
    struct qemu_glDeleteBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEBUFFERS);
    call.n = n;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteBuffers(struct qemu_syscall *call)
{
    struct qemu_glDeleteBuffers *c = (struct qemu_glDeleteBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteBuffers( c->n, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glDeleteBuffersARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteBuffersARB( GLsizei n, const GLuint *buffers )
{
    struct qemu_glDeleteBuffersARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEBUFFERSARB);
    call.n = n;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteBuffersARB(struct qemu_syscall *call)
{
    struct qemu_glDeleteBuffersARB *c = (struct qemu_glDeleteBuffersARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteBuffersARB( c->n, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glDeleteCommandListsNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t lists;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteCommandListsNV( GLsizei n, const GLuint *lists )
{
    struct qemu_glDeleteCommandListsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETECOMMANDLISTSNV);
    call.n = n;
    call.lists = (ULONG_PTR)lists;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteCommandListsNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteCommandListsNV *c = (struct qemu_glDeleteCommandListsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteCommandListsNV( c->n, QEMU_G2H(c->lists) ));
}

#endif

struct qemu_glDeleteFencesAPPLE
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t fences;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteFencesAPPLE( GLsizei n, const GLuint *fences )
{
    struct qemu_glDeleteFencesAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEFENCESAPPLE);
    call.n = n;
    call.fences = (ULONG_PTR)fences;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteFencesAPPLE(struct qemu_syscall *call)
{
    struct qemu_glDeleteFencesAPPLE *c = (struct qemu_glDeleteFencesAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteFencesAPPLE( c->n, QEMU_G2H(c->fences) ));
}

#endif

struct qemu_glDeleteFencesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t fences;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteFencesNV( GLsizei n, const GLuint *fences )
{
    struct qemu_glDeleteFencesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEFENCESNV);
    call.n = n;
    call.fences = (ULONG_PTR)fences;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteFencesNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteFencesNV *c = (struct qemu_glDeleteFencesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteFencesNV( c->n, QEMU_G2H(c->fences) ));
}

#endif

struct qemu_glDeleteFragmentShaderATI
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteFragmentShaderATI( GLuint id )
{
    struct qemu_glDeleteFragmentShaderATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEFRAGMENTSHADERATI);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteFragmentShaderATI(struct qemu_syscall *call)
{
    struct qemu_glDeleteFragmentShaderATI *c = (struct qemu_glDeleteFragmentShaderATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteFragmentShaderATI( c->id ));
}

#endif

struct qemu_glDeleteFramebuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t framebuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteFramebuffers( GLsizei n, const GLuint *framebuffers )
{
    struct qemu_glDeleteFramebuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEFRAMEBUFFERS);
    call.n = n;
    call.framebuffers = (ULONG_PTR)framebuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteFramebuffers(struct qemu_syscall *call)
{
    struct qemu_glDeleteFramebuffers *c = (struct qemu_glDeleteFramebuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteFramebuffers( c->n, QEMU_G2H(c->framebuffers) ));
}

#endif

struct qemu_glDeleteFramebuffersEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t framebuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteFramebuffersEXT( GLsizei n, const GLuint *framebuffers )
{
    struct qemu_glDeleteFramebuffersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEFRAMEBUFFERSEXT);
    call.n = n;
    call.framebuffers = (ULONG_PTR)framebuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteFramebuffersEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteFramebuffersEXT *c = (struct qemu_glDeleteFramebuffersEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteFramebuffersEXT( c->n, QEMU_G2H(c->framebuffers) ));
}

#endif

struct qemu_glDeleteMemoryObjectsEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t memoryObjects;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteMemoryObjectsEXT( GLsizei n, const GLuint *memoryObjects )
{
    struct qemu_glDeleteMemoryObjectsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEMEMORYOBJECTSEXT);
    call.n = n;
    call.memoryObjects = (ULONG_PTR)memoryObjects;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteMemoryObjectsEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteMemoryObjectsEXT *c = (struct qemu_glDeleteMemoryObjectsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteMemoryObjectsEXT( c->n, QEMU_G2H(c->memoryObjects) ));
}

#endif

struct qemu_glDeleteNamedStringARB
{
    struct qemu_syscall super;
    uint64_t namelen;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteNamedStringARB( GLint namelen, const GLchar *name )
{
    struct qemu_glDeleteNamedStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETENAMEDSTRINGARB);
    call.namelen = namelen;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteNamedStringARB(struct qemu_syscall *call)
{
    struct qemu_glDeleteNamedStringARB *c = (struct qemu_glDeleteNamedStringARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteNamedStringARB( c->namelen, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glDeleteNamesAMD
{
    struct qemu_syscall super;
    uint64_t identifier;
    uint64_t num;
    uint64_t names;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteNamesAMD( GLenum identifier, GLuint num, const GLuint *names )
{
    struct qemu_glDeleteNamesAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETENAMESAMD);
    call.identifier = identifier;
    call.num = num;
    call.names = (ULONG_PTR)names;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteNamesAMD(struct qemu_syscall *call)
{
    struct qemu_glDeleteNamesAMD *c = (struct qemu_glDeleteNamesAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteNamesAMD( c->identifier, c->num, QEMU_G2H(c->names) ));
}

#endif

struct qemu_glDeleteObjectARB
{
    struct qemu_syscall super;
    uint64_t obj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteObjectARB( GLhandleARB obj )
{
    struct qemu_glDeleteObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEOBJECTARB);
    call.obj = obj;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteObjectARB(struct qemu_syscall *call)
{
    struct qemu_glDeleteObjectARB *c = (struct qemu_glDeleteObjectARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteObjectARB( c->obj ));
}

#endif

struct qemu_glDeleteObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteObjectBufferATI( GLuint buffer )
{
    struct qemu_glDeleteObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEOBJECTBUFFERATI);
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glDeleteObjectBufferATI *c = (struct qemu_glDeleteObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteObjectBufferATI( c->buffer ));
}

#endif

struct qemu_glDeleteOcclusionQueriesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteOcclusionQueriesNV( GLsizei n, const GLuint *ids )
{
    struct qemu_glDeleteOcclusionQueriesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEOCCLUSIONQUERIESNV);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteOcclusionQueriesNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteOcclusionQueriesNV *c = (struct qemu_glDeleteOcclusionQueriesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteOcclusionQueriesNV( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glDeletePathsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeletePathsNV( GLuint path, GLsizei range )
{
    struct qemu_glDeletePathsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPATHSNV);
    call.path = path;
    call.range = range;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeletePathsNV(struct qemu_syscall *call)
{
    struct qemu_glDeletePathsNV *c = (struct qemu_glDeletePathsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeletePathsNV( c->path, c->range ));
}

#endif

struct qemu_glDeletePerfMonitorsAMD
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t monitors;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeletePerfMonitorsAMD( GLsizei n, GLuint *monitors )
{
    struct qemu_glDeletePerfMonitorsAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPERFMONITORSAMD);
    call.n = n;
    call.monitors = (ULONG_PTR)monitors;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeletePerfMonitorsAMD(struct qemu_syscall *call)
{
    struct qemu_glDeletePerfMonitorsAMD *c = (struct qemu_glDeletePerfMonitorsAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeletePerfMonitorsAMD( c->n, QEMU_G2H(c->monitors) ));
}

#endif

struct qemu_glDeletePerfQueryINTEL
{
    struct qemu_syscall super;
    uint64_t queryHandle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeletePerfQueryINTEL( GLuint queryHandle )
{
    struct qemu_glDeletePerfQueryINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPERFQUERYINTEL);
    call.queryHandle = queryHandle;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeletePerfQueryINTEL(struct qemu_syscall *call)
{
    struct qemu_glDeletePerfQueryINTEL *c = (struct qemu_glDeletePerfQueryINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeletePerfQueryINTEL( c->queryHandle ));
}

#endif

struct qemu_glDeleteProgram
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteProgram( GLuint program )
{
    struct qemu_glDeleteProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPROGRAM);
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteProgram(struct qemu_syscall *call)
{
    struct qemu_glDeleteProgram *c = (struct qemu_glDeleteProgram *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteProgram( c->program ));
}

#endif

struct qemu_glDeleteProgramPipelines
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t pipelines;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteProgramPipelines( GLsizei n, const GLuint *pipelines )
{
    struct qemu_glDeleteProgramPipelines call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPROGRAMPIPELINES);
    call.n = n;
    call.pipelines = (ULONG_PTR)pipelines;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteProgramPipelines(struct qemu_syscall *call)
{
    struct qemu_glDeleteProgramPipelines *c = (struct qemu_glDeleteProgramPipelines *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteProgramPipelines( c->n, QEMU_G2H(c->pipelines) ));
}

#endif

struct qemu_glDeleteProgramsARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteProgramsARB( GLsizei n, const GLuint *programs )
{
    struct qemu_glDeleteProgramsARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPROGRAMSARB);
    call.n = n;
    call.programs = (ULONG_PTR)programs;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteProgramsARB(struct qemu_syscall *call)
{
    struct qemu_glDeleteProgramsARB *c = (struct qemu_glDeleteProgramsARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteProgramsARB( c->n, QEMU_G2H(c->programs) ));
}

#endif

struct qemu_glDeleteProgramsNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteProgramsNV( GLsizei n, const GLuint *programs )
{
    struct qemu_glDeleteProgramsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEPROGRAMSNV);
    call.n = n;
    call.programs = (ULONG_PTR)programs;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteProgramsNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteProgramsNV *c = (struct qemu_glDeleteProgramsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteProgramsNV( c->n, QEMU_G2H(c->programs) ));
}

#endif

struct qemu_glDeleteQueries
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteQueries( GLsizei n, const GLuint *ids )
{
    struct qemu_glDeleteQueries call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEQUERIES);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteQueries(struct qemu_syscall *call)
{
    struct qemu_glDeleteQueries *c = (struct qemu_glDeleteQueries *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteQueries( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glDeleteQueriesARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteQueriesARB( GLsizei n, const GLuint *ids )
{
    struct qemu_glDeleteQueriesARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEQUERIESARB);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteQueriesARB(struct qemu_syscall *call)
{
    struct qemu_glDeleteQueriesARB *c = (struct qemu_glDeleteQueriesARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteQueriesARB( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glDeleteQueryResourceTagNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t tagIds;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteQueryResourceTagNV( GLsizei n, const GLint *tagIds )
{
    struct qemu_glDeleteQueryResourceTagNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEQUERYRESOURCETAGNV);
    call.n = n;
    call.tagIds = (ULONG_PTR)tagIds;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteQueryResourceTagNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteQueryResourceTagNV *c = (struct qemu_glDeleteQueryResourceTagNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteQueryResourceTagNV( c->n, QEMU_G2H(c->tagIds) ));
}

#endif

struct qemu_glDeleteRenderbuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t renderbuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteRenderbuffers( GLsizei n, const GLuint *renderbuffers )
{
    struct qemu_glDeleteRenderbuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETERENDERBUFFERS);
    call.n = n;
    call.renderbuffers = (ULONG_PTR)renderbuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteRenderbuffers(struct qemu_syscall *call)
{
    struct qemu_glDeleteRenderbuffers *c = (struct qemu_glDeleteRenderbuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteRenderbuffers( c->n, QEMU_G2H(c->renderbuffers) ));
}

#endif

struct qemu_glDeleteRenderbuffersEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t renderbuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteRenderbuffersEXT( GLsizei n, const GLuint *renderbuffers )
{
    struct qemu_glDeleteRenderbuffersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETERENDERBUFFERSEXT);
    call.n = n;
    call.renderbuffers = (ULONG_PTR)renderbuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteRenderbuffersEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteRenderbuffersEXT *c = (struct qemu_glDeleteRenderbuffersEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteRenderbuffersEXT( c->n, QEMU_G2H(c->renderbuffers) ));
}

#endif

struct qemu_glDeleteSamplers
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t samplers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteSamplers( GLsizei count, const GLuint *samplers )
{
    struct qemu_glDeleteSamplers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETESAMPLERS);
    call.count = count;
    call.samplers = (ULONG_PTR)samplers;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteSamplers(struct qemu_syscall *call)
{
    struct qemu_glDeleteSamplers *c = (struct qemu_glDeleteSamplers *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteSamplers( c->count, QEMU_G2H(c->samplers) ));
}

#endif

struct qemu_glDeleteSemaphoresEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t semaphores;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteSemaphoresEXT( GLsizei n, const GLuint *semaphores )
{
    struct qemu_glDeleteSemaphoresEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETESEMAPHORESEXT);
    call.n = n;
    call.semaphores = (ULONG_PTR)semaphores;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteSemaphoresEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteSemaphoresEXT *c = (struct qemu_glDeleteSemaphoresEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteSemaphoresEXT( c->n, QEMU_G2H(c->semaphores) ));
}

#endif

struct qemu_glDeleteShader
{
    struct qemu_syscall super;
    uint64_t shader;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteShader( GLuint shader )
{
    struct qemu_glDeleteShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETESHADER);
    call.shader = shader;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteShader(struct qemu_syscall *call)
{
    struct qemu_glDeleteShader *c = (struct qemu_glDeleteShader *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteShader( c->shader ));
}

#endif

struct qemu_glDeleteStatesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t states;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteStatesNV( GLsizei n, const GLuint *states )
{
    struct qemu_glDeleteStatesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETESTATESNV);
    call.n = n;
    call.states = (ULONG_PTR)states;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteStatesNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteStatesNV *c = (struct qemu_glDeleteStatesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteStatesNV( c->n, QEMU_G2H(c->states) ));
}

#endif

struct qemu_glDeleteSync
{
    struct qemu_syscall super;
    uint64_t sync;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteSync( GLsync sync )
{
    struct qemu_glDeleteSync call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETESYNC);
    call.sync = (ULONG_PTR)sync;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteSync(struct qemu_syscall *call)
{
    struct qemu_glDeleteSync *c = (struct qemu_glDeleteSync *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteSync( QEMU_G2H(c->sync) ));
}

#endif

struct qemu_glDeleteTexturesEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t textures;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteTexturesEXT( GLsizei n, const GLuint *textures )
{
    struct qemu_glDeleteTexturesEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETETEXTURESEXT);
    call.n = n;
    call.textures = (ULONG_PTR)textures;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteTexturesEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteTexturesEXT *c = (struct qemu_glDeleteTexturesEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteTexturesEXT( c->n, QEMU_G2H(c->textures) ));
}

#endif

struct qemu_glDeleteTransformFeedbacks
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteTransformFeedbacks( GLsizei n, const GLuint *ids )
{
    struct qemu_glDeleteTransformFeedbacks call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETETRANSFORMFEEDBACKS);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteTransformFeedbacks(struct qemu_syscall *call)
{
    struct qemu_glDeleteTransformFeedbacks *c = (struct qemu_glDeleteTransformFeedbacks *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteTransformFeedbacks( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glDeleteTransformFeedbacksNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteTransformFeedbacksNV( GLsizei n, const GLuint *ids )
{
    struct qemu_glDeleteTransformFeedbacksNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETETRANSFORMFEEDBACKSNV);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteTransformFeedbacksNV(struct qemu_syscall *call)
{
    struct qemu_glDeleteTransformFeedbacksNV *c = (struct qemu_glDeleteTransformFeedbacksNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteTransformFeedbacksNV( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glDeleteVertexArrays
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t arrays;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteVertexArrays( GLsizei n, const GLuint *arrays )
{
    struct qemu_glDeleteVertexArrays call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEVERTEXARRAYS);
    call.n = n;
    call.arrays = (ULONG_PTR)arrays;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteVertexArrays(struct qemu_syscall *call)
{
    struct qemu_glDeleteVertexArrays *c = (struct qemu_glDeleteVertexArrays *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteVertexArrays( c->n, QEMU_G2H(c->arrays) ));
}

#endif

struct qemu_glDeleteVertexArraysAPPLE
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t arrays;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteVertexArraysAPPLE( GLsizei n, const GLuint *arrays )
{
    struct qemu_glDeleteVertexArraysAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEVERTEXARRAYSAPPLE);
    call.n = n;
    call.arrays = (ULONG_PTR)arrays;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteVertexArraysAPPLE(struct qemu_syscall *call)
{
    struct qemu_glDeleteVertexArraysAPPLE *c = (struct qemu_glDeleteVertexArraysAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteVertexArraysAPPLE( c->n, QEMU_G2H(c->arrays) ));
}

#endif

struct qemu_glDeleteVertexShaderEXT
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDeleteVertexShaderEXT( GLuint id )
{
    struct qemu_glDeleteVertexShaderEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDELETEVERTEXSHADEREXT);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glDeleteVertexShaderEXT(struct qemu_syscall *call)
{
    struct qemu_glDeleteVertexShaderEXT *c = (struct qemu_glDeleteVertexShaderEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDeleteVertexShaderEXT( c->id ));
}

#endif

struct qemu_glDepthBoundsEXT
{
    struct qemu_syscall super;
    uint64_t zmin;
    uint64_t zmax;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthBoundsEXT( GLclampd zmin, GLclampd zmax )
{
    struct qemu_glDepthBoundsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHBOUNDSEXT);
    call.zmin = zmin;
    call.zmax = zmax;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthBoundsEXT(struct qemu_syscall *call)
{
    struct qemu_glDepthBoundsEXT *c = (struct qemu_glDepthBoundsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthBoundsEXT( c->zmin, c->zmax ));
}

#endif

struct qemu_glDepthBoundsdNV
{
    struct qemu_syscall super;
    double zmin;
    double zmax;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthBoundsdNV( GLdouble zmin, GLdouble zmax )
{
    struct qemu_glDepthBoundsdNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHBOUNDSDNV);
    call.zmin = zmin;
    call.zmax = zmax;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthBoundsdNV(struct qemu_syscall *call)
{
    struct qemu_glDepthBoundsdNV *c = (struct qemu_glDepthBoundsdNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthBoundsdNV( c->zmin, c->zmax ));
}

#endif

struct qemu_glDepthRangeArraydvNV
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangeArraydvNV( GLuint first, GLsizei count, const GLdouble *v )
{
    struct qemu_glDepthRangeArraydvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEARRAYDVNV);
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangeArraydvNV(struct qemu_syscall *call)
{
    struct qemu_glDepthRangeArraydvNV *c = (struct qemu_glDepthRangeArraydvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangeArraydvNV( c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glDepthRangeArrayv
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangeArrayv( GLuint first, GLsizei count, const GLdouble *v )
{
    struct qemu_glDepthRangeArrayv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEARRAYV);
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangeArrayv(struct qemu_syscall *call)
{
    struct qemu_glDepthRangeArrayv *c = (struct qemu_glDepthRangeArrayv *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangeArrayv( c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glDepthRangeIndexed
{
    struct qemu_syscall super;
    uint64_t index;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangeIndexed( GLuint index, GLdouble n, GLdouble f )
{
    struct qemu_glDepthRangeIndexed call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEINDEXED);
    call.index = index;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangeIndexed(struct qemu_syscall *call)
{
    struct qemu_glDepthRangeIndexed *c = (struct qemu_glDepthRangeIndexed *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangeIndexed( c->index, c->n, c->f ));
}

#endif

struct qemu_glDepthRangeIndexeddNV
{
    struct qemu_syscall super;
    uint64_t index;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangeIndexeddNV( GLuint index, GLdouble n, GLdouble f )
{
    struct qemu_glDepthRangeIndexeddNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEINDEXEDDNV);
    call.index = index;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangeIndexeddNV(struct qemu_syscall *call)
{
    struct qemu_glDepthRangeIndexeddNV *c = (struct qemu_glDepthRangeIndexeddNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangeIndexeddNV( c->index, c->n, c->f ));
}

#endif

struct qemu_glDepthRangedNV
{
    struct qemu_syscall super;
    double zNear;
    double zFar;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangedNV( GLdouble zNear, GLdouble zFar )
{
    struct qemu_glDepthRangedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEDNV);
    call.zNear = zNear;
    call.zFar = zFar;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangedNV(struct qemu_syscall *call)
{
    struct qemu_glDepthRangedNV *c = (struct qemu_glDepthRangedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangedNV( c->zNear, c->zFar ));
}

#endif

struct qemu_glDepthRangef
{
    struct qemu_syscall super;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangef( GLfloat n, GLfloat f )
{
    struct qemu_glDepthRangef call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEF);
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangef(struct qemu_syscall *call)
{
    struct qemu_glDepthRangef *c = (struct qemu_glDepthRangef *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangef( c->n, c->f ));
}

#endif

struct qemu_glDepthRangefOES
{
    struct qemu_syscall super;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangefOES( GLclampf n, GLclampf f )
{
    struct qemu_glDepthRangefOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEFOES);
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangefOES(struct qemu_syscall *call)
{
    struct qemu_glDepthRangefOES *c = (struct qemu_glDepthRangefOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangefOES( c->n, c->f ));
}

#endif

struct qemu_glDepthRangexOES
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDepthRangexOES( GLfixed n, GLfixed f )
{
    struct qemu_glDepthRangexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDEPTHRANGEXOES);
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glDepthRangexOES(struct qemu_syscall *call)
{
    struct qemu_glDepthRangexOES *c = (struct qemu_glDepthRangexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glDepthRangexOES( c->n, c->f ));
}

#endif

struct qemu_glDetachObjectARB
{
    struct qemu_syscall super;
    uint64_t containerObj;
    uint64_t attachedObj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDetachObjectARB( GLhandleARB containerObj, GLhandleARB attachedObj )
{
    struct qemu_glDetachObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDETACHOBJECTARB);
    call.containerObj = containerObj;
    call.attachedObj = attachedObj;

    qemu_syscall(&call.super);
}

#else

void qemu_glDetachObjectARB(struct qemu_syscall *call)
{
    struct qemu_glDetachObjectARB *c = (struct qemu_glDetachObjectARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDetachObjectARB( c->containerObj, c->attachedObj ));
}

#endif

struct qemu_glDetachShader
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shader;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDetachShader( GLuint program, GLuint shader )
{
    struct qemu_glDetachShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDETACHSHADER);
    call.program = program;
    call.shader = shader;

    qemu_syscall(&call.super);
}

#else

void qemu_glDetachShader(struct qemu_syscall *call)
{
    struct qemu_glDetachShader *c = (struct qemu_glDetachShader *)call;
    WINE_FIXME("Unverified\n");
    (p_glDetachShader( c->program, c->shader ));
}

#endif

struct qemu_glDetailTexFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t n;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDetailTexFuncSGIS( GLenum target, GLsizei n, const GLfloat *points )
{
    struct qemu_glDetailTexFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDETAILTEXFUNCSGIS);
    call.target = target;
    call.n = n;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glDetailTexFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glDetailTexFuncSGIS *c = (struct qemu_glDetailTexFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glDetailTexFuncSGIS( c->target, c->n, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glDisableClientStateIndexedEXT
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableClientStateIndexedEXT( GLenum array, GLuint index )
{
    struct qemu_glDisableClientStateIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLECLIENTSTATEINDEXEDEXT);
    call.array = array;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableClientStateIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableClientStateIndexedEXT *c = (struct qemu_glDisableClientStateIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableClientStateIndexedEXT( c->array, c->index ));
}

#endif

struct qemu_glDisableClientStateiEXT
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableClientStateiEXT( GLenum array, GLuint index )
{
    struct qemu_glDisableClientStateiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLECLIENTSTATEIEXT);
    call.array = array;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableClientStateiEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableClientStateiEXT *c = (struct qemu_glDisableClientStateiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableClientStateiEXT( c->array, c->index ));
}

#endif

struct qemu_glDisableIndexedEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableIndexedEXT( GLenum target, GLuint index )
{
    struct qemu_glDisableIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEINDEXEDEXT);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableIndexedEXT *c = (struct qemu_glDisableIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableIndexedEXT( c->target, c->index ));
}

#endif

struct qemu_glDisableVariantClientStateEXT
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVariantClientStateEXT( GLuint id )
{
    struct qemu_glDisableVariantClientStateEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVARIANTCLIENTSTATEEXT);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVariantClientStateEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableVariantClientStateEXT *c = (struct qemu_glDisableVariantClientStateEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVariantClientStateEXT( c->id ));
}

#endif

struct qemu_glDisableVertexArrayAttrib
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexArrayAttrib( GLuint vaobj, GLuint index )
{
    struct qemu_glDisableVertexArrayAttrib call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXARRAYATTRIB);
    call.vaobj = vaobj;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexArrayAttrib(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexArrayAttrib *c = (struct qemu_glDisableVertexArrayAttrib *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexArrayAttrib( c->vaobj, c->index ));
}

#endif

struct qemu_glDisableVertexArrayAttribEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexArrayAttribEXT( GLuint vaobj, GLuint index )
{
    struct qemu_glDisableVertexArrayAttribEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXARRAYATTRIBEXT);
    call.vaobj = vaobj;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexArrayAttribEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexArrayAttribEXT *c = (struct qemu_glDisableVertexArrayAttribEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexArrayAttribEXT( c->vaobj, c->index ));
}

#endif

struct qemu_glDisableVertexArrayEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexArrayEXT( GLuint vaobj, GLenum array )
{
    struct qemu_glDisableVertexArrayEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXARRAYEXT);
    call.vaobj = vaobj;
    call.array = array;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexArrayEXT(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexArrayEXT *c = (struct qemu_glDisableVertexArrayEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexArrayEXT( c->vaobj, c->array ));
}

#endif

struct qemu_glDisableVertexAttribAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexAttribAPPLE( GLuint index, GLenum pname )
{
    struct qemu_glDisableVertexAttribAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXATTRIBAPPLE);
    call.index = index;
    call.pname = pname;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexAttribAPPLE(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexAttribAPPLE *c = (struct qemu_glDisableVertexAttribAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexAttribAPPLE( c->index, c->pname ));
}

#endif

struct qemu_glDisableVertexAttribArray
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexAttribArray( GLuint index )
{
    struct qemu_glDisableVertexAttribArray call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXATTRIBARRAY);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexAttribArray(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexAttribArray *c = (struct qemu_glDisableVertexAttribArray *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexAttribArray( c->index ));
}

#endif

struct qemu_glDisableVertexAttribArrayARB
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisableVertexAttribArrayARB( GLuint index )
{
    struct qemu_glDisableVertexAttribArrayARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEVERTEXATTRIBARRAYARB);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisableVertexAttribArrayARB(struct qemu_syscall *call)
{
    struct qemu_glDisableVertexAttribArrayARB *c = (struct qemu_glDisableVertexAttribArrayARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisableVertexAttribArrayARB( c->index ));
}

#endif

struct qemu_glDisablei
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDisablei( GLenum target, GLuint index )
{
    struct qemu_glDisablei call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISABLEI);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glDisablei(struct qemu_syscall *call)
{
    struct qemu_glDisablei *c = (struct qemu_glDisablei *)call;
    WINE_FIXME("Unverified\n");
    (p_glDisablei( c->target, c->index ));
}

#endif

struct qemu_glDispatchCompute
{
    struct qemu_syscall super;
    uint64_t num_groups_x;
    uint64_t num_groups_y;
    uint64_t num_groups_z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDispatchCompute( GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z )
{
    struct qemu_glDispatchCompute call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISPATCHCOMPUTE);
    call.num_groups_x = num_groups_x;
    call.num_groups_y = num_groups_y;
    call.num_groups_z = num_groups_z;

    qemu_syscall(&call.super);
}

#else

void qemu_glDispatchCompute(struct qemu_syscall *call)
{
    struct qemu_glDispatchCompute *c = (struct qemu_glDispatchCompute *)call;
    WINE_FIXME("Unverified\n");
    (p_glDispatchCompute( c->num_groups_x, c->num_groups_y, c->num_groups_z ));
}

#endif

struct qemu_glDispatchComputeGroupSizeARB
{
    struct qemu_syscall super;
    uint64_t num_groups_x;
    uint64_t num_groups_y;
    uint64_t num_groups_z;
    uint64_t group_size_x;
    uint64_t group_size_y;
    uint64_t group_size_z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDispatchComputeGroupSizeARB( GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z )
{
    struct qemu_glDispatchComputeGroupSizeARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISPATCHCOMPUTEGROUPSIZEARB);
    call.num_groups_x = num_groups_x;
    call.num_groups_y = num_groups_y;
    call.num_groups_z = num_groups_z;
    call.group_size_x = group_size_x;
    call.group_size_y = group_size_y;
    call.group_size_z = group_size_z;

    qemu_syscall(&call.super);
}

#else

void qemu_glDispatchComputeGroupSizeARB(struct qemu_syscall *call)
{
    struct qemu_glDispatchComputeGroupSizeARB *c = (struct qemu_glDispatchComputeGroupSizeARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDispatchComputeGroupSizeARB( c->num_groups_x, c->num_groups_y, c->num_groups_z, c->group_size_x, c->group_size_y, c->group_size_z ));
}

#endif

struct qemu_glDispatchComputeIndirect
{
    struct qemu_syscall super;
    uint64_t indirect;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDispatchComputeIndirect( GLintptr indirect )
{
    struct qemu_glDispatchComputeIndirect call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDISPATCHCOMPUTEINDIRECT);
    call.indirect = indirect;

    qemu_syscall(&call.super);
}

#else

void qemu_glDispatchComputeIndirect(struct qemu_syscall *call)
{
    struct qemu_glDispatchComputeIndirect *c = (struct qemu_glDispatchComputeIndirect *)call;
    WINE_FIXME("Unverified\n");
    (p_glDispatchComputeIndirect( c->indirect ));
}

#endif

struct qemu_glDrawArraysEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysEXT( GLenum mode, GLint first, GLsizei count )
{
    struct qemu_glDrawArraysEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSEXT);
    call.mode = mode;
    call.first = first;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysEXT(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysEXT *c = (struct qemu_glDrawArraysEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysEXT( c->mode, c->first, c->count ));
}

#endif

struct qemu_glDrawArraysIndirect
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysIndirect( GLenum mode, const void *indirect )
{
    struct qemu_glDrawArraysIndirect call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSINDIRECT);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysIndirect(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysIndirect *c = (struct qemu_glDrawArraysIndirect *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysIndirect( c->mode, QEMU_G2H(c->indirect) ));
}

#endif

struct qemu_glDrawArraysInstanced
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t instancecount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysInstanced( GLenum mode, GLint first, GLsizei count, GLsizei instancecount )
{
    struct qemu_glDrawArraysInstanced call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSINSTANCED);
    call.mode = mode;
    call.first = first;
    call.count = count;
    call.instancecount = instancecount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysInstanced(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysInstanced *c = (struct qemu_glDrawArraysInstanced *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysInstanced( c->mode, c->first, c->count, c->instancecount ));
}

#endif

struct qemu_glDrawArraysInstancedARB
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysInstancedARB( GLenum mode, GLint first, GLsizei count, GLsizei primcount )
{
    struct qemu_glDrawArraysInstancedARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSINSTANCEDARB);
    call.mode = mode;
    call.first = first;
    call.count = count;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysInstancedARB(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysInstancedARB *c = (struct qemu_glDrawArraysInstancedARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysInstancedARB( c->mode, c->first, c->count, c->primcount ));
}

#endif

struct qemu_glDrawArraysInstancedBaseInstance
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t instancecount;
    uint64_t baseinstance;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysInstancedBaseInstance( GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance )
{
    struct qemu_glDrawArraysInstancedBaseInstance call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSINSTANCEDBASEINSTANCE);
    call.mode = mode;
    call.first = first;
    call.count = count;
    call.instancecount = instancecount;
    call.baseinstance = baseinstance;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysInstancedBaseInstance(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysInstancedBaseInstance *c = (struct qemu_glDrawArraysInstancedBaseInstance *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysInstancedBaseInstance( c->mode, c->first, c->count, c->instancecount, c->baseinstance ));
}

#endif

struct qemu_glDrawArraysInstancedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t count;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawArraysInstancedEXT( GLenum mode, GLint start, GLsizei count, GLsizei primcount )
{
    struct qemu_glDrawArraysInstancedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWARRAYSINSTANCEDEXT);
    call.mode = mode;
    call.start = start;
    call.count = count;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawArraysInstancedEXT(struct qemu_syscall *call)
{
    struct qemu_glDrawArraysInstancedEXT *c = (struct qemu_glDrawArraysInstancedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawArraysInstancedEXT( c->mode, c->start, c->count, c->primcount ));
}

#endif

struct qemu_glDrawBufferRegion
{
    struct qemu_syscall super;
    uint64_t region;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t xDest;
    uint64_t yDest;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawBufferRegion( GLenum region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest )
{
    struct qemu_glDrawBufferRegion call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWBUFFERREGION);
    call.region = region;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.xDest = xDest;
    call.yDest = yDest;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawBufferRegion(struct qemu_syscall *call)
{
    struct qemu_glDrawBufferRegion *c = (struct qemu_glDrawBufferRegion *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawBufferRegion( c->region, c->x, c->y, c->width, c->height, c->xDest, c->yDest ));
}

#endif

struct qemu_glDrawBuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t bufs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawBuffers( GLsizei n, const GLenum *bufs )
{
    struct qemu_glDrawBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWBUFFERS);
    call.n = n;
    call.bufs = (ULONG_PTR)bufs;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawBuffers(struct qemu_syscall *call)
{
    struct qemu_glDrawBuffers *c = (struct qemu_glDrawBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawBuffers( c->n, QEMU_G2H(c->bufs) ));
}

#endif

struct qemu_glDrawBuffersARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t bufs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawBuffersARB( GLsizei n, const GLenum *bufs )
{
    struct qemu_glDrawBuffersARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWBUFFERSARB);
    call.n = n;
    call.bufs = (ULONG_PTR)bufs;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawBuffersARB(struct qemu_syscall *call)
{
    struct qemu_glDrawBuffersARB *c = (struct qemu_glDrawBuffersARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawBuffersARB( c->n, QEMU_G2H(c->bufs) ));
}

#endif

struct qemu_glDrawBuffersATI
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t bufs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawBuffersATI( GLsizei n, const GLenum *bufs )
{
    struct qemu_glDrawBuffersATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWBUFFERSATI);
    call.n = n;
    call.bufs = (ULONG_PTR)bufs;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawBuffersATI(struct qemu_syscall *call)
{
    struct qemu_glDrawBuffersATI *c = (struct qemu_glDrawBuffersATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawBuffersATI( c->n, QEMU_G2H(c->bufs) ));
}

#endif

struct qemu_glDrawCommandsAddressNV
{
    struct qemu_syscall super;
    uint64_t primitiveMode;
    uint64_t indirects;
    uint64_t sizes;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawCommandsAddressNV( GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count )
{
    struct qemu_glDrawCommandsAddressNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWCOMMANDSADDRESSNV);
    call.primitiveMode = primitiveMode;
    call.indirects = (ULONG_PTR)indirects;
    call.sizes = (ULONG_PTR)sizes;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawCommandsAddressNV(struct qemu_syscall *call)
{
    struct qemu_glDrawCommandsAddressNV *c = (struct qemu_glDrawCommandsAddressNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawCommandsAddressNV( c->primitiveMode, QEMU_G2H(c->indirects), QEMU_G2H(c->sizes), c->count ));
}

#endif

struct qemu_glDrawCommandsNV
{
    struct qemu_syscall super;
    uint64_t primitiveMode;
    uint64_t buffer;
    uint64_t indirects;
    uint64_t sizes;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawCommandsNV( GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count )
{
    struct qemu_glDrawCommandsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWCOMMANDSNV);
    call.primitiveMode = primitiveMode;
    call.buffer = buffer;
    call.indirects = (ULONG_PTR)indirects;
    call.sizes = (ULONG_PTR)sizes;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawCommandsNV(struct qemu_syscall *call)
{
    struct qemu_glDrawCommandsNV *c = (struct qemu_glDrawCommandsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawCommandsNV( c->primitiveMode, c->buffer, QEMU_G2H(c->indirects), QEMU_G2H(c->sizes), c->count ));
}

#endif

struct qemu_glDrawCommandsStatesAddressNV
{
    struct qemu_syscall super;
    uint64_t indirects;
    uint64_t sizes;
    uint64_t states;
    uint64_t fbos;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawCommandsStatesAddressNV( const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count )
{
    struct qemu_glDrawCommandsStatesAddressNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWCOMMANDSSTATESADDRESSNV);
    call.indirects = (ULONG_PTR)indirects;
    call.sizes = (ULONG_PTR)sizes;
    call.states = (ULONG_PTR)states;
    call.fbos = (ULONG_PTR)fbos;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawCommandsStatesAddressNV(struct qemu_syscall *call)
{
    struct qemu_glDrawCommandsStatesAddressNV *c = (struct qemu_glDrawCommandsStatesAddressNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawCommandsStatesAddressNV( QEMU_G2H(c->indirects), QEMU_G2H(c->sizes), QEMU_G2H(c->states), QEMU_G2H(c->fbos), c->count ));
}

#endif

struct qemu_glDrawCommandsStatesNV
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t indirects;
    uint64_t sizes;
    uint64_t states;
    uint64_t fbos;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawCommandsStatesNV( GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count )
{
    struct qemu_glDrawCommandsStatesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWCOMMANDSSTATESNV);
    call.buffer = buffer;
    call.indirects = (ULONG_PTR)indirects;
    call.sizes = (ULONG_PTR)sizes;
    call.states = (ULONG_PTR)states;
    call.fbos = (ULONG_PTR)fbos;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawCommandsStatesNV(struct qemu_syscall *call)
{
    struct qemu_glDrawCommandsStatesNV *c = (struct qemu_glDrawCommandsStatesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawCommandsStatesNV( c->buffer, QEMU_G2H(c->indirects), QEMU_G2H(c->sizes), QEMU_G2H(c->states), QEMU_G2H(c->fbos), c->count ));
}

#endif

struct qemu_glDrawElementArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementArrayAPPLE( GLenum mode, GLint first, GLsizei count )
{
    struct qemu_glDrawElementArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTARRAYAPPLE);
    call.mode = mode;
    call.first = first;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glDrawElementArrayAPPLE *c = (struct qemu_glDrawElementArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementArrayAPPLE( c->mode, c->first, c->count ));
}

#endif

struct qemu_glDrawElementArrayATI
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementArrayATI( GLenum mode, GLsizei count )
{
    struct qemu_glDrawElementArrayATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTARRAYATI);
    call.mode = mode;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementArrayATI(struct qemu_syscall *call)
{
    struct qemu_glDrawElementArrayATI *c = (struct qemu_glDrawElementArrayATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementArrayATI( c->mode, c->count ));
}

#endif

struct qemu_glDrawElementsBaseVertex
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t basevertex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsBaseVertex( GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex )
{
    struct qemu_glDrawElementsBaseVertex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSBASEVERTEX);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.basevertex = basevertex;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsBaseVertex(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsBaseVertex *c = (struct qemu_glDrawElementsBaseVertex *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsBaseVertex( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->basevertex ));
}

#endif

struct qemu_glDrawElementsIndirect
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsIndirect( GLenum mode, GLenum type, const void *indirect )
{
    struct qemu_glDrawElementsIndirect call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINDIRECT);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsIndirect(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsIndirect *c = (struct qemu_glDrawElementsIndirect *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsIndirect( c->mode, c->type, QEMU_G2H(c->indirect) ));
}

#endif

struct qemu_glDrawElementsInstanced
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t instancecount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstanced( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount )
{
    struct qemu_glDrawElementsInstanced call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCED);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.instancecount = instancecount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstanced(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstanced *c = (struct qemu_glDrawElementsInstanced *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstanced( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->instancecount ));
}

#endif

struct qemu_glDrawElementsInstancedARB
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstancedARB( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount )
{
    struct qemu_glDrawElementsInstancedARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCEDARB);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstancedARB(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstancedARB *c = (struct qemu_glDrawElementsInstancedARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstancedARB( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->primcount ));
}

#endif

struct qemu_glDrawElementsInstancedBaseInstance
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t instancecount;
    uint64_t baseinstance;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstancedBaseInstance( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance )
{
    struct qemu_glDrawElementsInstancedBaseInstance call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCEDBASEINSTANCE);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.instancecount = instancecount;
    call.baseinstance = baseinstance;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstancedBaseInstance(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstancedBaseInstance *c = (struct qemu_glDrawElementsInstancedBaseInstance *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstancedBaseInstance( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->instancecount, c->baseinstance ));
}

#endif

struct qemu_glDrawElementsInstancedBaseVertex
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t instancecount;
    uint64_t basevertex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstancedBaseVertex( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex )
{
    struct qemu_glDrawElementsInstancedBaseVertex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCEDBASEVERTEX);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.instancecount = instancecount;
    call.basevertex = basevertex;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstancedBaseVertex(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstancedBaseVertex *c = (struct qemu_glDrawElementsInstancedBaseVertex *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstancedBaseVertex( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->instancecount, c->basevertex ));
}

#endif

struct qemu_glDrawElementsInstancedBaseVertexBaseInstance
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t instancecount;
    uint64_t basevertex;
    uint64_t baseinstance;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstancedBaseVertexBaseInstance( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance )
{
    struct qemu_glDrawElementsInstancedBaseVertexBaseInstance call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.instancecount = instancecount;
    call.basevertex = basevertex;
    call.baseinstance = baseinstance;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstancedBaseVertexBaseInstance(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstancedBaseVertexBaseInstance *c = (struct qemu_glDrawElementsInstancedBaseVertexBaseInstance *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstancedBaseVertexBaseInstance( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->instancecount, c->basevertex, c->baseinstance ));
}

#endif

struct qemu_glDrawElementsInstancedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawElementsInstancedEXT( GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount )
{
    struct qemu_glDrawElementsInstancedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWELEMENTSINSTANCEDEXT);
    call.mode = mode;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawElementsInstancedEXT(struct qemu_syscall *call)
{
    struct qemu_glDrawElementsInstancedEXT *c = (struct qemu_glDrawElementsInstancedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawElementsInstancedEXT( c->mode, c->count, c->type, QEMU_G2H(c->indices), c->primcount ));
}

#endif

struct qemu_glDrawMeshArraysSUN
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawMeshArraysSUN( GLenum mode, GLint first, GLsizei count, GLsizei width )
{
    struct qemu_glDrawMeshArraysSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWMESHARRAYSSUN);
    call.mode = mode;
    call.first = first;
    call.count = count;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawMeshArraysSUN(struct qemu_syscall *call)
{
    struct qemu_glDrawMeshArraysSUN *c = (struct qemu_glDrawMeshArraysSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawMeshArraysSUN( c->mode, c->first, c->count, c->width ));
}

#endif

struct qemu_glDrawMeshTasksIndirectNV
{
    struct qemu_syscall super;
    uint64_t indirect;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawMeshTasksIndirectNV( GLintptr indirect )
{
    struct qemu_glDrawMeshTasksIndirectNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWMESHTASKSINDIRECTNV);
    call.indirect = indirect;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawMeshTasksIndirectNV(struct qemu_syscall *call)
{
    struct qemu_glDrawMeshTasksIndirectNV *c = (struct qemu_glDrawMeshTasksIndirectNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawMeshTasksIndirectNV( c->indirect ));
}

#endif

struct qemu_glDrawMeshTasksNV
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawMeshTasksNV( GLuint first, GLuint count )
{
    struct qemu_glDrawMeshTasksNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWMESHTASKSNV);
    call.first = first;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawMeshTasksNV(struct qemu_syscall *call)
{
    struct qemu_glDrawMeshTasksNV *c = (struct qemu_glDrawMeshTasksNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawMeshTasksNV( c->first, c->count ));
}

#endif

struct qemu_glDrawRangeElementArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t first;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawRangeElementArrayAPPLE( GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count )
{
    struct qemu_glDrawRangeElementArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWRANGEELEMENTARRAYAPPLE);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.first = first;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawRangeElementArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glDrawRangeElementArrayAPPLE *c = (struct qemu_glDrawRangeElementArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawRangeElementArrayAPPLE( c->mode, c->start, c->end, c->first, c->count ));
}

#endif

struct qemu_glDrawRangeElementArrayATI
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawRangeElementArrayATI( GLenum mode, GLuint start, GLuint end, GLsizei count )
{
    struct qemu_glDrawRangeElementArrayATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWRANGEELEMENTARRAYATI);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawRangeElementArrayATI(struct qemu_syscall *call)
{
    struct qemu_glDrawRangeElementArrayATI *c = (struct qemu_glDrawRangeElementArrayATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawRangeElementArrayATI( c->mode, c->start, c->end, c->count ));
}

#endif

struct qemu_glDrawRangeElements
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawRangeElements( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices )
{
    struct qemu_glDrawRangeElements call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWRANGEELEMENTS);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawRangeElements(struct qemu_syscall *call)
{
    struct qemu_glDrawRangeElements *c = (struct qemu_glDrawRangeElements *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawRangeElements( c->mode, c->start, c->end, c->count, c->type, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glDrawRangeElementsBaseVertex
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t basevertex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawRangeElementsBaseVertex( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex )
{
    struct qemu_glDrawRangeElementsBaseVertex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWRANGEELEMENTSBASEVERTEX);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.basevertex = basevertex;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawRangeElementsBaseVertex(struct qemu_syscall *call)
{
    struct qemu_glDrawRangeElementsBaseVertex *c = (struct qemu_glDrawRangeElementsBaseVertex *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawRangeElementsBaseVertex( c->mode, c->start, c->end, c->count, c->type, QEMU_G2H(c->indices), c->basevertex ));
}

#endif

struct qemu_glDrawRangeElementsEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawRangeElementsEXT( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices )
{
    struct qemu_glDrawRangeElementsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWRANGEELEMENTSEXT);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.count = count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawRangeElementsEXT(struct qemu_syscall *call)
{
    struct qemu_glDrawRangeElementsEXT *c = (struct qemu_glDrawRangeElementsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawRangeElementsEXT( c->mode, c->start, c->end, c->count, c->type, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glDrawTextureNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t sampler;
    double x0;
    double y0;
    double x1;
    double y1;
    double z;
    double s0;
    double t0;
    double s1;
    double t1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTextureNV( GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1 )
{
    struct qemu_glDrawTextureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTEXTURENV);
    call.texture = texture;
    call.sampler = sampler;
    call.x0 = x0;
    call.y0 = y0;
    call.x1 = x1;
    call.y1 = y1;
    call.z = z;
    call.s0 = s0;
    call.t0 = t0;
    call.s1 = s1;
    call.t1 = t1;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTextureNV(struct qemu_syscall *call)
{
    struct qemu_glDrawTextureNV *c = (struct qemu_glDrawTextureNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTextureNV( c->texture, c->sampler, c->x0, c->y0, c->x1, c->y1, c->z, c->s0, c->t0, c->s1, c->t1 ));
}

#endif

struct qemu_glDrawTransformFeedback
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTransformFeedback( GLenum mode, GLuint id )
{
    struct qemu_glDrawTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTRANSFORMFEEDBACK);
    call.mode = mode;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glDrawTransformFeedback *c = (struct qemu_glDrawTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTransformFeedback( c->mode, c->id ));
}

#endif

struct qemu_glDrawTransformFeedbackInstanced
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t id;
    uint64_t instancecount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTransformFeedbackInstanced( GLenum mode, GLuint id, GLsizei instancecount )
{
    struct qemu_glDrawTransformFeedbackInstanced call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTRANSFORMFEEDBACKINSTANCED);
    call.mode = mode;
    call.id = id;
    call.instancecount = instancecount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTransformFeedbackInstanced(struct qemu_syscall *call)
{
    struct qemu_glDrawTransformFeedbackInstanced *c = (struct qemu_glDrawTransformFeedbackInstanced *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTransformFeedbackInstanced( c->mode, c->id, c->instancecount ));
}

#endif

struct qemu_glDrawTransformFeedbackNV
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTransformFeedbackNV( GLenum mode, GLuint id )
{
    struct qemu_glDrawTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTRANSFORMFEEDBACKNV);
    call.mode = mode;
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glDrawTransformFeedbackNV *c = (struct qemu_glDrawTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTransformFeedbackNV( c->mode, c->id ));
}

#endif

struct qemu_glDrawTransformFeedbackStream
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t id;
    uint64_t stream;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTransformFeedbackStream( GLenum mode, GLuint id, GLuint stream )
{
    struct qemu_glDrawTransformFeedbackStream call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTRANSFORMFEEDBACKSTREAM);
    call.mode = mode;
    call.id = id;
    call.stream = stream;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTransformFeedbackStream(struct qemu_syscall *call)
{
    struct qemu_glDrawTransformFeedbackStream *c = (struct qemu_glDrawTransformFeedbackStream *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTransformFeedbackStream( c->mode, c->id, c->stream ));
}

#endif

struct qemu_glDrawTransformFeedbackStreamInstanced
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t id;
    uint64_t stream;
    uint64_t instancecount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawTransformFeedbackStreamInstanced( GLenum mode, GLuint id, GLuint stream, GLsizei instancecount )
{
    struct qemu_glDrawTransformFeedbackStreamInstanced call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED);
    call.mode = mode;
    call.id = id;
    call.stream = stream;
    call.instancecount = instancecount;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawTransformFeedbackStreamInstanced(struct qemu_syscall *call)
{
    struct qemu_glDrawTransformFeedbackStreamInstanced *c = (struct qemu_glDrawTransformFeedbackStreamInstanced *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawTransformFeedbackStreamInstanced( c->mode, c->id, c->stream, c->instancecount ));
}

#endif

struct qemu_glDrawVkImageNV
{
    struct qemu_syscall super;
    uint64_t vkImage;
    uint64_t sampler;
    double x0;
    double y0;
    double x1;
    double y1;
    double z;
    double s0;
    double t0;
    double s1;
    double t1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glDrawVkImageNV( GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1 )
{
    struct qemu_glDrawVkImageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLDRAWVKIMAGENV);
    call.vkImage = vkImage;
    call.sampler = sampler;
    call.x0 = x0;
    call.y0 = y0;
    call.x1 = x1;
    call.y1 = y1;
    call.z = z;
    call.s0 = s0;
    call.t0 = t0;
    call.s1 = s1;
    call.t1 = t1;

    qemu_syscall(&call.super);
}

#else

void qemu_glDrawVkImageNV(struct qemu_syscall *call)
{
    struct qemu_glDrawVkImageNV *c = (struct qemu_glDrawVkImageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glDrawVkImageNV( c->vkImage, c->sampler, c->x0, c->y0, c->x1, c->y1, c->z, c->s0, c->t0, c->s1, c->t1 ));
}

#endif

struct qemu_glEGLImageTargetTexStorageEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t image;
    uint64_t attrib_list;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEGLImageTargetTexStorageEXT( GLenum target, GLeglImageOES image, const GLint* attrib_list )
{
    struct qemu_glEGLImageTargetTexStorageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEGLIMAGETARGETTEXSTORAGEEXT);
    call.target = target;
    call.image = (ULONG_PTR)image;
    call.attrib_list = (ULONG_PTR)attrib_list;

    qemu_syscall(&call.super);
}

#else

void qemu_glEGLImageTargetTexStorageEXT(struct qemu_syscall *call)
{
    struct qemu_glEGLImageTargetTexStorageEXT *c = (struct qemu_glEGLImageTargetTexStorageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEGLImageTargetTexStorageEXT( c->target, QEMU_G2H(c->image), QEMU_G2H(c->attrib_list) ));
}

#endif

struct qemu_glEGLImageTargetTextureStorageEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t image;
    uint64_t attrib_list;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEGLImageTargetTextureStorageEXT( GLuint texture, GLeglImageOES image, const GLint* attrib_list )
{
    struct qemu_glEGLImageTargetTextureStorageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEGLIMAGETARGETTEXTURESTORAGEEXT);
    call.texture = texture;
    call.image = (ULONG_PTR)image;
    call.attrib_list = (ULONG_PTR)attrib_list;

    qemu_syscall(&call.super);
}

#else

void qemu_glEGLImageTargetTextureStorageEXT(struct qemu_syscall *call)
{
    struct qemu_glEGLImageTargetTextureStorageEXT *c = (struct qemu_glEGLImageTargetTextureStorageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEGLImageTargetTextureStorageEXT( c->texture, QEMU_G2H(c->image), QEMU_G2H(c->attrib_list) ));
}

#endif

struct qemu_glEdgeFlagFormatNV
{
    struct qemu_syscall super;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEdgeFlagFormatNV( GLsizei stride )
{
    struct qemu_glEdgeFlagFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEDGEFLAGFORMATNV);
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glEdgeFlagFormatNV(struct qemu_syscall *call)
{
    struct qemu_glEdgeFlagFormatNV *c = (struct qemu_glEdgeFlagFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEdgeFlagFormatNV( c->stride ));
}

#endif

struct qemu_glEdgeFlagPointerEXT
{
    struct qemu_syscall super;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEdgeFlagPointerEXT( GLsizei stride, GLsizei count, const GLboolean *pointer )
{
    struct qemu_glEdgeFlagPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEDGEFLAGPOINTEREXT);
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glEdgeFlagPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glEdgeFlagPointerEXT *c = (struct qemu_glEdgeFlagPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEdgeFlagPointerEXT( c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glEdgeFlagPointerListIBM
{
    struct qemu_syscall super;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEdgeFlagPointerListIBM( GLint stride, const GLboolean **pointer, GLint ptrstride )
{
    struct qemu_glEdgeFlagPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEDGEFLAGPOINTERLISTIBM);
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glEdgeFlagPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glEdgeFlagPointerListIBM *c = (struct qemu_glEdgeFlagPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glEdgeFlagPointerListIBM( c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glElementPointerAPPLE
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glElementPointerAPPLE( GLenum type, const void *pointer )
{
    struct qemu_glElementPointerAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLELEMENTPOINTERAPPLE);
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glElementPointerAPPLE(struct qemu_syscall *call)
{
    struct qemu_glElementPointerAPPLE *c = (struct qemu_glElementPointerAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glElementPointerAPPLE( c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glElementPointerATI
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glElementPointerATI( GLenum type, const void *pointer )
{
    struct qemu_glElementPointerATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLELEMENTPOINTERATI);
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glElementPointerATI(struct qemu_syscall *call)
{
    struct qemu_glElementPointerATI *c = (struct qemu_glElementPointerATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glElementPointerATI( c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glEnableClientStateIndexedEXT
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableClientStateIndexedEXT( GLenum array, GLuint index )
{
    struct qemu_glEnableClientStateIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLECLIENTSTATEINDEXEDEXT);
    call.array = array;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableClientStateIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableClientStateIndexedEXT *c = (struct qemu_glEnableClientStateIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableClientStateIndexedEXT( c->array, c->index ));
}

#endif

struct qemu_glEnableClientStateiEXT
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableClientStateiEXT( GLenum array, GLuint index )
{
    struct qemu_glEnableClientStateiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLECLIENTSTATEIEXT);
    call.array = array;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableClientStateiEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableClientStateiEXT *c = (struct qemu_glEnableClientStateiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableClientStateiEXT( c->array, c->index ));
}

#endif

struct qemu_glEnableIndexedEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableIndexedEXT( GLenum target, GLuint index )
{
    struct qemu_glEnableIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEINDEXEDEXT);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableIndexedEXT *c = (struct qemu_glEnableIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableIndexedEXT( c->target, c->index ));
}

#endif

struct qemu_glEnableVariantClientStateEXT
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVariantClientStateEXT( GLuint id )
{
    struct qemu_glEnableVariantClientStateEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVARIANTCLIENTSTATEEXT);
    call.id = id;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVariantClientStateEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableVariantClientStateEXT *c = (struct qemu_glEnableVariantClientStateEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVariantClientStateEXT( c->id ));
}

#endif

struct qemu_glEnableVertexArrayAttrib
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexArrayAttrib( GLuint vaobj, GLuint index )
{
    struct qemu_glEnableVertexArrayAttrib call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXARRAYATTRIB);
    call.vaobj = vaobj;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexArrayAttrib(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexArrayAttrib *c = (struct qemu_glEnableVertexArrayAttrib *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexArrayAttrib( c->vaobj, c->index ));
}

#endif

struct qemu_glEnableVertexArrayAttribEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexArrayAttribEXT( GLuint vaobj, GLuint index )
{
    struct qemu_glEnableVertexArrayAttribEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXARRAYATTRIBEXT);
    call.vaobj = vaobj;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexArrayAttribEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexArrayAttribEXT *c = (struct qemu_glEnableVertexArrayAttribEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexArrayAttribEXT( c->vaobj, c->index ));
}

#endif

struct qemu_glEnableVertexArrayEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexArrayEXT( GLuint vaobj, GLenum array )
{
    struct qemu_glEnableVertexArrayEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXARRAYEXT);
    call.vaobj = vaobj;
    call.array = array;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexArrayEXT(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexArrayEXT *c = (struct qemu_glEnableVertexArrayEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexArrayEXT( c->vaobj, c->array ));
}

#endif

struct qemu_glEnableVertexAttribAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexAttribAPPLE( GLuint index, GLenum pname )
{
    struct qemu_glEnableVertexAttribAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXATTRIBAPPLE);
    call.index = index;
    call.pname = pname;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexAttribAPPLE(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexAttribAPPLE *c = (struct qemu_glEnableVertexAttribAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexAttribAPPLE( c->index, c->pname ));
}

#endif

struct qemu_glEnableVertexAttribArray
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexAttribArray( GLuint index )
{
    struct qemu_glEnableVertexAttribArray call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXATTRIBARRAY);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexAttribArray(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexAttribArray *c = (struct qemu_glEnableVertexAttribArray *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexAttribArray( c->index ));
}

#endif

struct qemu_glEnableVertexAttribArrayARB
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnableVertexAttribArrayARB( GLuint index )
{
    struct qemu_glEnableVertexAttribArrayARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEVERTEXATTRIBARRAYARB);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnableVertexAttribArrayARB(struct qemu_syscall *call)
{
    struct qemu_glEnableVertexAttribArrayARB *c = (struct qemu_glEnableVertexAttribArrayARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnableVertexAttribArrayARB( c->index ));
}

#endif

struct qemu_glEnablei
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEnablei( GLenum target, GLuint index )
{
    struct qemu_glEnablei call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENABLEI);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEnablei(struct qemu_syscall *call)
{
    struct qemu_glEnablei *c = (struct qemu_glEnablei *)call;
    WINE_FIXME("Unverified\n");
    (p_glEnablei( c->target, c->index ));
}

#endif

struct qemu_glEndConditionalRender
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndConditionalRender(void)
{
    struct qemu_glEndConditionalRender call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDCONDITIONALRENDER);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndConditionalRender(struct qemu_syscall *call)
{
    struct qemu_glEndConditionalRender *c = (struct qemu_glEndConditionalRender *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndConditionalRender());
}

#endif

struct qemu_glEndConditionalRenderNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndConditionalRenderNV(void)
{
    struct qemu_glEndConditionalRenderNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDCONDITIONALRENDERNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndConditionalRenderNV(struct qemu_syscall *call)
{
    struct qemu_glEndConditionalRenderNV *c = (struct qemu_glEndConditionalRenderNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndConditionalRenderNV());
}

#endif

struct qemu_glEndConditionalRenderNVX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndConditionalRenderNVX(void)
{
    struct qemu_glEndConditionalRenderNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDCONDITIONALRENDERNVX);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndConditionalRenderNVX(struct qemu_syscall *call)
{
    struct qemu_glEndConditionalRenderNVX *c = (struct qemu_glEndConditionalRenderNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndConditionalRenderNVX());
}

#endif

struct qemu_glEndFragmentShaderATI
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndFragmentShaderATI(void)
{
    struct qemu_glEndFragmentShaderATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDFRAGMENTSHADERATI);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndFragmentShaderATI(struct qemu_syscall *call)
{
    struct qemu_glEndFragmentShaderATI *c = (struct qemu_glEndFragmentShaderATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndFragmentShaderATI());
}

#endif

struct qemu_glEndOcclusionQueryNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndOcclusionQueryNV(void)
{
    struct qemu_glEndOcclusionQueryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDOCCLUSIONQUERYNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndOcclusionQueryNV(struct qemu_syscall *call)
{
    struct qemu_glEndOcclusionQueryNV *c = (struct qemu_glEndOcclusionQueryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndOcclusionQueryNV());
}

#endif

struct qemu_glEndPerfMonitorAMD
{
    struct qemu_syscall super;
    uint64_t monitor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndPerfMonitorAMD( GLuint monitor )
{
    struct qemu_glEndPerfMonitorAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDPERFMONITORAMD);
    call.monitor = monitor;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndPerfMonitorAMD(struct qemu_syscall *call)
{
    struct qemu_glEndPerfMonitorAMD *c = (struct qemu_glEndPerfMonitorAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndPerfMonitorAMD( c->monitor ));
}

#endif

struct qemu_glEndPerfQueryINTEL
{
    struct qemu_syscall super;
    uint64_t queryHandle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndPerfQueryINTEL( GLuint queryHandle )
{
    struct qemu_glEndPerfQueryINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDPERFQUERYINTEL);
    call.queryHandle = queryHandle;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndPerfQueryINTEL(struct qemu_syscall *call)
{
    struct qemu_glEndPerfQueryINTEL *c = (struct qemu_glEndPerfQueryINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndPerfQueryINTEL( c->queryHandle ));
}

#endif

struct qemu_glEndQuery
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndQuery( GLenum target )
{
    struct qemu_glEndQuery call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDQUERY);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndQuery(struct qemu_syscall *call)
{
    struct qemu_glEndQuery *c = (struct qemu_glEndQuery *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndQuery( c->target ));
}

#endif

struct qemu_glEndQueryARB
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndQueryARB( GLenum target )
{
    struct qemu_glEndQueryARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDQUERYARB);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndQueryARB(struct qemu_syscall *call)
{
    struct qemu_glEndQueryARB *c = (struct qemu_glEndQueryARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndQueryARB( c->target ));
}

#endif

struct qemu_glEndQueryIndexed
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndQueryIndexed( GLenum target, GLuint index )
{
    struct qemu_glEndQueryIndexed call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDQUERYINDEXED);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndQueryIndexed(struct qemu_syscall *call)
{
    struct qemu_glEndQueryIndexed *c = (struct qemu_glEndQueryIndexed *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndQueryIndexed( c->target, c->index ));
}

#endif

struct qemu_glEndTransformFeedback
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndTransformFeedback(void)
{
    struct qemu_glEndTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDTRANSFORMFEEDBACK);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glEndTransformFeedback *c = (struct qemu_glEndTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndTransformFeedback());
}

#endif

struct qemu_glEndTransformFeedbackEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndTransformFeedbackEXT(void)
{
    struct qemu_glEndTransformFeedbackEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDTRANSFORMFEEDBACKEXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndTransformFeedbackEXT(struct qemu_syscall *call)
{
    struct qemu_glEndTransformFeedbackEXT *c = (struct qemu_glEndTransformFeedbackEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndTransformFeedbackEXT());
}

#endif

struct qemu_glEndTransformFeedbackNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndTransformFeedbackNV(void)
{
    struct qemu_glEndTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDTRANSFORMFEEDBACKNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glEndTransformFeedbackNV *c = (struct qemu_glEndTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndTransformFeedbackNV());
}

#endif

struct qemu_glEndVertexShaderEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndVertexShaderEXT(void)
{
    struct qemu_glEndVertexShaderEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDVERTEXSHADEREXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glEndVertexShaderEXT(struct qemu_syscall *call)
{
    struct qemu_glEndVertexShaderEXT *c = (struct qemu_glEndVertexShaderEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndVertexShaderEXT());
}

#endif

struct qemu_glEndVideoCaptureNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEndVideoCaptureNV( GLuint video_capture_slot )
{
    struct qemu_glEndVideoCaptureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLENDVIDEOCAPTURENV);
    call.video_capture_slot = video_capture_slot;

    qemu_syscall(&call.super);
}

#else

void qemu_glEndVideoCaptureNV(struct qemu_syscall *call)
{
    struct qemu_glEndVideoCaptureNV *c = (struct qemu_glEndVideoCaptureNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEndVideoCaptureNV( c->video_capture_slot ));
}

#endif

struct qemu_glEvalCoord1xOES
{
    struct qemu_syscall super;
    uint64_t u;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvalCoord1xOES( GLfixed u )
{
    struct qemu_glEvalCoord1xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALCOORD1XOES);
    call.u = u;

    qemu_syscall(&call.super);
}

#else

void qemu_glEvalCoord1xOES(struct qemu_syscall *call)
{
    struct qemu_glEvalCoord1xOES *c = (struct qemu_glEvalCoord1xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvalCoord1xOES( c->u ));
}

#endif

struct qemu_glEvalCoord1xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvalCoord1xvOES( const GLfixed *coords )
{
    struct qemu_glEvalCoord1xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALCOORD1XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glEvalCoord1xvOES(struct qemu_syscall *call)
{
    struct qemu_glEvalCoord1xvOES *c = (struct qemu_glEvalCoord1xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvalCoord1xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glEvalCoord2xOES
{
    struct qemu_syscall super;
    uint64_t u;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvalCoord2xOES( GLfixed u, GLfixed v )
{
    struct qemu_glEvalCoord2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALCOORD2XOES);
    call.u = u;
    call.v = v;

    qemu_syscall(&call.super);
}

#else

void qemu_glEvalCoord2xOES(struct qemu_syscall *call)
{
    struct qemu_glEvalCoord2xOES *c = (struct qemu_glEvalCoord2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvalCoord2xOES( c->u, c->v ));
}

#endif

struct qemu_glEvalCoord2xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvalCoord2xvOES( const GLfixed *coords )
{
    struct qemu_glEvalCoord2xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALCOORD2XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glEvalCoord2xvOES(struct qemu_syscall *call)
{
    struct qemu_glEvalCoord2xvOES *c = (struct qemu_glEvalCoord2xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvalCoord2xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glEvalMapsNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvalMapsNV( GLenum target, GLenum mode )
{
    struct qemu_glEvalMapsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALMAPSNV);
    call.target = target;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glEvalMapsNV(struct qemu_syscall *call)
{
    struct qemu_glEvalMapsNV *c = (struct qemu_glEvalMapsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvalMapsNV( c->target, c->mode ));
}

#endif

struct qemu_glEvaluateDepthValuesARB
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glEvaluateDepthValuesARB(void)
{
    struct qemu_glEvaluateDepthValuesARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEVALUATEDEPTHVALUESARB);

    qemu_syscall(&call.super);
}

#else

void qemu_glEvaluateDepthValuesARB(struct qemu_syscall *call)
{
    struct qemu_glEvaluateDepthValuesARB *c = (struct qemu_glEvaluateDepthValuesARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glEvaluateDepthValuesARB());
}

#endif

struct qemu_glExecuteProgramNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glExecuteProgramNV( GLenum target, GLuint id, const GLfloat *params )
{
    struct qemu_glExecuteProgramNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEXECUTEPROGRAMNV);
    call.target = target;
    call.id = id;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glExecuteProgramNV(struct qemu_syscall *call)
{
    struct qemu_glExecuteProgramNV *c = (struct qemu_glExecuteProgramNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glExecuteProgramNV( c->target, c->id, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glExtractComponentEXT
{
    struct qemu_syscall super;
    uint64_t res;
    uint64_t src;
    uint64_t num;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glExtractComponentEXT( GLuint res, GLuint src, GLuint num )
{
    struct qemu_glExtractComponentEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLEXTRACTCOMPONENTEXT);
    call.res = res;
    call.src = src;
    call.num = num;

    qemu_syscall(&call.super);
}

#else

void qemu_glExtractComponentEXT(struct qemu_syscall *call)
{
    struct qemu_glExtractComponentEXT *c = (struct qemu_glExtractComponentEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glExtractComponentEXT( c->res, c->src, c->num ));
}

#endif

struct qemu_glFeedbackBufferxOES
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t type;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFeedbackBufferxOES( GLsizei n, GLenum type, const GLfixed *buffer )
{
    struct qemu_glFeedbackBufferxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFEEDBACKBUFFERXOES);
    call.n = n;
    call.type = type;
    call.buffer = (ULONG_PTR)buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFeedbackBufferxOES(struct qemu_syscall *call)
{
    struct qemu_glFeedbackBufferxOES *c = (struct qemu_glFeedbackBufferxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glFeedbackBufferxOES( c->n, c->type, QEMU_G2H(c->buffer) ));
}

#endif

struct qemu_glFenceSync
{
    struct qemu_syscall super;
    uint64_t condition;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

GLsync WINAPI glFenceSync( GLenum condition, GLbitfield flags )
{
    struct qemu_glFenceSync call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFENCESYNC);
    call.condition = condition;
    call.flags = flags;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glFenceSync(struct qemu_syscall *call)
{
    struct qemu_glFenceSync *c = (struct qemu_glFenceSync *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glFenceSync( c->condition, c->flags ));
}

#endif

struct qemu_glFinalCombinerInputNV
{
    struct qemu_syscall super;
    uint64_t variable;
    uint64_t input;
    uint64_t mapping;
    uint64_t componentUsage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFinalCombinerInputNV( GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
    struct qemu_glFinalCombinerInputNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINALCOMBINERINPUTNV);
    call.variable = variable;
    call.input = input;
    call.mapping = mapping;
    call.componentUsage = componentUsage;

    qemu_syscall(&call.super);
}

#else

void qemu_glFinalCombinerInputNV(struct qemu_syscall *call)
{
    struct qemu_glFinalCombinerInputNV *c = (struct qemu_glFinalCombinerInputNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFinalCombinerInputNV( c->variable, c->input, c->mapping, c->componentUsage ));
}

#endif

struct qemu_glFinishAsyncSGIX
{
    struct qemu_syscall super;
    uint64_t markerp;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glFinishAsyncSGIX( GLuint *markerp )
{
    struct qemu_glFinishAsyncSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINISHASYNCSGIX);
    call.markerp = (ULONG_PTR)markerp;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glFinishAsyncSGIX(struct qemu_syscall *call)
{
    struct qemu_glFinishAsyncSGIX *c = (struct qemu_glFinishAsyncSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glFinishAsyncSGIX( QEMU_G2H(c->markerp) ));
}

#endif

struct qemu_glFinishFenceAPPLE
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFinishFenceAPPLE( GLuint fence )
{
    struct qemu_glFinishFenceAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINISHFENCEAPPLE);
    call.fence = fence;

    qemu_syscall(&call.super);
}

#else

void qemu_glFinishFenceAPPLE(struct qemu_syscall *call)
{
    struct qemu_glFinishFenceAPPLE *c = (struct qemu_glFinishFenceAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glFinishFenceAPPLE( c->fence ));
}

#endif

struct qemu_glFinishFenceNV
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFinishFenceNV( GLuint fence )
{
    struct qemu_glFinishFenceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINISHFENCENV);
    call.fence = fence;

    qemu_syscall(&call.super);
}

#else

void qemu_glFinishFenceNV(struct qemu_syscall *call)
{
    struct qemu_glFinishFenceNV *c = (struct qemu_glFinishFenceNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFinishFenceNV( c->fence ));
}

#endif

struct qemu_glFinishObjectAPPLE
{
    struct qemu_syscall super;
    uint64_t object;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFinishObjectAPPLE( GLenum object, GLint name )
{
    struct qemu_glFinishObjectAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINISHOBJECTAPPLE);
    call.object = object;
    call.name = name;

    qemu_syscall(&call.super);
}

#else

void qemu_glFinishObjectAPPLE(struct qemu_syscall *call)
{
    struct qemu_glFinishObjectAPPLE *c = (struct qemu_glFinishObjectAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glFinishObjectAPPLE( c->object, c->name ));
}

#endif

struct qemu_glFinishTextureSUNX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFinishTextureSUNX(void)
{
    struct qemu_glFinishTextureSUNX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFINISHTEXTURESUNX);

    qemu_syscall(&call.super);
}

#else

void qemu_glFinishTextureSUNX(struct qemu_syscall *call)
{
    struct qemu_glFinishTextureSUNX *c = (struct qemu_glFinishTextureSUNX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFinishTextureSUNX());
}

#endif

struct qemu_glFlushMappedBufferRange
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushMappedBufferRange( GLenum target, GLintptr offset, GLsizeiptr length )
{
    struct qemu_glFlushMappedBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHMAPPEDBUFFERRANGE);
    call.target = target;
    call.offset = offset;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushMappedBufferRange(struct qemu_syscall *call)
{
    struct qemu_glFlushMappedBufferRange *c = (struct qemu_glFlushMappedBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushMappedBufferRange( c->target, c->offset, c->length ));
}

#endif

struct qemu_glFlushMappedBufferRangeAPPLE
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushMappedBufferRangeAPPLE( GLenum target, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glFlushMappedBufferRangeAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHMAPPEDBUFFERRANGEAPPLE);
    call.target = target;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushMappedBufferRangeAPPLE(struct qemu_syscall *call)
{
    struct qemu_glFlushMappedBufferRangeAPPLE *c = (struct qemu_glFlushMappedBufferRangeAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushMappedBufferRangeAPPLE( c->target, c->offset, c->size ));
}

#endif

struct qemu_glFlushMappedNamedBufferRange
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushMappedNamedBufferRange( GLuint buffer, GLintptr offset, GLsizeiptr length )
{
    struct qemu_glFlushMappedNamedBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHMAPPEDNAMEDBUFFERRANGE);
    call.buffer = buffer;
    call.offset = offset;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushMappedNamedBufferRange(struct qemu_syscall *call)
{
    struct qemu_glFlushMappedNamedBufferRange *c = (struct qemu_glFlushMappedNamedBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushMappedNamedBufferRange( c->buffer, c->offset, c->length ));
}

#endif

struct qemu_glFlushMappedNamedBufferRangeEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushMappedNamedBufferRangeEXT( GLuint buffer, GLintptr offset, GLsizeiptr length )
{
    struct qemu_glFlushMappedNamedBufferRangeEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushMappedNamedBufferRangeEXT(struct qemu_syscall *call)
{
    struct qemu_glFlushMappedNamedBufferRangeEXT *c = (struct qemu_glFlushMappedNamedBufferRangeEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushMappedNamedBufferRangeEXT( c->buffer, c->offset, c->length ));
}

#endif

struct qemu_glFlushPixelDataRangeNV
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushPixelDataRangeNV( GLenum target )
{
    struct qemu_glFlushPixelDataRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHPIXELDATARANGENV);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushPixelDataRangeNV(struct qemu_syscall *call)
{
    struct qemu_glFlushPixelDataRangeNV *c = (struct qemu_glFlushPixelDataRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushPixelDataRangeNV( c->target ));
}

#endif

struct qemu_glFlushRasterSGIX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushRasterSGIX(void)
{
    struct qemu_glFlushRasterSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHRASTERSGIX);

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushRasterSGIX(struct qemu_syscall *call)
{
    struct qemu_glFlushRasterSGIX *c = (struct qemu_glFlushRasterSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushRasterSGIX());
}

#endif

struct qemu_glFlushStaticDataIBM
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushStaticDataIBM( GLenum target )
{
    struct qemu_glFlushStaticDataIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHSTATICDATAIBM);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushStaticDataIBM(struct qemu_syscall *call)
{
    struct qemu_glFlushStaticDataIBM *c = (struct qemu_glFlushStaticDataIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushStaticDataIBM( c->target ));
}

#endif

struct qemu_glFlushVertexArrayRangeAPPLE
{
    struct qemu_syscall super;
    uint64_t length;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushVertexArrayRangeAPPLE( GLsizei length, void *pointer )
{
    struct qemu_glFlushVertexArrayRangeAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHVERTEXARRAYRANGEAPPLE);
    call.length = length;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushVertexArrayRangeAPPLE(struct qemu_syscall *call)
{
    struct qemu_glFlushVertexArrayRangeAPPLE *c = (struct qemu_glFlushVertexArrayRangeAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushVertexArrayRangeAPPLE( c->length, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glFlushVertexArrayRangeNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFlushVertexArrayRangeNV(void)
{
    struct qemu_glFlushVertexArrayRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFLUSHVERTEXARRAYRANGENV);

    qemu_syscall(&call.super);
}

#else

void qemu_glFlushVertexArrayRangeNV(struct qemu_syscall *call)
{
    struct qemu_glFlushVertexArrayRangeNV *c = (struct qemu_glFlushVertexArrayRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFlushVertexArrayRangeNV());
}

#endif

struct qemu_glFogCoordFormatNV
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordFormatNV( GLenum type, GLsizei stride )
{
    struct qemu_glFogCoordFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDFORMATNV);
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordFormatNV(struct qemu_syscall *call)
{
    struct qemu_glFogCoordFormatNV *c = (struct qemu_glFogCoordFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordFormatNV( c->type, c->stride ));
}

#endif

struct qemu_glFogCoordPointer
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordPointer( GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glFogCoordPointer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDPOINTER);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordPointer(struct qemu_syscall *call)
{
    struct qemu_glFogCoordPointer *c = (struct qemu_glFogCoordPointer *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordPointer( c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glFogCoordPointerEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordPointerEXT( GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glFogCoordPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDPOINTEREXT);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glFogCoordPointerEXT *c = (struct qemu_glFogCoordPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordPointerEXT( c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glFogCoordPointerListIBM
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordPointerListIBM( GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glFogCoordPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDPOINTERLISTIBM);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glFogCoordPointerListIBM *c = (struct qemu_glFogCoordPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordPointerListIBM( c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glFogCoordd
{
    struct qemu_syscall super;
    double coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordd( GLdouble coord )
{
    struct qemu_glFogCoordd call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDD);
    call.coord = coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordd(struct qemu_syscall *call)
{
    struct qemu_glFogCoordd *c = (struct qemu_glFogCoordd *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordd( c->coord ));
}

#endif

struct qemu_glFogCoorddEXT
{
    struct qemu_syscall super;
    double coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoorddEXT( GLdouble coord )
{
    struct qemu_glFogCoorddEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDDEXT);
    call.coord = coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoorddEXT(struct qemu_syscall *call)
{
    struct qemu_glFogCoorddEXT *c = (struct qemu_glFogCoorddEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoorddEXT( c->coord ));
}

#endif

struct qemu_glFogCoorddv
{
    struct qemu_syscall super;
    uint64_t coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoorddv( const GLdouble *coord )
{
    struct qemu_glFogCoorddv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDDV);
    call.coord = (ULONG_PTR)coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoorddv(struct qemu_syscall *call)
{
    struct qemu_glFogCoorddv *c = (struct qemu_glFogCoorddv *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoorddv( QEMU_G2H(c->coord) ));
}

#endif

struct qemu_glFogCoorddvEXT
{
    struct qemu_syscall super;
    uint64_t coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoorddvEXT( const GLdouble *coord )
{
    struct qemu_glFogCoorddvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDDVEXT);
    call.coord = (ULONG_PTR)coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoorddvEXT(struct qemu_syscall *call)
{
    struct qemu_glFogCoorddvEXT *c = (struct qemu_glFogCoorddvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoorddvEXT( QEMU_G2H(c->coord) ));
}

#endif

struct qemu_glFogCoordf
{
    struct qemu_syscall super;
    double coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordf( GLfloat coord )
{
    struct qemu_glFogCoordf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDF);
    call.coord = coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordf(struct qemu_syscall *call)
{
    struct qemu_glFogCoordf *c = (struct qemu_glFogCoordf *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordf( c->coord ));
}

#endif

struct qemu_glFogCoordfEXT
{
    struct qemu_syscall super;
    double coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordfEXT( GLfloat coord )
{
    struct qemu_glFogCoordfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDFEXT);
    call.coord = coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordfEXT(struct qemu_syscall *call)
{
    struct qemu_glFogCoordfEXT *c = (struct qemu_glFogCoordfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordfEXT( c->coord ));
}

#endif

struct qemu_glFogCoordfv
{
    struct qemu_syscall super;
    uint64_t coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordfv( const GLfloat *coord )
{
    struct qemu_glFogCoordfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDFV);
    call.coord = (ULONG_PTR)coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordfv(struct qemu_syscall *call)
{
    struct qemu_glFogCoordfv *c = (struct qemu_glFogCoordfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordfv( QEMU_G2H(c->coord) ));
}

#endif

struct qemu_glFogCoordfvEXT
{
    struct qemu_syscall super;
    uint64_t coord;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordfvEXT( const GLfloat *coord )
{
    struct qemu_glFogCoordfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDFVEXT);
    call.coord = (ULONG_PTR)coord;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordfvEXT(struct qemu_syscall *call)
{
    struct qemu_glFogCoordfvEXT *c = (struct qemu_glFogCoordfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordfvEXT( QEMU_G2H(c->coord) ));
}

#endif

struct qemu_glFogCoordhNV
{
    struct qemu_syscall super;
    uint64_t fog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordhNV( GLhalfNV fog )
{
    struct qemu_glFogCoordhNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDHNV);
    call.fog = fog;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordhNV(struct qemu_syscall *call)
{
    struct qemu_glFogCoordhNV *c = (struct qemu_glFogCoordhNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordhNV( c->fog ));
}

#endif

struct qemu_glFogCoordhvNV
{
    struct qemu_syscall super;
    uint64_t fog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogCoordhvNV( const GLhalfNV *fog )
{
    struct qemu_glFogCoordhvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGCOORDHVNV);
    call.fog = (ULONG_PTR)fog;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogCoordhvNV(struct qemu_syscall *call)
{
    struct qemu_glFogCoordhvNV *c = (struct qemu_glFogCoordhvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogCoordhvNV( QEMU_G2H(c->fog) ));
}

#endif

struct qemu_glFogFuncSGIS
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogFuncSGIS( GLsizei n, const GLfloat *points )
{
    struct qemu_glFogFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGFUNCSGIS);
    call.n = n;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glFogFuncSGIS *c = (struct qemu_glFogFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogFuncSGIS( c->n, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glFogxOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogxOES( GLenum pname, GLfixed param )
{
    struct qemu_glFogxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGXOES);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogxOES(struct qemu_syscall *call)
{
    struct qemu_glFogxOES *c = (struct qemu_glFogxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogxOES( c->pname, c->param ));
}

#endif

struct qemu_glFogxvOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFogxvOES( GLenum pname, const GLfixed *param )
{
    struct qemu_glFogxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFOGXVOES);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFogxvOES(struct qemu_syscall *call)
{
    struct qemu_glFogxvOES *c = (struct qemu_glFogxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glFogxvOES( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glFragmentColorMaterialSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentColorMaterialSGIX( GLenum face, GLenum mode )
{
    struct qemu_glFragmentColorMaterialSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTCOLORMATERIALSGIX);
    call.face = face;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentColorMaterialSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentColorMaterialSGIX *c = (struct qemu_glFragmentColorMaterialSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentColorMaterialSGIX( c->face, c->mode ));
}

#endif

struct qemu_glFragmentCoverageColorNV
{
    struct qemu_syscall super;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentCoverageColorNV( GLuint color )
{
    struct qemu_glFragmentCoverageColorNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTCOVERAGECOLORNV);
    call.color = color;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentCoverageColorNV(struct qemu_syscall *call)
{
    struct qemu_glFragmentCoverageColorNV *c = (struct qemu_glFragmentCoverageColorNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentCoverageColorNV( c->color ));
}

#endif

struct qemu_glFragmentLightModelfSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightModelfSGIX( GLenum pname, GLfloat param )
{
    struct qemu_glFragmentLightModelfSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTMODELFSGIX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightModelfSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightModelfSGIX *c = (struct qemu_glFragmentLightModelfSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightModelfSGIX( c->pname, c->param ));
}

#endif

struct qemu_glFragmentLightModelfvSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightModelfvSGIX( GLenum pname, const GLfloat *params )
{
    struct qemu_glFragmentLightModelfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTMODELFVSGIX);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightModelfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightModelfvSGIX *c = (struct qemu_glFragmentLightModelfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightModelfvSGIX( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFragmentLightModeliSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightModeliSGIX( GLenum pname, GLint param )
{
    struct qemu_glFragmentLightModeliSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTMODELISGIX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightModeliSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightModeliSGIX *c = (struct qemu_glFragmentLightModeliSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightModeliSGIX( c->pname, c->param ));
}

#endif

struct qemu_glFragmentLightModelivSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightModelivSGIX( GLenum pname, const GLint *params )
{
    struct qemu_glFragmentLightModelivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTMODELIVSGIX);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightModelivSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightModelivSGIX *c = (struct qemu_glFragmentLightModelivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightModelivSGIX( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFragmentLightfSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightfSGIX( GLenum light, GLenum pname, GLfloat param )
{
    struct qemu_glFragmentLightfSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTFSGIX);
    call.light = light;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightfSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightfSGIX *c = (struct qemu_glFragmentLightfSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightfSGIX( c->light, c->pname, c->param ));
}

#endif

struct qemu_glFragmentLightfvSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightfvSGIX( GLenum light, GLenum pname, const GLfloat *params )
{
    struct qemu_glFragmentLightfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTFVSGIX);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightfvSGIX *c = (struct qemu_glFragmentLightfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightfvSGIX( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFragmentLightiSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightiSGIX( GLenum light, GLenum pname, GLint param )
{
    struct qemu_glFragmentLightiSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTISGIX);
    call.light = light;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightiSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightiSGIX *c = (struct qemu_glFragmentLightiSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightiSGIX( c->light, c->pname, c->param ));
}

#endif

struct qemu_glFragmentLightivSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentLightivSGIX( GLenum light, GLenum pname, const GLint *params )
{
    struct qemu_glFragmentLightivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTLIGHTIVSGIX);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentLightivSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentLightivSGIX *c = (struct qemu_glFragmentLightivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentLightivSGIX( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFragmentMaterialfSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentMaterialfSGIX( GLenum face, GLenum pname, GLfloat param )
{
    struct qemu_glFragmentMaterialfSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTMATERIALFSGIX);
    call.face = face;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentMaterialfSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentMaterialfSGIX *c = (struct qemu_glFragmentMaterialfSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentMaterialfSGIX( c->face, c->pname, c->param ));
}

#endif

struct qemu_glFragmentMaterialfvSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentMaterialfvSGIX( GLenum face, GLenum pname, const GLfloat *params )
{
    struct qemu_glFragmentMaterialfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTMATERIALFVSGIX);
    call.face = face;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentMaterialfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentMaterialfvSGIX *c = (struct qemu_glFragmentMaterialfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentMaterialfvSGIX( c->face, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFragmentMaterialiSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentMaterialiSGIX( GLenum face, GLenum pname, GLint param )
{
    struct qemu_glFragmentMaterialiSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTMATERIALISGIX);
    call.face = face;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentMaterialiSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentMaterialiSGIX *c = (struct qemu_glFragmentMaterialiSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentMaterialiSGIX( c->face, c->pname, c->param ));
}

#endif

struct qemu_glFragmentMaterialivSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFragmentMaterialivSGIX( GLenum face, GLenum pname, const GLint *params )
{
    struct qemu_glFragmentMaterialivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAGMENTMATERIALIVSGIX);
    call.face = face;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glFragmentMaterialivSGIX(struct qemu_syscall *call)
{
    struct qemu_glFragmentMaterialivSGIX *c = (struct qemu_glFragmentMaterialivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFragmentMaterialivSGIX( c->face, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glFrameTerminatorGREMEDY
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFrameTerminatorGREMEDY(void)
{
    struct qemu_glFrameTerminatorGREMEDY call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMETERMINATORGREMEDY);

    qemu_syscall(&call.super);
}

#else

void qemu_glFrameTerminatorGREMEDY(struct qemu_syscall *call)
{
    struct qemu_glFrameTerminatorGREMEDY *c = (struct qemu_glFrameTerminatorGREMEDY *)call;
    WINE_FIXME("Unverified\n");
    (p_glFrameTerminatorGREMEDY());
}

#endif

struct qemu_glFrameZoomSGIX
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFrameZoomSGIX( GLint factor )
{
    struct qemu_glFrameZoomSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEZOOMSGIX);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glFrameZoomSGIX(struct qemu_syscall *call)
{
    struct qemu_glFrameZoomSGIX *c = (struct qemu_glFrameZoomSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glFrameZoomSGIX( c->factor ));
}

#endif

struct qemu_glFramebufferDrawBufferEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferDrawBufferEXT( GLuint framebuffer, GLenum mode )
{
    struct qemu_glFramebufferDrawBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERDRAWBUFFEREXT);
    call.framebuffer = framebuffer;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferDrawBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferDrawBufferEXT *c = (struct qemu_glFramebufferDrawBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferDrawBufferEXT( c->framebuffer, c->mode ));
}

#endif

struct qemu_glFramebufferDrawBuffersEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t n;
    uint64_t bufs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferDrawBuffersEXT( GLuint framebuffer, GLsizei n, const GLenum *bufs )
{
    struct qemu_glFramebufferDrawBuffersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERDRAWBUFFERSEXT);
    call.framebuffer = framebuffer;
    call.n = n;
    call.bufs = (ULONG_PTR)bufs;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferDrawBuffersEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferDrawBuffersEXT *c = (struct qemu_glFramebufferDrawBuffersEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferDrawBuffersEXT( c->framebuffer, c->n, QEMU_G2H(c->bufs) ));
}

#endif

struct qemu_glFramebufferFetchBarrierEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferFetchBarrierEXT(void)
{
    struct qemu_glFramebufferFetchBarrierEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERFETCHBARRIEREXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferFetchBarrierEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferFetchBarrierEXT *c = (struct qemu_glFramebufferFetchBarrierEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferFetchBarrierEXT());
}

#endif

struct qemu_glFramebufferParameteri
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferParameteri( GLenum target, GLenum pname, GLint param )
{
    struct qemu_glFramebufferParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERPARAMETERI);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferParameteri(struct qemu_syscall *call)
{
    struct qemu_glFramebufferParameteri *c = (struct qemu_glFramebufferParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferParameteri( c->target, c->pname, c->param ));
}

#endif

struct qemu_glFramebufferParameteriMESA
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferParameteriMESA( GLenum target, GLenum pname, GLint param )
{
    struct qemu_glFramebufferParameteriMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERPARAMETERIMESA);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferParameteriMESA(struct qemu_syscall *call)
{
    struct qemu_glFramebufferParameteriMESA *c = (struct qemu_glFramebufferParameteriMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferParameteriMESA( c->target, c->pname, c->param ));
}

#endif

struct qemu_glFramebufferReadBufferEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferReadBufferEXT( GLuint framebuffer, GLenum mode )
{
    struct qemu_glFramebufferReadBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERREADBUFFEREXT);
    call.framebuffer = framebuffer;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferReadBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferReadBufferEXT *c = (struct qemu_glFramebufferReadBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferReadBufferEXT( c->framebuffer, c->mode ));
}

#endif

struct qemu_glFramebufferRenderbuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t renderbuffertarget;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferRenderbuffer( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer )
{
    struct qemu_glFramebufferRenderbuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERRENDERBUFFER);
    call.target = target;
    call.attachment = attachment;
    call.renderbuffertarget = renderbuffertarget;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferRenderbuffer(struct qemu_syscall *call)
{
    struct qemu_glFramebufferRenderbuffer *c = (struct qemu_glFramebufferRenderbuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferRenderbuffer( c->target, c->attachment, c->renderbuffertarget, c->renderbuffer ));
}

#endif

struct qemu_glFramebufferRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t renderbuffertarget;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferRenderbufferEXT( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer )
{
    struct qemu_glFramebufferRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERRENDERBUFFEREXT);
    call.target = target;
    call.attachment = attachment;
    call.renderbuffertarget = renderbuffertarget;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferRenderbufferEXT *c = (struct qemu_glFramebufferRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferRenderbufferEXT( c->target, c->attachment, c->renderbuffertarget, c->renderbuffer ));
}

#endif

struct qemu_glFramebufferSampleLocationsfvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferSampleLocationsfvARB( GLenum target, GLuint start, GLsizei count, const GLfloat *v )
{
    struct qemu_glFramebufferSampleLocationsfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERSAMPLELOCATIONSFVARB);
    call.target = target;
    call.start = start;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferSampleLocationsfvARB(struct qemu_syscall *call)
{
    struct qemu_glFramebufferSampleLocationsfvARB *c = (struct qemu_glFramebufferSampleLocationsfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferSampleLocationsfvARB( c->target, c->start, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glFramebufferSampleLocationsfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t start;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferSampleLocationsfvNV( GLenum target, GLuint start, GLsizei count, const GLfloat *v )
{
    struct qemu_glFramebufferSampleLocationsfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERSAMPLELOCATIONSFVNV);
    call.target = target;
    call.start = start;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferSampleLocationsfvNV(struct qemu_syscall *call)
{
    struct qemu_glFramebufferSampleLocationsfvNV *c = (struct qemu_glFramebufferSampleLocationsfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferSampleLocationsfvNV( c->target, c->start, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glFramebufferSamplePositionsfvAMD
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t numsamples;
    uint64_t pixelindex;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferSamplePositionsfvAMD( GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values )
{
    struct qemu_glFramebufferSamplePositionsfvAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERSAMPLEPOSITIONSFVAMD);
    call.target = target;
    call.numsamples = numsamples;
    call.pixelindex = pixelindex;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferSamplePositionsfvAMD(struct qemu_syscall *call)
{
    struct qemu_glFramebufferSamplePositionsfvAMD *c = (struct qemu_glFramebufferSamplePositionsfvAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferSamplePositionsfvAMD( c->target, c->numsamples, c->pixelindex, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glFramebufferTexture
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture( GLenum target, GLenum attachment, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTexture call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture *c = (struct qemu_glFramebufferTexture *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture( c->target, c->attachment, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTexture1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture1D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTexture1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE1D);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture1D(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture1D *c = (struct qemu_glFramebufferTexture1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture1D( c->target, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTexture1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture1DEXT( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTexture1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE1DEXT);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture1DEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture1DEXT *c = (struct qemu_glFramebufferTexture1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture1DEXT( c->target, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTexture2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture2D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTexture2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE2D);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture2D(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture2D *c = (struct qemu_glFramebufferTexture2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture2D( c->target, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTexture2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture2DEXT( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTexture2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE2DEXT);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture2DEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture2DEXT *c = (struct qemu_glFramebufferTexture2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture2DEXT( c->target, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTexture3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
    uint64_t zoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture3D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset )
{
    struct qemu_glFramebufferTexture3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE3D);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;
    call.zoffset = zoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture3D(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture3D *c = (struct qemu_glFramebufferTexture3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture3D( c->target, c->attachment, c->textarget, c->texture, c->level, c->zoffset ));
}

#endif

struct qemu_glFramebufferTexture3DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
    uint64_t zoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTexture3DEXT( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset )
{
    struct qemu_glFramebufferTexture3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURE3DEXT);
    call.target = target;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;
    call.zoffset = zoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTexture3DEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTexture3DEXT *c = (struct qemu_glFramebufferTexture3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTexture3DEXT( c->target, c->attachment, c->textarget, c->texture, c->level, c->zoffset ));
}

#endif

struct qemu_glFramebufferTextureARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureARB( GLenum target, GLenum attachment, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTextureARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTUREARB);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureARB(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureARB *c = (struct qemu_glFramebufferTextureARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureARB( c->target, c->attachment, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTextureEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureEXT( GLenum target, GLenum attachment, GLuint texture, GLint level )
{
    struct qemu_glFramebufferTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTUREEXT);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureEXT *c = (struct qemu_glFramebufferTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureEXT( c->target, c->attachment, c->texture, c->level ));
}

#endif

struct qemu_glFramebufferTextureFaceARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t face;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureFaceARB( GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face )
{
    struct qemu_glFramebufferTextureFaceARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTUREFACEARB);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.face = face;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureFaceARB(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureFaceARB *c = (struct qemu_glFramebufferTextureFaceARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureFaceARB( c->target, c->attachment, c->texture, c->level, c->face ));
}

#endif

struct qemu_glFramebufferTextureFaceEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t face;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureFaceEXT( GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face )
{
    struct qemu_glFramebufferTextureFaceEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTUREFACEEXT);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.face = face;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureFaceEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureFaceEXT *c = (struct qemu_glFramebufferTextureFaceEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureFaceEXT( c->target, c->attachment, c->texture, c->level, c->face ));
}

#endif

struct qemu_glFramebufferTextureLayer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t layer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureLayer( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer )
{
    struct qemu_glFramebufferTextureLayer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURELAYER);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.layer = layer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureLayer(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureLayer *c = (struct qemu_glFramebufferTextureLayer *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureLayer( c->target, c->attachment, c->texture, c->level, c->layer ));
}

#endif

struct qemu_glFramebufferTextureLayerARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t layer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureLayerARB( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer )
{
    struct qemu_glFramebufferTextureLayerARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURELAYERARB);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.layer = layer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureLayerARB(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureLayerARB *c = (struct qemu_glFramebufferTextureLayerARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureLayerARB( c->target, c->attachment, c->texture, c->level, c->layer ));
}

#endif

struct qemu_glFramebufferTextureLayerEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t layer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureLayerEXT( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer )
{
    struct qemu_glFramebufferTextureLayerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTURELAYEREXT);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.layer = layer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureLayerEXT(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureLayerEXT *c = (struct qemu_glFramebufferTextureLayerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureLayerEXT( c->target, c->attachment, c->texture, c->level, c->layer ));
}

#endif

struct qemu_glFramebufferTextureMultiviewOVR
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t baseViewIndex;
    uint64_t numViews;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFramebufferTextureMultiviewOVR( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews )
{
    struct qemu_glFramebufferTextureMultiviewOVR call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRAMEBUFFERTEXTUREMULTIVIEWOVR);
    call.target = target;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.baseViewIndex = baseViewIndex;
    call.numViews = numViews;

    qemu_syscall(&call.super);
}

#else

void qemu_glFramebufferTextureMultiviewOVR(struct qemu_syscall *call)
{
    struct qemu_glFramebufferTextureMultiviewOVR *c = (struct qemu_glFramebufferTextureMultiviewOVR *)call;
    WINE_FIXME("Unverified\n");
    (p_glFramebufferTextureMultiviewOVR( c->target, c->attachment, c->texture, c->level, c->baseViewIndex, c->numViews ));
}

#endif

struct qemu_glFreeObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFreeObjectBufferATI( GLuint buffer )
{
    struct qemu_glFreeObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFREEOBJECTBUFFERATI);
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glFreeObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glFreeObjectBufferATI *c = (struct qemu_glFreeObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glFreeObjectBufferATI( c->buffer ));
}

#endif

struct qemu_glFrustumfOES
{
    struct qemu_syscall super;
    double l;
    double r;
    double b;
    double t;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFrustumfOES( GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f )
{
    struct qemu_glFrustumfOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRUSTUMFOES);
    call.l = l;
    call.r = r;
    call.b = b;
    call.t = t;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glFrustumfOES(struct qemu_syscall *call)
{
    struct qemu_glFrustumfOES *c = (struct qemu_glFrustumfOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glFrustumfOES( c->l, c->r, c->b, c->t, c->n, c->f ));
}

#endif

struct qemu_glFrustumxOES
{
    struct qemu_syscall super;
    uint64_t l;
    uint64_t r;
    uint64_t b;
    uint64_t t;
    uint64_t n;
    uint64_t f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glFrustumxOES( GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f )
{
    struct qemu_glFrustumxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLFRUSTUMXOES);
    call.l = l;
    call.r = r;
    call.b = b;
    call.t = t;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glFrustumxOES(struct qemu_syscall *call)
{
    struct qemu_glFrustumxOES *c = (struct qemu_glFrustumxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glFrustumxOES( c->l, c->r, c->b, c->t, c->n, c->f ));
}

#endif

struct qemu_glGenAsyncMarkersSGIX
{
    struct qemu_syscall super;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGenAsyncMarkersSGIX( GLsizei range )
{
    struct qemu_glGenAsyncMarkersSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENASYNCMARKERSSGIX);
    call.range = range;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGenAsyncMarkersSGIX(struct qemu_syscall *call)
{
    struct qemu_glGenAsyncMarkersSGIX *c = (struct qemu_glGenAsyncMarkersSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGenAsyncMarkersSGIX( c->range ));
}

#endif

struct qemu_glGenBuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenBuffers( GLsizei n, GLuint *buffers )
{
    struct qemu_glGenBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENBUFFERS);
    call.n = n;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenBuffers(struct qemu_syscall *call)
{
    struct qemu_glGenBuffers *c = (struct qemu_glGenBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenBuffers( c->n, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glGenBuffersARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t buffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenBuffersARB( GLsizei n, GLuint *buffers )
{
    struct qemu_glGenBuffersARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENBUFFERSARB);
    call.n = n;
    call.buffers = (ULONG_PTR)buffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenBuffersARB(struct qemu_syscall *call)
{
    struct qemu_glGenBuffersARB *c = (struct qemu_glGenBuffersARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenBuffersARB( c->n, QEMU_G2H(c->buffers) ));
}

#endif

struct qemu_glGenFencesAPPLE
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t fences;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenFencesAPPLE( GLsizei n, GLuint *fences )
{
    struct qemu_glGenFencesAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENFENCESAPPLE);
    call.n = n;
    call.fences = (ULONG_PTR)fences;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenFencesAPPLE(struct qemu_syscall *call)
{
    struct qemu_glGenFencesAPPLE *c = (struct qemu_glGenFencesAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenFencesAPPLE( c->n, QEMU_G2H(c->fences) ));
}

#endif

struct qemu_glGenFencesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t fences;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenFencesNV( GLsizei n, GLuint *fences )
{
    struct qemu_glGenFencesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENFENCESNV);
    call.n = n;
    call.fences = (ULONG_PTR)fences;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenFencesNV(struct qemu_syscall *call)
{
    struct qemu_glGenFencesNV *c = (struct qemu_glGenFencesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenFencesNV( c->n, QEMU_G2H(c->fences) ));
}

#endif

struct qemu_glGenFragmentShadersATI
{
    struct qemu_syscall super;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGenFragmentShadersATI( GLuint range )
{
    struct qemu_glGenFragmentShadersATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENFRAGMENTSHADERSATI);
    call.range = range;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGenFragmentShadersATI(struct qemu_syscall *call)
{
    struct qemu_glGenFragmentShadersATI *c = (struct qemu_glGenFragmentShadersATI *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGenFragmentShadersATI( c->range ));
}

#endif

struct qemu_glGenFramebuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t framebuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenFramebuffers( GLsizei n, GLuint *framebuffers )
{
    struct qemu_glGenFramebuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENFRAMEBUFFERS);
    call.n = n;
    call.framebuffers = (ULONG_PTR)framebuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenFramebuffers(struct qemu_syscall *call)
{
    struct qemu_glGenFramebuffers *c = (struct qemu_glGenFramebuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenFramebuffers( c->n, QEMU_G2H(c->framebuffers) ));
}

#endif

struct qemu_glGenFramebuffersEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t framebuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenFramebuffersEXT( GLsizei n, GLuint *framebuffers )
{
    struct qemu_glGenFramebuffersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENFRAMEBUFFERSEXT);
    call.n = n;
    call.framebuffers = (ULONG_PTR)framebuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenFramebuffersEXT(struct qemu_syscall *call)
{
    struct qemu_glGenFramebuffersEXT *c = (struct qemu_glGenFramebuffersEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenFramebuffersEXT( c->n, QEMU_G2H(c->framebuffers) ));
}

#endif

struct qemu_glGenNamesAMD
{
    struct qemu_syscall super;
    uint64_t identifier;
    uint64_t num;
    uint64_t names;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenNamesAMD( GLenum identifier, GLuint num, GLuint *names )
{
    struct qemu_glGenNamesAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENNAMESAMD);
    call.identifier = identifier;
    call.num = num;
    call.names = (ULONG_PTR)names;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenNamesAMD(struct qemu_syscall *call)
{
    struct qemu_glGenNamesAMD *c = (struct qemu_glGenNamesAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenNamesAMD( c->identifier, c->num, QEMU_G2H(c->names) ));
}

#endif

struct qemu_glGenOcclusionQueriesNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenOcclusionQueriesNV( GLsizei n, GLuint *ids )
{
    struct qemu_glGenOcclusionQueriesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENOCCLUSIONQUERIESNV);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenOcclusionQueriesNV(struct qemu_syscall *call)
{
    struct qemu_glGenOcclusionQueriesNV *c = (struct qemu_glGenOcclusionQueriesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenOcclusionQueriesNV( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glGenPathsNV
{
    struct qemu_syscall super;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGenPathsNV( GLsizei range )
{
    struct qemu_glGenPathsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENPATHSNV);
    call.range = range;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGenPathsNV(struct qemu_syscall *call)
{
    struct qemu_glGenPathsNV *c = (struct qemu_glGenPathsNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGenPathsNV( c->range ));
}

#endif

struct qemu_glGenPerfMonitorsAMD
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t monitors;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenPerfMonitorsAMD( GLsizei n, GLuint *monitors )
{
    struct qemu_glGenPerfMonitorsAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENPERFMONITORSAMD);
    call.n = n;
    call.monitors = (ULONG_PTR)monitors;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenPerfMonitorsAMD(struct qemu_syscall *call)
{
    struct qemu_glGenPerfMonitorsAMD *c = (struct qemu_glGenPerfMonitorsAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenPerfMonitorsAMD( c->n, QEMU_G2H(c->monitors) ));
}

#endif

struct qemu_glGenProgramPipelines
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t pipelines;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenProgramPipelines( GLsizei n, GLuint *pipelines )
{
    struct qemu_glGenProgramPipelines call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENPROGRAMPIPELINES);
    call.n = n;
    call.pipelines = (ULONG_PTR)pipelines;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenProgramPipelines(struct qemu_syscall *call)
{
    struct qemu_glGenProgramPipelines *c = (struct qemu_glGenProgramPipelines *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenProgramPipelines( c->n, QEMU_G2H(c->pipelines) ));
}

#endif

struct qemu_glGenProgramsARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenProgramsARB( GLsizei n, GLuint *programs )
{
    struct qemu_glGenProgramsARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENPROGRAMSARB);
    call.n = n;
    call.programs = (ULONG_PTR)programs;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenProgramsARB(struct qemu_syscall *call)
{
    struct qemu_glGenProgramsARB *c = (struct qemu_glGenProgramsARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenProgramsARB( c->n, QEMU_G2H(c->programs) ));
}

#endif

struct qemu_glGenProgramsNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenProgramsNV( GLsizei n, GLuint *programs )
{
    struct qemu_glGenProgramsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENPROGRAMSNV);
    call.n = n;
    call.programs = (ULONG_PTR)programs;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenProgramsNV(struct qemu_syscall *call)
{
    struct qemu_glGenProgramsNV *c = (struct qemu_glGenProgramsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenProgramsNV( c->n, QEMU_G2H(c->programs) ));
}

#endif

struct qemu_glGenQueries
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenQueries( GLsizei n, GLuint *ids )
{
    struct qemu_glGenQueries call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENQUERIES);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenQueries(struct qemu_syscall *call)
{
    struct qemu_glGenQueries *c = (struct qemu_glGenQueries *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenQueries( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glGenQueriesARB
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenQueriesARB( GLsizei n, GLuint *ids )
{
    struct qemu_glGenQueriesARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENQUERIESARB);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenQueriesARB(struct qemu_syscall *call)
{
    struct qemu_glGenQueriesARB *c = (struct qemu_glGenQueriesARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenQueriesARB( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glGenQueryResourceTagNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t tagIds;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenQueryResourceTagNV( GLsizei n, GLint *tagIds )
{
    struct qemu_glGenQueryResourceTagNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENQUERYRESOURCETAGNV);
    call.n = n;
    call.tagIds = (ULONG_PTR)tagIds;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenQueryResourceTagNV(struct qemu_syscall *call)
{
    struct qemu_glGenQueryResourceTagNV *c = (struct qemu_glGenQueryResourceTagNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenQueryResourceTagNV( c->n, QEMU_G2H(c->tagIds) ));
}

#endif

struct qemu_glGenRenderbuffers
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t renderbuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenRenderbuffers( GLsizei n, GLuint *renderbuffers )
{
    struct qemu_glGenRenderbuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENRENDERBUFFERS);
    call.n = n;
    call.renderbuffers = (ULONG_PTR)renderbuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenRenderbuffers(struct qemu_syscall *call)
{
    struct qemu_glGenRenderbuffers *c = (struct qemu_glGenRenderbuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenRenderbuffers( c->n, QEMU_G2H(c->renderbuffers) ));
}

#endif

struct qemu_glGenRenderbuffersEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t renderbuffers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenRenderbuffersEXT( GLsizei n, GLuint *renderbuffers )
{
    struct qemu_glGenRenderbuffersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENRENDERBUFFERSEXT);
    call.n = n;
    call.renderbuffers = (ULONG_PTR)renderbuffers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenRenderbuffersEXT(struct qemu_syscall *call)
{
    struct qemu_glGenRenderbuffersEXT *c = (struct qemu_glGenRenderbuffersEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenRenderbuffersEXT( c->n, QEMU_G2H(c->renderbuffers) ));
}

#endif

struct qemu_glGenSamplers
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t samplers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenSamplers( GLsizei count, GLuint *samplers )
{
    struct qemu_glGenSamplers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENSAMPLERS);
    call.count = count;
    call.samplers = (ULONG_PTR)samplers;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenSamplers(struct qemu_syscall *call)
{
    struct qemu_glGenSamplers *c = (struct qemu_glGenSamplers *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenSamplers( c->count, QEMU_G2H(c->samplers) ));
}

#endif

struct qemu_glGenSemaphoresEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t semaphores;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenSemaphoresEXT( GLsizei n, GLuint *semaphores )
{
    struct qemu_glGenSemaphoresEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENSEMAPHORESEXT);
    call.n = n;
    call.semaphores = (ULONG_PTR)semaphores;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenSemaphoresEXT(struct qemu_syscall *call)
{
    struct qemu_glGenSemaphoresEXT *c = (struct qemu_glGenSemaphoresEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenSemaphoresEXT( c->n, QEMU_G2H(c->semaphores) ));
}

#endif

struct qemu_glGenSymbolsEXT
{
    struct qemu_syscall super;
    uint64_t datatype;
    uint64_t storagetype;
    uint64_t range;
    uint64_t components;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGenSymbolsEXT( GLenum datatype, GLenum storagetype, GLenum range, GLuint components )
{
    struct qemu_glGenSymbolsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENSYMBOLSEXT);
    call.datatype = datatype;
    call.storagetype = storagetype;
    call.range = range;
    call.components = components;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGenSymbolsEXT(struct qemu_syscall *call)
{
    struct qemu_glGenSymbolsEXT *c = (struct qemu_glGenSymbolsEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGenSymbolsEXT( c->datatype, c->storagetype, c->range, c->components ));
}

#endif

struct qemu_glGenTexturesEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t textures;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenTexturesEXT( GLsizei n, GLuint *textures )
{
    struct qemu_glGenTexturesEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENTEXTURESEXT);
    call.n = n;
    call.textures = (ULONG_PTR)textures;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenTexturesEXT(struct qemu_syscall *call)
{
    struct qemu_glGenTexturesEXT *c = (struct qemu_glGenTexturesEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenTexturesEXT( c->n, QEMU_G2H(c->textures) ));
}

#endif

struct qemu_glGenTransformFeedbacks
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenTransformFeedbacks( GLsizei n, GLuint *ids )
{
    struct qemu_glGenTransformFeedbacks call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENTRANSFORMFEEDBACKS);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenTransformFeedbacks(struct qemu_syscall *call)
{
    struct qemu_glGenTransformFeedbacks *c = (struct qemu_glGenTransformFeedbacks *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenTransformFeedbacks( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glGenTransformFeedbacksNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t ids;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenTransformFeedbacksNV( GLsizei n, GLuint *ids )
{
    struct qemu_glGenTransformFeedbacksNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENTRANSFORMFEEDBACKSNV);
    call.n = n;
    call.ids = (ULONG_PTR)ids;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenTransformFeedbacksNV(struct qemu_syscall *call)
{
    struct qemu_glGenTransformFeedbacksNV *c = (struct qemu_glGenTransformFeedbacksNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenTransformFeedbacksNV( c->n, QEMU_G2H(c->ids) ));
}

#endif

struct qemu_glGenVertexArrays
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t arrays;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenVertexArrays( GLsizei n, GLuint *arrays )
{
    struct qemu_glGenVertexArrays call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENVERTEXARRAYS);
    call.n = n;
    call.arrays = (ULONG_PTR)arrays;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenVertexArrays(struct qemu_syscall *call)
{
    struct qemu_glGenVertexArrays *c = (struct qemu_glGenVertexArrays *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenVertexArrays( c->n, QEMU_G2H(c->arrays) ));
}

#endif

struct qemu_glGenVertexArraysAPPLE
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t arrays;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenVertexArraysAPPLE( GLsizei n, GLuint *arrays )
{
    struct qemu_glGenVertexArraysAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENVERTEXARRAYSAPPLE);
    call.n = n;
    call.arrays = (ULONG_PTR)arrays;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenVertexArraysAPPLE(struct qemu_syscall *call)
{
    struct qemu_glGenVertexArraysAPPLE *c = (struct qemu_glGenVertexArraysAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenVertexArraysAPPLE( c->n, QEMU_G2H(c->arrays) ));
}

#endif

struct qemu_glGenVertexShadersEXT
{
    struct qemu_syscall super;
    uint64_t range;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGenVertexShadersEXT( GLuint range )
{
    struct qemu_glGenVertexShadersEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENVERTEXSHADERSEXT);
    call.range = range;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGenVertexShadersEXT(struct qemu_syscall *call)
{
    struct qemu_glGenVertexShadersEXT *c = (struct qemu_glGenVertexShadersEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGenVertexShadersEXT( c->range ));
}

#endif

struct qemu_glGenerateMipmap
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenerateMipmap( GLenum target )
{
    struct qemu_glGenerateMipmap call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENERATEMIPMAP);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenerateMipmap(struct qemu_syscall *call)
{
    struct qemu_glGenerateMipmap *c = (struct qemu_glGenerateMipmap *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenerateMipmap( c->target ));
}

#endif

struct qemu_glGenerateMipmapEXT
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenerateMipmapEXT( GLenum target )
{
    struct qemu_glGenerateMipmapEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENERATEMIPMAPEXT);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenerateMipmapEXT(struct qemu_syscall *call)
{
    struct qemu_glGenerateMipmapEXT *c = (struct qemu_glGenerateMipmapEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenerateMipmapEXT( c->target ));
}

#endif

struct qemu_glGenerateMultiTexMipmapEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenerateMultiTexMipmapEXT( GLenum texunit, GLenum target )
{
    struct qemu_glGenerateMultiTexMipmapEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENERATEMULTITEXMIPMAPEXT);
    call.texunit = texunit;
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenerateMultiTexMipmapEXT(struct qemu_syscall *call)
{
    struct qemu_glGenerateMultiTexMipmapEXT *c = (struct qemu_glGenerateMultiTexMipmapEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenerateMultiTexMipmapEXT( c->texunit, c->target ));
}

#endif

struct qemu_glGenerateTextureMipmap
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenerateTextureMipmap( GLuint texture )
{
    struct qemu_glGenerateTextureMipmap call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENERATETEXTUREMIPMAP);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenerateTextureMipmap(struct qemu_syscall *call)
{
    struct qemu_glGenerateTextureMipmap *c = (struct qemu_glGenerateTextureMipmap *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenerateTextureMipmap( c->texture ));
}

#endif

struct qemu_glGenerateTextureMipmapEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGenerateTextureMipmapEXT( GLuint texture, GLenum target )
{
    struct qemu_glGenerateTextureMipmapEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGENERATETEXTUREMIPMAPEXT);
    call.texture = texture;
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glGenerateTextureMipmapEXT(struct qemu_syscall *call)
{
    struct qemu_glGenerateTextureMipmapEXT *c = (struct qemu_glGenerateTextureMipmapEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGenerateTextureMipmapEXT( c->texture, c->target ));
}

#endif

struct qemu_glGetActiveAtomicCounterBufferiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t bufferIndex;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveAtomicCounterBufferiv( GLuint program, GLuint bufferIndex, GLenum pname, GLint *params )
{
    struct qemu_glGetActiveAtomicCounterBufferiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEATOMICCOUNTERBUFFERIV);
    call.program = program;
    call.bufferIndex = bufferIndex;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveAtomicCounterBufferiv(struct qemu_syscall *call)
{
    struct qemu_glGetActiveAtomicCounterBufferiv *c = (struct qemu_glGetActiveAtomicCounterBufferiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveAtomicCounterBufferiv( c->program, c->bufferIndex, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetActiveAttrib
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveAttrib( GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name )
{
    struct qemu_glGetActiveAttrib call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEATTRIB);
    call.program = program;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveAttrib(struct qemu_syscall *call)
{
    struct qemu_glGetActiveAttrib *c = (struct qemu_glGetActiveAttrib *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveAttrib( c->program, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveAttribARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t index;
    uint64_t maxLength;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveAttribARB( GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name )
{
    struct qemu_glGetActiveAttribARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEATTRIBARB);
    call.programObj = programObj;
    call.index = index;
    call.maxLength = maxLength;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveAttribARB(struct qemu_syscall *call)
{
    struct qemu_glGetActiveAttribARB *c = (struct qemu_glGetActiveAttribARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveAttribARB( c->programObj, c->index, c->maxLength, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveSubroutineName
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveSubroutineName( GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name )
{
    struct qemu_glGetActiveSubroutineName call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVESUBROUTINENAME);
    call.program = program;
    call.shadertype = shadertype;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveSubroutineName(struct qemu_syscall *call)
{
    struct qemu_glGetActiveSubroutineName *c = (struct qemu_glGetActiveSubroutineName *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveSubroutineName( c->program, c->shadertype, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveSubroutineUniformName
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveSubroutineUniformName( GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name )
{
    struct qemu_glGetActiveSubroutineUniformName call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVESUBROUTINEUNIFORMNAME);
    call.program = program;
    call.shadertype = shadertype;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveSubroutineUniformName(struct qemu_syscall *call)
{
    struct qemu_glGetActiveSubroutineUniformName *c = (struct qemu_glGetActiveSubroutineUniformName *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveSubroutineUniformName( c->program, c->shadertype, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveSubroutineUniformiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t index;
    uint64_t pname;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveSubroutineUniformiv( GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values )
{
    struct qemu_glGetActiveSubroutineUniformiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVESUBROUTINEUNIFORMIV);
    call.program = program;
    call.shadertype = shadertype;
    call.index = index;
    call.pname = pname;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveSubroutineUniformiv(struct qemu_syscall *call)
{
    struct qemu_glGetActiveSubroutineUniformiv *c = (struct qemu_glGetActiveSubroutineUniformiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveSubroutineUniformiv( c->program, c->shadertype, c->index, c->pname, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetActiveUniform
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniform( GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name )
{
    struct qemu_glGetActiveUniform call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORM);
    call.program = program;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniform(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniform *c = (struct qemu_glGetActiveUniform *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniform( c->program, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveUniformARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t index;
    uint64_t maxLength;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniformARB( GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name )
{
    struct qemu_glGetActiveUniformARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORMARB);
    call.programObj = programObj;
    call.index = index;
    call.maxLength = maxLength;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniformARB(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniformARB *c = (struct qemu_glGetActiveUniformARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniformARB( c->programObj, c->index, c->maxLength, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetActiveUniformBlockName
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformBlockIndex;
    uint64_t bufSize;
    uint64_t length;
    uint64_t uniformBlockName;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniformBlockName( GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName )
{
    struct qemu_glGetActiveUniformBlockName call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORMBLOCKNAME);
    call.program = program;
    call.uniformBlockIndex = uniformBlockIndex;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.uniformBlockName = (ULONG_PTR)uniformBlockName;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniformBlockName(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniformBlockName *c = (struct qemu_glGetActiveUniformBlockName *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniformBlockName( c->program, c->uniformBlockIndex, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->uniformBlockName) ));
}

#endif

struct qemu_glGetActiveUniformBlockiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformBlockIndex;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniformBlockiv( GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params )
{
    struct qemu_glGetActiveUniformBlockiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORMBLOCKIV);
    call.program = program;
    call.uniformBlockIndex = uniformBlockIndex;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniformBlockiv(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniformBlockiv *c = (struct qemu_glGetActiveUniformBlockiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniformBlockiv( c->program, c->uniformBlockIndex, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetActiveUniformName
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformIndex;
    uint64_t bufSize;
    uint64_t length;
    uint64_t uniformName;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniformName( GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName )
{
    struct qemu_glGetActiveUniformName call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORMNAME);
    call.program = program;
    call.uniformIndex = uniformIndex;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.uniformName = (ULONG_PTR)uniformName;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniformName(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniformName *c = (struct qemu_glGetActiveUniformName *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniformName( c->program, c->uniformIndex, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->uniformName) ));
}

#endif

struct qemu_glGetActiveUniformsiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformCount;
    uint64_t uniformIndices;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveUniformsiv( GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params )
{
    struct qemu_glGetActiveUniformsiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEUNIFORMSIV);
    call.program = program;
    call.uniformCount = uniformCount;
    call.uniformIndices = (ULONG_PTR)uniformIndices;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveUniformsiv(struct qemu_syscall *call)
{
    struct qemu_glGetActiveUniformsiv *c = (struct qemu_glGetActiveUniformsiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveUniformsiv( c->program, c->uniformCount, QEMU_G2H(c->uniformIndices), c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetActiveVaryingNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetActiveVaryingNV( GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name )
{
    struct qemu_glGetActiveVaryingNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETACTIVEVARYINGNV);
    call.program = program;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetActiveVaryingNV(struct qemu_syscall *call)
{
    struct qemu_glGetActiveVaryingNV *c = (struct qemu_glGetActiveVaryingNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetActiveVaryingNV( c->program, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetArrayObjectfvATI
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetArrayObjectfvATI( GLenum array, GLenum pname, GLfloat *params )
{
    struct qemu_glGetArrayObjectfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETARRAYOBJECTFVATI);
    call.array = array;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetArrayObjectfvATI(struct qemu_syscall *call)
{
    struct qemu_glGetArrayObjectfvATI *c = (struct qemu_glGetArrayObjectfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetArrayObjectfvATI( c->array, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetArrayObjectivATI
{
    struct qemu_syscall super;
    uint64_t array;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetArrayObjectivATI( GLenum array, GLenum pname, GLint *params )
{
    struct qemu_glGetArrayObjectivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETARRAYOBJECTIVATI);
    call.array = array;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetArrayObjectivATI(struct qemu_syscall *call)
{
    struct qemu_glGetArrayObjectivATI *c = (struct qemu_glGetArrayObjectivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetArrayObjectivATI( c->array, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetAttachedObjectsARB
{
    struct qemu_syscall super;
    uint64_t containerObj;
    uint64_t maxCount;
    uint64_t count;
    uint64_t obj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetAttachedObjectsARB( GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj )
{
    struct qemu_glGetAttachedObjectsARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETATTACHEDOBJECTSARB);
    call.containerObj = containerObj;
    call.maxCount = maxCount;
    call.count = (ULONG_PTR)count;
    call.obj = (ULONG_PTR)obj;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetAttachedObjectsARB(struct qemu_syscall *call)
{
    struct qemu_glGetAttachedObjectsARB *c = (struct qemu_glGetAttachedObjectsARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetAttachedObjectsARB( c->containerObj, c->maxCount, QEMU_G2H(c->count), QEMU_G2H(c->obj) ));
}

#endif

struct qemu_glGetAttachedShaders
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t maxCount;
    uint64_t count;
    uint64_t shaders;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetAttachedShaders( GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders )
{
    struct qemu_glGetAttachedShaders call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETATTACHEDSHADERS);
    call.program = program;
    call.maxCount = maxCount;
    call.count = (ULONG_PTR)count;
    call.shaders = (ULONG_PTR)shaders;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetAttachedShaders(struct qemu_syscall *call)
{
    struct qemu_glGetAttachedShaders *c = (struct qemu_glGetAttachedShaders *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetAttachedShaders( c->program, c->maxCount, QEMU_G2H(c->count), QEMU_G2H(c->shaders) ));
}

#endif

struct qemu_glGetAttribLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetAttribLocation( GLuint program, const GLchar *name )
{
    struct qemu_glGetAttribLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETATTRIBLOCATION);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetAttribLocation(struct qemu_syscall *call)
{
    struct qemu_glGetAttribLocation *c = (struct qemu_glGetAttribLocation *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetAttribLocation( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetAttribLocationARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetAttribLocationARB( GLhandleARB programObj, const GLcharARB *name )
{
    struct qemu_glGetAttribLocationARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETATTRIBLOCATIONARB);
    call.programObj = programObj;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetAttribLocationARB(struct qemu_syscall *call)
{
    struct qemu_glGetAttribLocationARB *c = (struct qemu_glGetAttribLocationARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetAttribLocationARB( c->programObj, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetBooleanIndexedvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBooleanIndexedvEXT( GLenum target, GLuint index, GLboolean *data )
{
    struct qemu_glGetBooleanIndexedvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBOOLEANINDEXEDVEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBooleanIndexedvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetBooleanIndexedvEXT *c = (struct qemu_glGetBooleanIndexedvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBooleanIndexedvEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetBooleani_v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBooleani_v( GLenum target, GLuint index, GLboolean *data )
{
    struct qemu_glGetBooleani_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBOOLEANI_V);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBooleani_v(struct qemu_syscall *call)
{
    struct qemu_glGetBooleani_v *c = (struct qemu_glGetBooleani_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBooleani_v( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetBufferParameteri64v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferParameteri64v( GLenum target, GLenum pname, GLint64 *params )
{
    struct qemu_glGetBufferParameteri64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPARAMETERI64V);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferParameteri64v(struct qemu_syscall *call)
{
    struct qemu_glGetBufferParameteri64v *c = (struct qemu_glGetBufferParameteri64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferParameteri64v( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetBufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetBufferParameteriv *c = (struct qemu_glGetBufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferParameterivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferParameterivARB( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetBufferParameterivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPARAMETERIVARB);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferParameterivARB(struct qemu_syscall *call)
{
    struct qemu_glGetBufferParameterivARB *c = (struct qemu_glGetBufferParameterivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferParameterivARB( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferParameterui64vNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferParameterui64vNV( GLenum target, GLenum pname, GLuint64EXT *params )
{
    struct qemu_glGetBufferParameterui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPARAMETERUI64VNV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferParameterui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetBufferParameterui64vNV *c = (struct qemu_glGetBufferParameterui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferParameterui64vNV( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferPointerv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferPointerv( GLenum target, GLenum pname, void **params )
{
    struct qemu_glGetBufferPointerv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPOINTERV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferPointerv(struct qemu_syscall *call)
{
    struct qemu_glGetBufferPointerv *c = (struct qemu_glGetBufferPointerv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferPointerv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferPointervARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferPointervARB( GLenum target, GLenum pname, void **params )
{
    struct qemu_glGetBufferPointervARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERPOINTERVARB);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferPointervARB(struct qemu_syscall *call)
{
    struct qemu_glGetBufferPointervARB *c = (struct qemu_glGetBufferPointervARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferPointervARB( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetBufferSubData
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferSubData( GLenum target, GLintptr offset, GLsizeiptr size, void *data )
{
    struct qemu_glGetBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERSUBDATA);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glGetBufferSubData *c = (struct qemu_glGetBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferSubData( c->target, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetBufferSubDataARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetBufferSubDataARB( GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data )
{
    struct qemu_glGetBufferSubDataARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETBUFFERSUBDATAARB);
    call.target = target;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetBufferSubDataARB(struct qemu_syscall *call)
{
    struct qemu_glGetBufferSubDataARB *c = (struct qemu_glGetBufferSubDataARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetBufferSubDataARB( c->target, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetClipPlanefOES
{
    struct qemu_syscall super;
    uint64_t plane;
    uint64_t equation;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetClipPlanefOES( GLenum plane, GLfloat *equation )
{
    struct qemu_glGetClipPlanefOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCLIPPLANEFOES);
    call.plane = plane;
    call.equation = (ULONG_PTR)equation;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetClipPlanefOES(struct qemu_syscall *call)
{
    struct qemu_glGetClipPlanefOES *c = (struct qemu_glGetClipPlanefOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetClipPlanefOES( c->plane, QEMU_G2H(c->equation) ));
}

#endif

struct qemu_glGetClipPlanexOES
{
    struct qemu_syscall super;
    uint64_t plane;
    uint64_t equation;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetClipPlanexOES( GLenum plane, GLfixed *equation )
{
    struct qemu_glGetClipPlanexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCLIPPLANEXOES);
    call.plane = plane;
    call.equation = (ULONG_PTR)equation;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetClipPlanexOES(struct qemu_syscall *call)
{
    struct qemu_glGetClipPlanexOES *c = (struct qemu_glGetClipPlanexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetClipPlanexOES( c->plane, QEMU_G2H(c->equation) ));
}

#endif

struct qemu_glGetColorTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTable( GLenum target, GLenum format, GLenum type, void *table )
{
    struct qemu_glGetColorTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLE);
    call.target = target;
    call.format = format;
    call.type = type;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTable(struct qemu_syscall *call)
{
    struct qemu_glGetColorTable *c = (struct qemu_glGetColorTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTable( c->target, c->format, c->type, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glGetColorTableEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableEXT( GLenum target, GLenum format, GLenum type, void *data )
{
    struct qemu_glGetColorTableEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEEXT);
    call.target = target;
    call.format = format;
    call.type = type;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableEXT(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableEXT *c = (struct qemu_glGetColorTableEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableEXT( c->target, c->format, c->type, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetColorTableParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetColorTableParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameterfv *c = (struct qemu_glGetColorTableParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetColorTableParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameterfvEXT *c = (struct qemu_glGetColorTableParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableParameterfvSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameterfvSGI( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetColorTableParameterfvSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERFVSGI);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameterfvSGI(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameterfvSGI *c = (struct qemu_glGetColorTableParameterfvSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameterfvSGI( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetColorTableParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameteriv *c = (struct qemu_glGetColorTableParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetColorTableParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameterivEXT *c = (struct qemu_glGetColorTableParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableParameterivSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableParameterivSGI( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetColorTableParameterivSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLEPARAMETERIVSGI);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableParameterivSGI(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableParameterivSGI *c = (struct qemu_glGetColorTableParameterivSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableParameterivSGI( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetColorTableSGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetColorTableSGI( GLenum target, GLenum format, GLenum type, void *table )
{
    struct qemu_glGetColorTableSGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOLORTABLESGI);
    call.target = target;
    call.format = format;
    call.type = type;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetColorTableSGI(struct qemu_syscall *call)
{
    struct qemu_glGetColorTableSGI *c = (struct qemu_glGetColorTableSGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetColorTableSGI( c->target, c->format, c->type, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glGetCombinerInputParameterfvNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t variable;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCombinerInputParameterfvNV( GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params )
{
    struct qemu_glGetCombinerInputParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMBINERINPUTPARAMETERFVNV);
    call.stage = stage;
    call.portion = portion;
    call.variable = variable;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCombinerInputParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetCombinerInputParameterfvNV *c = (struct qemu_glGetCombinerInputParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCombinerInputParameterfvNV( c->stage, c->portion, c->variable, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCombinerInputParameterivNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t variable;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCombinerInputParameterivNV( GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params )
{
    struct qemu_glGetCombinerInputParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMBINERINPUTPARAMETERIVNV);
    call.stage = stage;
    call.portion = portion;
    call.variable = variable;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCombinerInputParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetCombinerInputParameterivNV *c = (struct qemu_glGetCombinerInputParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCombinerInputParameterivNV( c->stage, c->portion, c->variable, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCombinerOutputParameterfvNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCombinerOutputParameterfvNV( GLenum stage, GLenum portion, GLenum pname, GLfloat *params )
{
    struct qemu_glGetCombinerOutputParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMBINEROUTPUTPARAMETERFVNV);
    call.stage = stage;
    call.portion = portion;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCombinerOutputParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetCombinerOutputParameterfvNV *c = (struct qemu_glGetCombinerOutputParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCombinerOutputParameterfvNV( c->stage, c->portion, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCombinerOutputParameterivNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t portion;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCombinerOutputParameterivNV( GLenum stage, GLenum portion, GLenum pname, GLint *params )
{
    struct qemu_glGetCombinerOutputParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMBINEROUTPUTPARAMETERIVNV);
    call.stage = stage;
    call.portion = portion;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCombinerOutputParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetCombinerOutputParameterivNV *c = (struct qemu_glGetCombinerOutputParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCombinerOutputParameterivNV( c->stage, c->portion, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCombinerStageParameterfvNV
{
    struct qemu_syscall super;
    uint64_t stage;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCombinerStageParameterfvNV( GLenum stage, GLenum pname, GLfloat *params )
{
    struct qemu_glGetCombinerStageParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMBINERSTAGEPARAMETERFVNV);
    call.stage = stage;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCombinerStageParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetCombinerStageParameterfvNV *c = (struct qemu_glGetCombinerStageParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCombinerStageParameterfvNV( c->stage, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCommandHeaderNV
{
    struct qemu_syscall super;
    uint64_t tokenID;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetCommandHeaderNV( GLenum tokenID, GLuint size )
{
    struct qemu_glGetCommandHeaderNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMMANDHEADERNV);
    call.tokenID = tokenID;
    call.size = size;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetCommandHeaderNV(struct qemu_syscall *call)
{
    struct qemu_glGetCommandHeaderNV *c = (struct qemu_glGetCommandHeaderNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetCommandHeaderNV( c->tokenID, c->size ));
}

#endif

struct qemu_glGetCompressedMultiTexImageEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t lod;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedMultiTexImageEXT( GLenum texunit, GLenum target, GLint lod, void *img )
{
    struct qemu_glGetCompressedMultiTexImageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDMULTITEXIMAGEEXT);
    call.texunit = texunit;
    call.target = target;
    call.lod = lod;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedMultiTexImageEXT(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedMultiTexImageEXT *c = (struct qemu_glGetCompressedMultiTexImageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedMultiTexImageEXT( c->texunit, c->target, c->lod, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetCompressedTexImage
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedTexImage( GLenum target, GLint level, void *img )
{
    struct qemu_glGetCompressedTexImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDTEXIMAGE);
    call.target = target;
    call.level = level;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedTexImage(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedTexImage *c = (struct qemu_glGetCompressedTexImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedTexImage( c->target, c->level, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetCompressedTexImageARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedTexImageARB( GLenum target, GLint level, void *img )
{
    struct qemu_glGetCompressedTexImageARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDTEXIMAGEARB);
    call.target = target;
    call.level = level;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedTexImageARB(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedTexImageARB *c = (struct qemu_glGetCompressedTexImageARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedTexImageARB( c->target, c->level, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetCompressedTextureImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedTextureImage( GLuint texture, GLint level, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetCompressedTextureImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDTEXTUREIMAGE);
    call.texture = texture;
    call.level = level;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedTextureImage(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedTextureImage *c = (struct qemu_glGetCompressedTextureImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedTextureImage( c->texture, c->level, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetCompressedTextureImageEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t lod;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedTextureImageEXT( GLuint texture, GLenum target, GLint lod, void *img )
{
    struct qemu_glGetCompressedTextureImageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDTEXTUREIMAGEEXT);
    call.texture = texture;
    call.target = target;
    call.lod = lod;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedTextureImageEXT(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedTextureImageEXT *c = (struct qemu_glGetCompressedTextureImageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedTextureImageEXT( c->texture, c->target, c->lod, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetCompressedTextureSubImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCompressedTextureSubImage( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetCompressedTextureSubImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOMPRESSEDTEXTURESUBIMAGE);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCompressedTextureSubImage(struct qemu_syscall *call)
{
    struct qemu_glGetCompressedTextureSubImage *c = (struct qemu_glGetCompressedTextureSubImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCompressedTextureSubImage( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetConvolutionFilter
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionFilter( GLenum target, GLenum format, GLenum type, void *image )
{
    struct qemu_glGetConvolutionFilter call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONFILTER);
    call.target = target;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionFilter(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionFilter *c = (struct qemu_glGetConvolutionFilter *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionFilter( c->target, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glGetConvolutionFilterEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionFilterEXT( GLenum target, GLenum format, GLenum type, void *image )
{
    struct qemu_glGetConvolutionFilterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONFILTEREXT);
    call.target = target;
    call.format = format;
    call.type = type;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionFilterEXT(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionFilterEXT *c = (struct qemu_glGetConvolutionFilterEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionFilterEXT( c->target, c->format, c->type, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glGetConvolutionParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetConvolutionParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionParameterfv *c = (struct qemu_glGetConvolutionParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetConvolutionParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionParameterfvEXT( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetConvolutionParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionParameterfvEXT *c = (struct qemu_glGetConvolutionParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetConvolutionParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetConvolutionParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionParameteriv *c = (struct qemu_glGetConvolutionParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetConvolutionParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetConvolutionParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionParameterivEXT *c = (struct qemu_glGetConvolutionParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetConvolutionParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetConvolutionParameterxvOES( GLenum target, GLenum pname, GLfixed *params )
{
    struct qemu_glGetConvolutionParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCONVOLUTIONPARAMETERXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetConvolutionParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetConvolutionParameterxvOES *c = (struct qemu_glGetConvolutionParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetConvolutionParameterxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetCoverageModulationTableNV
{
    struct qemu_syscall super;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetCoverageModulationTableNV( GLsizei bufSize, GLfloat *v )
{
    struct qemu_glGetCoverageModulationTableNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETCOVERAGEMODULATIONTABLENV);
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetCoverageModulationTableNV(struct qemu_syscall *call)
{
    struct qemu_glGetCoverageModulationTableNV *c = (struct qemu_glGetCoverageModulationTableNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetCoverageModulationTableNV( c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetDebugMessageLog
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t bufSize;
    uint64_t sources;
    uint64_t types;
    uint64_t ids;
    uint64_t severities;
    uint64_t lengths;
    uint64_t messageLog;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetDebugMessageLog( GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog )
{
    struct qemu_glGetDebugMessageLog call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDEBUGMESSAGELOG);
    call.count = count;
    call.bufSize = bufSize;
    call.sources = (ULONG_PTR)sources;
    call.types = (ULONG_PTR)types;
    call.ids = (ULONG_PTR)ids;
    call.severities = (ULONG_PTR)severities;
    call.lengths = (ULONG_PTR)lengths;
    call.messageLog = (ULONG_PTR)messageLog;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetDebugMessageLog(struct qemu_syscall *call)
{
    struct qemu_glGetDebugMessageLog *c = (struct qemu_glGetDebugMessageLog *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetDebugMessageLog( c->count, c->bufSize, QEMU_G2H(c->sources), QEMU_G2H(c->types), QEMU_G2H(c->ids), QEMU_G2H(c->severities), QEMU_G2H(c->lengths), QEMU_G2H(c->messageLog) ));
}

#endif

struct qemu_glGetDebugMessageLogAMD
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t bufSize;
    uint64_t categories;
    uint64_t severities;
    uint64_t ids;
    uint64_t lengths;
    uint64_t message;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetDebugMessageLogAMD( GLuint count, GLsizei bufSize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message )
{
    struct qemu_glGetDebugMessageLogAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDEBUGMESSAGELOGAMD);
    call.count = count;
    call.bufSize = bufSize;
    call.categories = (ULONG_PTR)categories;
    call.severities = (ULONG_PTR)severities;
    call.ids = (ULONG_PTR)ids;
    call.lengths = (ULONG_PTR)lengths;
    call.message = (ULONG_PTR)message;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetDebugMessageLogAMD(struct qemu_syscall *call)
{
    struct qemu_glGetDebugMessageLogAMD *c = (struct qemu_glGetDebugMessageLogAMD *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetDebugMessageLogAMD( c->count, c->bufSize, QEMU_G2H(c->categories), QEMU_G2H(c->severities), QEMU_G2H(c->ids), QEMU_G2H(c->lengths), QEMU_G2H(c->message) ));
}

#endif

struct qemu_glGetDebugMessageLogARB
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t bufSize;
    uint64_t sources;
    uint64_t types;
    uint64_t ids;
    uint64_t severities;
    uint64_t lengths;
    uint64_t messageLog;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetDebugMessageLogARB( GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog )
{
    struct qemu_glGetDebugMessageLogARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDEBUGMESSAGELOGARB);
    call.count = count;
    call.bufSize = bufSize;
    call.sources = (ULONG_PTR)sources;
    call.types = (ULONG_PTR)types;
    call.ids = (ULONG_PTR)ids;
    call.severities = (ULONG_PTR)severities;
    call.lengths = (ULONG_PTR)lengths;
    call.messageLog = (ULONG_PTR)messageLog;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetDebugMessageLogARB(struct qemu_syscall *call)
{
    struct qemu_glGetDebugMessageLogARB *c = (struct qemu_glGetDebugMessageLogARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetDebugMessageLogARB( c->count, c->bufSize, QEMU_G2H(c->sources), QEMU_G2H(c->types), QEMU_G2H(c->ids), QEMU_G2H(c->severities), QEMU_G2H(c->lengths), QEMU_G2H(c->messageLog) ));
}

#endif

struct qemu_glGetDetailTexFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetDetailTexFuncSGIS( GLenum target, GLfloat *points )
{
    struct qemu_glGetDetailTexFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDETAILTEXFUNCSGIS);
    call.target = target;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetDetailTexFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetDetailTexFuncSGIS *c = (struct qemu_glGetDetailTexFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetDetailTexFuncSGIS( c->target, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glGetDoubleIndexedvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetDoubleIndexedvEXT( GLenum target, GLuint index, GLdouble *data )
{
    struct qemu_glGetDoubleIndexedvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDOUBLEINDEXEDVEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetDoubleIndexedvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetDoubleIndexedvEXT *c = (struct qemu_glGetDoubleIndexedvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetDoubleIndexedvEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetDoublei_v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetDoublei_v( GLenum target, GLuint index, GLdouble *data )
{
    struct qemu_glGetDoublei_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDOUBLEI_V);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetDoublei_v(struct qemu_syscall *call)
{
    struct qemu_glGetDoublei_v *c = (struct qemu_glGetDoublei_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetDoublei_v( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetDoublei_vEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetDoublei_vEXT( GLenum pname, GLuint index, GLdouble *params )
{
    struct qemu_glGetDoublei_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETDOUBLEI_VEXT);
    call.pname = pname;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetDoublei_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetDoublei_vEXT *c = (struct qemu_glGetDoublei_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetDoublei_vEXT( c->pname, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFenceivNV
{
    struct qemu_syscall super;
    uint64_t fence;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFenceivNV( GLuint fence, GLenum pname, GLint *params )
{
    struct qemu_glGetFenceivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFENCEIVNV);
    call.fence = fence;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFenceivNV(struct qemu_syscall *call)
{
    struct qemu_glGetFenceivNV *c = (struct qemu_glGetFenceivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFenceivNV( c->fence, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFinalCombinerInputParameterfvNV
{
    struct qemu_syscall super;
    uint64_t variable;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFinalCombinerInputParameterfvNV( GLenum variable, GLenum pname, GLfloat *params )
{
    struct qemu_glGetFinalCombinerInputParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFINALCOMBINERINPUTPARAMETERFVNV);
    call.variable = variable;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFinalCombinerInputParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetFinalCombinerInputParameterfvNV *c = (struct qemu_glGetFinalCombinerInputParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFinalCombinerInputParameterfvNV( c->variable, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFinalCombinerInputParameterivNV
{
    struct qemu_syscall super;
    uint64_t variable;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFinalCombinerInputParameterivNV( GLenum variable, GLenum pname, GLint *params )
{
    struct qemu_glGetFinalCombinerInputParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFINALCOMBINERINPUTPARAMETERIVNV);
    call.variable = variable;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFinalCombinerInputParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetFinalCombinerInputParameterivNV *c = (struct qemu_glGetFinalCombinerInputParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFinalCombinerInputParameterivNV( c->variable, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFirstPerfQueryIdINTEL
{
    struct qemu_syscall super;
    uint64_t queryId;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFirstPerfQueryIdINTEL( GLuint *queryId )
{
    struct qemu_glGetFirstPerfQueryIdINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFIRSTPERFQUERYIDINTEL);
    call.queryId = (ULONG_PTR)queryId;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFirstPerfQueryIdINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetFirstPerfQueryIdINTEL *c = (struct qemu_glGetFirstPerfQueryIdINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFirstPerfQueryIdINTEL( QEMU_G2H(c->queryId) ));
}

#endif

struct qemu_glGetFixedvOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFixedvOES( GLenum pname, GLfixed *params )
{
    struct qemu_glGetFixedvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFIXEDVOES);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFixedvOES(struct qemu_syscall *call)
{
    struct qemu_glGetFixedvOES *c = (struct qemu_glGetFixedvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFixedvOES( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFloatIndexedvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFloatIndexedvEXT( GLenum target, GLuint index, GLfloat *data )
{
    struct qemu_glGetFloatIndexedvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFLOATINDEXEDVEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFloatIndexedvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetFloatIndexedvEXT *c = (struct qemu_glGetFloatIndexedvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFloatIndexedvEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetFloati_v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFloati_v( GLenum target, GLuint index, GLfloat *data )
{
    struct qemu_glGetFloati_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFLOATI_V);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFloati_v(struct qemu_syscall *call)
{
    struct qemu_glGetFloati_v *c = (struct qemu_glGetFloati_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFloati_v( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetFloati_vEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFloati_vEXT( GLenum pname, GLuint index, GLfloat *params )
{
    struct qemu_glGetFloati_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFLOATI_VEXT);
    call.pname = pname;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFloati_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetFloati_vEXT *c = (struct qemu_glGetFloati_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFloati_vEXT( c->pname, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFogFuncSGIS
{
    struct qemu_syscall super;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFogFuncSGIS( GLfloat *points )
{
    struct qemu_glGetFogFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFOGFUNCSGIS);
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFogFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetFogFuncSGIS *c = (struct qemu_glGetFogFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFogFuncSGIS( QEMU_G2H(c->points) ));
}

#endif

struct qemu_glGetFragDataIndex
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetFragDataIndex( GLuint program, const GLchar *name )
{
    struct qemu_glGetFragDataIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGDATAINDEX);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetFragDataIndex(struct qemu_syscall *call)
{
    struct qemu_glGetFragDataIndex *c = (struct qemu_glGetFragDataIndex *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetFragDataIndex( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetFragDataLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetFragDataLocation( GLuint program, const GLchar *name )
{
    struct qemu_glGetFragDataLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGDATALOCATION);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetFragDataLocation(struct qemu_syscall *call)
{
    struct qemu_glGetFragDataLocation *c = (struct qemu_glGetFragDataLocation *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetFragDataLocation( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetFragDataLocationEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetFragDataLocationEXT( GLuint program, const GLchar *name )
{
    struct qemu_glGetFragDataLocationEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGDATALOCATIONEXT);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetFragDataLocationEXT(struct qemu_syscall *call)
{
    struct qemu_glGetFragDataLocationEXT *c = (struct qemu_glGetFragDataLocationEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetFragDataLocationEXT( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetFragmentLightfvSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFragmentLightfvSGIX( GLenum light, GLenum pname, GLfloat *params )
{
    struct qemu_glGetFragmentLightfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGMENTLIGHTFVSGIX);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFragmentLightfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetFragmentLightfvSGIX *c = (struct qemu_glGetFragmentLightfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFragmentLightfvSGIX( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFragmentLightivSGIX
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFragmentLightivSGIX( GLenum light, GLenum pname, GLint *params )
{
    struct qemu_glGetFragmentLightivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGMENTLIGHTIVSGIX);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFragmentLightivSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetFragmentLightivSGIX *c = (struct qemu_glGetFragmentLightivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFragmentLightivSGIX( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFragmentMaterialfvSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFragmentMaterialfvSGIX( GLenum face, GLenum pname, GLfloat *params )
{
    struct qemu_glGetFragmentMaterialfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGMENTMATERIALFVSGIX);
    call.face = face;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFragmentMaterialfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetFragmentMaterialfvSGIX *c = (struct qemu_glGetFragmentMaterialfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFragmentMaterialfvSGIX( c->face, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFragmentMaterialivSGIX
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFragmentMaterialivSGIX( GLenum face, GLenum pname, GLint *params )
{
    struct qemu_glGetFragmentMaterialivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAGMENTMATERIALIVSGIX);
    call.face = face;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFragmentMaterialivSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetFragmentMaterialivSGIX *c = (struct qemu_glGetFragmentMaterialivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFragmentMaterialivSGIX( c->face, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFramebufferAttachmentParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferAttachmentParameteriv( GLenum target, GLenum attachment, GLenum pname, GLint *params )
{
    struct qemu_glGetFramebufferAttachmentParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV);
    call.target = target;
    call.attachment = attachment;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferAttachmentParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferAttachmentParameteriv *c = (struct qemu_glGetFramebufferAttachmentParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferAttachmentParameteriv( c->target, c->attachment, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFramebufferAttachmentParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t attachment;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferAttachmentParameterivEXT( GLenum target, GLenum attachment, GLenum pname, GLint *params )
{
    struct qemu_glGetFramebufferAttachmentParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT);
    call.target = target;
    call.attachment = attachment;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferAttachmentParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferAttachmentParameterivEXT *c = (struct qemu_glGetFramebufferAttachmentParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferAttachmentParameterivEXT( c->target, c->attachment, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFramebufferParameterfvAMD
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t numsamples;
    uint64_t pixelindex;
    uint64_t size;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferParameterfvAMD( GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values )
{
    struct qemu_glGetFramebufferParameterfvAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERPARAMETERFVAMD);
    call.target = target;
    call.pname = pname;
    call.numsamples = numsamples;
    call.pixelindex = pixelindex;
    call.size = size;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferParameterfvAMD(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferParameterfvAMD *c = (struct qemu_glGetFramebufferParameterfvAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferParameterfvAMD( c->target, c->pname, c->numsamples, c->pixelindex, c->size, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetFramebufferParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetFramebufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferParameteriv *c = (struct qemu_glGetFramebufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFramebufferParameterivEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferParameterivEXT( GLuint framebuffer, GLenum pname, GLint *params )
{
    struct qemu_glGetFramebufferParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERPARAMETERIVEXT);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferParameterivEXT *c = (struct qemu_glGetFramebufferParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferParameterivEXT( c->framebuffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetFramebufferParameterivMESA
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetFramebufferParameterivMESA( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetFramebufferParameterivMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETFRAMEBUFFERPARAMETERIVMESA);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetFramebufferParameterivMESA(struct qemu_syscall *call)
{
    struct qemu_glGetFramebufferParameterivMESA *c = (struct qemu_glGetFramebufferParameterivMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetFramebufferParameterivMESA( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetGraphicsResetStatus
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glGetGraphicsResetStatus(void)
{
    struct qemu_glGetGraphicsResetStatus call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETGRAPHICSRESETSTATUS);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetGraphicsResetStatus(struct qemu_syscall *call)
{
    struct qemu_glGetGraphicsResetStatus *c = (struct qemu_glGetGraphicsResetStatus *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetGraphicsResetStatus());
}

#endif

struct qemu_glGetGraphicsResetStatusARB
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glGetGraphicsResetStatusARB(void)
{
    struct qemu_glGetGraphicsResetStatusARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETGRAPHICSRESETSTATUSARB);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetGraphicsResetStatusARB(struct qemu_syscall *call)
{
    struct qemu_glGetGraphicsResetStatusARB *c = (struct qemu_glGetGraphicsResetStatusARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetGraphicsResetStatusARB());
}

#endif

struct qemu_glGetHandleARB
{
    struct qemu_syscall super;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

GLhandleARB WINAPI glGetHandleARB( GLenum pname )
{
    struct qemu_glGetHandleARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHANDLEARB);
    call.pname = pname;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetHandleARB(struct qemu_syscall *call)
{
    struct qemu_glGetHandleARB *c = (struct qemu_glGetHandleARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetHandleARB( c->pname ));
}

#endif

struct qemu_glGetHistogram
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogram( GLenum target, GLboolean reset, GLenum format, GLenum type, void *values )
{
    struct qemu_glGetHistogram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAM);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogram(struct qemu_syscall *call)
{
    struct qemu_glGetHistogram *c = (struct qemu_glGetHistogram *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogram( c->target, c->reset, c->format, c->type, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetHistogramEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramEXT( GLenum target, GLboolean reset, GLenum format, GLenum type, void *values )
{
    struct qemu_glGetHistogramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMEXT);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramEXT(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramEXT *c = (struct qemu_glGetHistogramEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramEXT( c->target, c->reset, c->format, c->type, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetHistogramParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetHistogramParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramParameterfv *c = (struct qemu_glGetHistogramParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetHistogramParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramParameterfvEXT( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetHistogramParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramParameterfvEXT *c = (struct qemu_glGetHistogramParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetHistogramParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetHistogramParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramParameteriv *c = (struct qemu_glGetHistogramParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetHistogramParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetHistogramParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramParameterivEXT *c = (struct qemu_glGetHistogramParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetHistogramParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetHistogramParameterxvOES( GLenum target, GLenum pname, GLfixed *params )
{
    struct qemu_glGetHistogramParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETHISTOGRAMPARAMETERXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetHistogramParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetHistogramParameterxvOES *c = (struct qemu_glGetHistogramParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetHistogramParameterxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetImageHandleARB
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t layered;
    uint64_t layer;
    uint64_t format;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetImageHandleARB( GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format )
{
    struct qemu_glGetImageHandleARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETIMAGEHANDLEARB);
    call.texture = texture;
    call.level = level;
    call.layered = layered;
    call.layer = layer;
    call.format = format;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetImageHandleARB(struct qemu_syscall *call)
{
    struct qemu_glGetImageHandleARB *c = (struct qemu_glGetImageHandleARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetImageHandleARB( c->texture, c->level, c->layered, c->layer, c->format ));
}

#endif

struct qemu_glGetImageHandleNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t layered;
    uint64_t layer;
    uint64_t format;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetImageHandleNV( GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format )
{
    struct qemu_glGetImageHandleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETIMAGEHANDLENV);
    call.texture = texture;
    call.level = level;
    call.layered = layered;
    call.layer = layer;
    call.format = format;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetImageHandleNV(struct qemu_syscall *call)
{
    struct qemu_glGetImageHandleNV *c = (struct qemu_glGetImageHandleNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetImageHandleNV( c->texture, c->level, c->layered, c->layer, c->format ));
}

#endif

struct qemu_glGetImageTransformParameterfvHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetImageTransformParameterfvHP( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetImageTransformParameterfvHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETIMAGETRANSFORMPARAMETERFVHP);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetImageTransformParameterfvHP(struct qemu_syscall *call)
{
    struct qemu_glGetImageTransformParameterfvHP *c = (struct qemu_glGetImageTransformParameterfvHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetImageTransformParameterfvHP( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetImageTransformParameterivHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetImageTransformParameterivHP( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetImageTransformParameterivHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETIMAGETRANSFORMPARAMETERIVHP);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetImageTransformParameterivHP(struct qemu_syscall *call)
{
    struct qemu_glGetImageTransformParameterivHP *c = (struct qemu_glGetImageTransformParameterivHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetImageTransformParameterivHP( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetInfoLogARB
{
    struct qemu_syscall super;
    uint64_t obj;
    uint64_t maxLength;
    uint64_t length;
    uint64_t infoLog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInfoLogARB( GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog )
{
    struct qemu_glGetInfoLogARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINFOLOGARB);
    call.obj = obj;
    call.maxLength = maxLength;
    call.length = (ULONG_PTR)length;
    call.infoLog = (ULONG_PTR)infoLog;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInfoLogARB(struct qemu_syscall *call)
{
    struct qemu_glGetInfoLogARB *c = (struct qemu_glGetInfoLogARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInfoLogARB( c->obj, c->maxLength, QEMU_G2H(c->length), QEMU_G2H(c->infoLog) ));
}

#endif

struct qemu_glGetInstrumentsSGIX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetInstrumentsSGIX(void)
{
    struct qemu_glGetInstrumentsSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINSTRUMENTSSGIX);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetInstrumentsSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetInstrumentsSGIX *c = (struct qemu_glGetInstrumentsSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetInstrumentsSGIX());
}

#endif

struct qemu_glGetInteger64i_v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInteger64i_v( GLenum target, GLuint index, GLint64 *data )
{
    struct qemu_glGetInteger64i_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGER64I_V);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInteger64i_v(struct qemu_syscall *call)
{
    struct qemu_glGetInteger64i_v *c = (struct qemu_glGetInteger64i_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInteger64i_v( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetInteger64v
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInteger64v( GLenum pname, GLint64 *data )
{
    struct qemu_glGetInteger64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGER64V);
    call.pname = pname;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInteger64v(struct qemu_syscall *call)
{
    struct qemu_glGetInteger64v *c = (struct qemu_glGetInteger64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInteger64v( c->pname, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetIntegerIndexedvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetIntegerIndexedvEXT( GLenum target, GLuint index, GLint *data )
{
    struct qemu_glGetIntegerIndexedvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGERINDEXEDVEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetIntegerIndexedvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetIntegerIndexedvEXT *c = (struct qemu_glGetIntegerIndexedvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetIntegerIndexedvEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetIntegeri_v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetIntegeri_v( GLenum target, GLuint index, GLint *data )
{
    struct qemu_glGetIntegeri_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGERI_V);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetIntegeri_v(struct qemu_syscall *call)
{
    struct qemu_glGetIntegeri_v *c = (struct qemu_glGetIntegeri_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetIntegeri_v( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetIntegerui64i_vNV
{
    struct qemu_syscall super;
    uint64_t value;
    uint64_t index;
    uint64_t result;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetIntegerui64i_vNV( GLenum value, GLuint index, GLuint64EXT *result )
{
    struct qemu_glGetIntegerui64i_vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGERUI64I_VNV);
    call.value = value;
    call.index = index;
    call.result = (ULONG_PTR)result;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetIntegerui64i_vNV(struct qemu_syscall *call)
{
    struct qemu_glGetIntegerui64i_vNV *c = (struct qemu_glGetIntegerui64i_vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetIntegerui64i_vNV( c->value, c->index, QEMU_G2H(c->result) ));
}

#endif

struct qemu_glGetIntegerui64vNV
{
    struct qemu_syscall super;
    uint64_t value;
    uint64_t result;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetIntegerui64vNV( GLenum value, GLuint64EXT *result )
{
    struct qemu_glGetIntegerui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTEGERUI64VNV);
    call.value = value;
    call.result = (ULONG_PTR)result;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetIntegerui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetIntegerui64vNV *c = (struct qemu_glGetIntegerui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetIntegerui64vNV( c->value, QEMU_G2H(c->result) ));
}

#endif

struct qemu_glGetInternalformatSampleivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t samples;
    uint64_t pname;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInternalformatSampleivNV( GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint *params )
{
    struct qemu_glGetInternalformatSampleivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTERNALFORMATSAMPLEIVNV);
    call.target = target;
    call.internalformat = internalformat;
    call.samples = samples;
    call.pname = pname;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInternalformatSampleivNV(struct qemu_syscall *call)
{
    struct qemu_glGetInternalformatSampleivNV *c = (struct qemu_glGetInternalformatSampleivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInternalformatSampleivNV( c->target, c->internalformat, c->samples, c->pname, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetInternalformati64v
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t pname;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInternalformati64v( GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params )
{
    struct qemu_glGetInternalformati64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTERNALFORMATI64V);
    call.target = target;
    call.internalformat = internalformat;
    call.pname = pname;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInternalformati64v(struct qemu_syscall *call)
{
    struct qemu_glGetInternalformati64v *c = (struct qemu_glGetInternalformati64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInternalformati64v( c->target, c->internalformat, c->pname, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetInternalformativ
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t pname;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInternalformativ( GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params )
{
    struct qemu_glGetInternalformativ call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINTERNALFORMATIV);
    call.target = target;
    call.internalformat = internalformat;
    call.pname = pname;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInternalformativ(struct qemu_syscall *call)
{
    struct qemu_glGetInternalformativ *c = (struct qemu_glGetInternalformativ *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInternalformativ( c->target, c->internalformat, c->pname, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetInvariantBooleanvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInvariantBooleanvEXT( GLuint id, GLenum value, GLboolean *data )
{
    struct qemu_glGetInvariantBooleanvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINVARIANTBOOLEANVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInvariantBooleanvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetInvariantBooleanvEXT *c = (struct qemu_glGetInvariantBooleanvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInvariantBooleanvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetInvariantFloatvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInvariantFloatvEXT( GLuint id, GLenum value, GLfloat *data )
{
    struct qemu_glGetInvariantFloatvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINVARIANTFLOATVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInvariantFloatvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetInvariantFloatvEXT *c = (struct qemu_glGetInvariantFloatvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInvariantFloatvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetInvariantIntegervEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetInvariantIntegervEXT( GLuint id, GLenum value, GLint *data )
{
    struct qemu_glGetInvariantIntegervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETINVARIANTINTEGERVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetInvariantIntegervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetInvariantIntegervEXT *c = (struct qemu_glGetInvariantIntegervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetInvariantIntegervEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetLightxOES
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetLightxOES( GLenum light, GLenum pname, GLfixed *params )
{
    struct qemu_glGetLightxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLIGHTXOES);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetLightxOES(struct qemu_syscall *call)
{
    struct qemu_glGetLightxOES *c = (struct qemu_glGetLightxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetLightxOES( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetListParameterfvSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetListParameterfvSGIX( GLuint list, GLenum pname, GLfloat *params )
{
    struct qemu_glGetListParameterfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLISTPARAMETERFVSGIX);
    call.list = list;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetListParameterfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetListParameterfvSGIX *c = (struct qemu_glGetListParameterfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetListParameterfvSGIX( c->list, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetListParameterivSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetListParameterivSGIX( GLuint list, GLenum pname, GLint *params )
{
    struct qemu_glGetListParameterivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLISTPARAMETERIVSGIX);
    call.list = list;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetListParameterivSGIX(struct qemu_syscall *call)
{
    struct qemu_glGetListParameterivSGIX *c = (struct qemu_glGetListParameterivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetListParameterivSGIX( c->list, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetLocalConstantBooleanvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetLocalConstantBooleanvEXT( GLuint id, GLenum value, GLboolean *data )
{
    struct qemu_glGetLocalConstantBooleanvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLOCALCONSTANTBOOLEANVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetLocalConstantBooleanvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetLocalConstantBooleanvEXT *c = (struct qemu_glGetLocalConstantBooleanvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetLocalConstantBooleanvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetLocalConstantFloatvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetLocalConstantFloatvEXT( GLuint id, GLenum value, GLfloat *data )
{
    struct qemu_glGetLocalConstantFloatvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLOCALCONSTANTFLOATVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetLocalConstantFloatvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetLocalConstantFloatvEXT *c = (struct qemu_glGetLocalConstantFloatvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetLocalConstantFloatvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetLocalConstantIntegervEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetLocalConstantIntegervEXT( GLuint id, GLenum value, GLint *data )
{
    struct qemu_glGetLocalConstantIntegervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETLOCALCONSTANTINTEGERVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetLocalConstantIntegervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetLocalConstantIntegervEXT *c = (struct qemu_glGetLocalConstantIntegervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetLocalConstantIntegervEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetMapAttribParameterfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapAttribParameterfvNV( GLenum target, GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMapAttribParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPATTRIBPARAMETERFVNV);
    call.target = target;
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapAttribParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetMapAttribParameterfvNV *c = (struct qemu_glGetMapAttribParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapAttribParameterfvNV( c->target, c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMapAttribParameterivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapAttribParameterivNV( GLenum target, GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetMapAttribParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPATTRIBPARAMETERIVNV);
    call.target = target;
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapAttribParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetMapAttribParameterivNV *c = (struct qemu_glGetMapAttribParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapAttribParameterivNV( c->target, c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMapControlPointsNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t type;
    uint64_t ustride;
    uint64_t vstride;
    uint64_t packed;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapControlPointsNV( GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points )
{
    struct qemu_glGetMapControlPointsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPCONTROLPOINTSNV);
    call.target = target;
    call.index = index;
    call.type = type;
    call.ustride = ustride;
    call.vstride = vstride;
    call.packed = packed;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapControlPointsNV(struct qemu_syscall *call)
{
    struct qemu_glGetMapControlPointsNV *c = (struct qemu_glGetMapControlPointsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapControlPointsNV( c->target, c->index, c->type, c->ustride, c->vstride, c->packed, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glGetMapParameterfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapParameterfvNV( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMapParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPPARAMETERFVNV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetMapParameterfvNV *c = (struct qemu_glGetMapParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapParameterfvNV( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMapParameterivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapParameterivNV( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMapParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPPARAMETERIVNV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetMapParameterivNV *c = (struct qemu_glGetMapParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapParameterivNV( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMapxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMapxvOES( GLenum target, GLenum query, GLfixed *v )
{
    struct qemu_glGetMapxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMAPXVOES);
    call.target = target;
    call.query = query;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMapxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetMapxvOES *c = (struct qemu_glGetMapxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMapxvOES( c->target, c->query, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetMaterialxOES
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMaterialxOES( GLenum face, GLenum pname, GLfixed param )
{
    struct qemu_glGetMaterialxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMATERIALXOES);
    call.face = face;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMaterialxOES(struct qemu_syscall *call)
{
    struct qemu_glGetMaterialxOES *c = (struct qemu_glGetMaterialxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMaterialxOES( c->face, c->pname, c->param ));
}

#endif

struct qemu_glGetMemoryObjectDetachedResourcesuivNV
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t pname;
    uint64_t first;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMemoryObjectDetachedResourcesuivNV( GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint *params )
{
    struct qemu_glGetMemoryObjectDetachedResourcesuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMEMORYOBJECTDETACHEDRESOURCESUIVNV);
    call.memory = memory;
    call.pname = pname;
    call.first = first;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMemoryObjectDetachedResourcesuivNV(struct qemu_syscall *call)
{
    struct qemu_glGetMemoryObjectDetachedResourcesuivNV *c = (struct qemu_glGetMemoryObjectDetachedResourcesuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMemoryObjectDetachedResourcesuivNV( c->memory, c->pname, c->first, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMemoryObjectParameterivEXT
{
    struct qemu_syscall super;
    uint64_t memoryObject;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMemoryObjectParameterivEXT( GLuint memoryObject, GLenum pname, GLint *params )
{
    struct qemu_glGetMemoryObjectParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMEMORYOBJECTPARAMETERIVEXT);
    call.memoryObject = memoryObject;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMemoryObjectParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMemoryObjectParameterivEXT *c = (struct qemu_glGetMemoryObjectParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMemoryObjectParameterivEXT( c->memoryObject, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMinmax
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmax( GLenum target, GLboolean reset, GLenum format, GLenum type, void *values )
{
    struct qemu_glGetMinmax call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAX);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmax(struct qemu_syscall *call)
{
    struct qemu_glGetMinmax *c = (struct qemu_glGetMinmax *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmax( c->target, c->reset, c->format, c->type, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetMinmaxEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmaxEXT( GLenum target, GLboolean reset, GLenum format, GLenum type, void *values )
{
    struct qemu_glGetMinmaxEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAXEXT);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmaxEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMinmaxEXT *c = (struct qemu_glGetMinmaxEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmaxEXT( c->target, c->reset, c->format, c->type, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetMinmaxParameterfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmaxParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMinmaxParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAXPARAMETERFV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmaxParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetMinmaxParameterfv *c = (struct qemu_glGetMinmaxParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmaxParameterfv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMinmaxParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmaxParameterfvEXT( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMinmaxParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAXPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmaxParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMinmaxParameterfvEXT *c = (struct qemu_glGetMinmaxParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmaxParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMinmaxParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmaxParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMinmaxParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAXPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmaxParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetMinmaxParameteriv *c = (struct qemu_glGetMinmaxParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmaxParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMinmaxParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMinmaxParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMinmaxParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMINMAXPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMinmaxParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMinmaxParameterivEXT *c = (struct qemu_glGetMinmaxParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMinmaxParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexEnvfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexEnvfvEXT( GLenum texunit, GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMultiTexEnvfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXENVFVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexEnvfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexEnvfvEXT *c = (struct qemu_glGetMultiTexEnvfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexEnvfvEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexEnvivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexEnvivEXT( GLenum texunit, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMultiTexEnvivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXENVIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexEnvivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexEnvivEXT *c = (struct qemu_glGetMultiTexEnvivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexEnvivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexGendvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexGendvEXT( GLenum texunit, GLenum coord, GLenum pname, GLdouble *params )
{
    struct qemu_glGetMultiTexGendvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXGENDVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexGendvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexGendvEXT *c = (struct qemu_glGetMultiTexGendvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexGendvEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexGenfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexGenfvEXT( GLenum texunit, GLenum coord, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMultiTexGenfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXGENFVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexGenfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexGenfvEXT *c = (struct qemu_glGetMultiTexGenfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexGenfvEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexGenivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexGenivEXT( GLenum texunit, GLenum coord, GLenum pname, GLint *params )
{
    struct qemu_glGetMultiTexGenivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXGENIVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexGenivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexGenivEXT *c = (struct qemu_glGetMultiTexGenivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexGenivEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexImageEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexImageEXT( GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels )
{
    struct qemu_glGetMultiTexImageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXIMAGEEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexImageEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexImageEXT *c = (struct qemu_glGetMultiTexImageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexImageEXT( c->texunit, c->target, c->level, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetMultiTexLevelParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexLevelParameterfvEXT( GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMultiTexLevelParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXLEVELPARAMETERFVEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexLevelParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexLevelParameterfvEXT *c = (struct qemu_glGetMultiTexLevelParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexLevelParameterfvEXT( c->texunit, c->target, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexLevelParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexLevelParameterivEXT( GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params )
{
    struct qemu_glGetMultiTexLevelParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXLEVELPARAMETERIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexLevelParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexLevelParameterivEXT *c = (struct qemu_glGetMultiTexLevelParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexLevelParameterivEXT( c->texunit, c->target, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexParameterIivEXT( GLenum texunit, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMultiTexParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXPARAMETERIIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexParameterIivEXT *c = (struct qemu_glGetMultiTexParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexParameterIivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexParameterIuivEXT( GLenum texunit, GLenum target, GLenum pname, GLuint *params )
{
    struct qemu_glGetMultiTexParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXPARAMETERIUIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexParameterIuivEXT *c = (struct qemu_glGetMultiTexParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexParameterIuivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexParameterfvEXT( GLenum texunit, GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetMultiTexParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXPARAMETERFVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexParameterfvEXT *c = (struct qemu_glGetMultiTexParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexParameterfvEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultiTexParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultiTexParameterivEXT( GLenum texunit, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetMultiTexParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTITEXPARAMETERIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultiTexParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetMultiTexParameterivEXT *c = (struct qemu_glGetMultiTexParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultiTexParameterivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetMultisamplefv
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t val;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultisamplefv( GLenum pname, GLuint index, GLfloat *val )
{
    struct qemu_glGetMultisamplefv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTISAMPLEFV);
    call.pname = pname;
    call.index = index;
    call.val = (ULONG_PTR)val;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultisamplefv(struct qemu_syscall *call)
{
    struct qemu_glGetMultisamplefv *c = (struct qemu_glGetMultisamplefv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultisamplefv( c->pname, c->index, QEMU_G2H(c->val) ));
}

#endif

struct qemu_glGetMultisamplefvNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t val;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetMultisamplefvNV( GLenum pname, GLuint index, GLfloat *val )
{
    struct qemu_glGetMultisamplefvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETMULTISAMPLEFVNV);
    call.pname = pname;
    call.index = index;
    call.val = (ULONG_PTR)val;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetMultisamplefvNV(struct qemu_syscall *call)
{
    struct qemu_glGetMultisamplefvNV *c = (struct qemu_glGetMultisamplefvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetMultisamplefvNV( c->pname, c->index, QEMU_G2H(c->val) ));
}

#endif

struct qemu_glGetNamedBufferParameteri64v
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferParameteri64v( GLuint buffer, GLenum pname, GLint64 *params )
{
    struct qemu_glGetNamedBufferParameteri64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPARAMETERI64V);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferParameteri64v(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferParameteri64v *c = (struct qemu_glGetNamedBufferParameteri64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferParameteri64v( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferParameteriv
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferParameteriv( GLuint buffer, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedBufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPARAMETERIV);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferParameteriv *c = (struct qemu_glGetNamedBufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferParameteriv( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferParameterivEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferParameterivEXT( GLuint buffer, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedBufferParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPARAMETERIVEXT);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferParameterivEXT *c = (struct qemu_glGetNamedBufferParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferParameterivEXT( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferParameterui64vNV
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferParameterui64vNV( GLuint buffer, GLenum pname, GLuint64EXT *params )
{
    struct qemu_glGetNamedBufferParameterui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPARAMETERUI64VNV);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferParameterui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferParameterui64vNV *c = (struct qemu_glGetNamedBufferParameterui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferParameterui64vNV( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferPointerv
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferPointerv( GLuint buffer, GLenum pname, void **params )
{
    struct qemu_glGetNamedBufferPointerv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPOINTERV);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferPointerv(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferPointerv *c = (struct qemu_glGetNamedBufferPointerv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferPointerv( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferPointervEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferPointervEXT( GLuint buffer, GLenum pname, void **params )
{
    struct qemu_glGetNamedBufferPointervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERPOINTERVEXT);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferPointervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferPointervEXT *c = (struct qemu_glGetNamedBufferPointervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferPointervEXT( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedBufferSubData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferSubData( GLuint buffer, GLintptr offset, GLsizeiptr size, void *data )
{
    struct qemu_glGetNamedBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERSUBDATA);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferSubData *c = (struct qemu_glGetNamedBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferSubData( c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetNamedBufferSubDataEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedBufferSubDataEXT( GLuint buffer, GLintptr offset, GLsizeiptr size, void *data )
{
    struct qemu_glGetNamedBufferSubDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDBUFFERSUBDATAEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedBufferSubDataEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedBufferSubDataEXT *c = (struct qemu_glGetNamedBufferSubDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedBufferSubDataEXT( c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetNamedFramebufferAttachmentParameteriv
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedFramebufferAttachmentParameteriv( GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedFramebufferAttachmentParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIV);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedFramebufferAttachmentParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetNamedFramebufferAttachmentParameteriv *c = (struct qemu_glGetNamedFramebufferAttachmentParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedFramebufferAttachmentParameteriv( c->framebuffer, c->attachment, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedFramebufferAttachmentParameterivEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedFramebufferAttachmentParameterivEXT( GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedFramebufferAttachmentParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedFramebufferAttachmentParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedFramebufferAttachmentParameterivEXT *c = (struct qemu_glGetNamedFramebufferAttachmentParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedFramebufferAttachmentParameterivEXT( c->framebuffer, c->attachment, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedFramebufferParameterfvAMD
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t numsamples;
    uint64_t pixelindex;
    uint64_t size;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedFramebufferParameterfvAMD( GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values )
{
    struct qemu_glGetNamedFramebufferParameterfvAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDFRAMEBUFFERPARAMETERFVAMD);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.numsamples = numsamples;
    call.pixelindex = pixelindex;
    call.size = size;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedFramebufferParameterfvAMD(struct qemu_syscall *call)
{
    struct qemu_glGetNamedFramebufferParameterfvAMD *c = (struct qemu_glGetNamedFramebufferParameterfvAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedFramebufferParameterfvAMD( c->framebuffer, c->pname, c->numsamples, c->pixelindex, c->size, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetNamedFramebufferParameteriv
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedFramebufferParameteriv( GLuint framebuffer, GLenum pname, GLint *param )
{
    struct qemu_glGetNamedFramebufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDFRAMEBUFFERPARAMETERIV);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedFramebufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetNamedFramebufferParameteriv *c = (struct qemu_glGetNamedFramebufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedFramebufferParameteriv( c->framebuffer, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetNamedFramebufferParameterivEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedFramebufferParameterivEXT( GLuint framebuffer, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedFramebufferParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedFramebufferParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedFramebufferParameterivEXT *c = (struct qemu_glGetNamedFramebufferParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedFramebufferParameterivEXT( c->framebuffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedProgramLocalParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramLocalParameterIivEXT( GLuint program, GLenum target, GLuint index, GLint *params )
{
    struct qemu_glGetNamedProgramLocalParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramLocalParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramLocalParameterIivEXT *c = (struct qemu_glGetNamedProgramLocalParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramLocalParameterIivEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedProgramLocalParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramLocalParameterIuivEXT( GLuint program, GLenum target, GLuint index, GLuint *params )
{
    struct qemu_glGetNamedProgramLocalParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramLocalParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramLocalParameterIuivEXT *c = (struct qemu_glGetNamedProgramLocalParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramLocalParameterIuivEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedProgramLocalParameterdvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramLocalParameterdvEXT( GLuint program, GLenum target, GLuint index, GLdouble *params )
{
    struct qemu_glGetNamedProgramLocalParameterdvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramLocalParameterdvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramLocalParameterdvEXT *c = (struct qemu_glGetNamedProgramLocalParameterdvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramLocalParameterdvEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedProgramLocalParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramLocalParameterfvEXT( GLuint program, GLenum target, GLuint index, GLfloat *params )
{
    struct qemu_glGetNamedProgramLocalParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramLocalParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramLocalParameterfvEXT *c = (struct qemu_glGetNamedProgramLocalParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramLocalParameterfvEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedProgramStringEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t pname;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramStringEXT( GLuint program, GLenum target, GLenum pname, void *string )
{
    struct qemu_glGetNamedProgramStringEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMSTRINGEXT);
    call.program = program;
    call.target = target;
    call.pname = pname;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramStringEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramStringEXT *c = (struct qemu_glGetNamedProgramStringEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramStringEXT( c->program, c->target, c->pname, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glGetNamedProgramivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedProgramivEXT( GLuint program, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedProgramivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDPROGRAMIVEXT);
    call.program = program;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedProgramivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedProgramivEXT *c = (struct qemu_glGetNamedProgramivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedProgramivEXT( c->program, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedRenderbufferParameteriv
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedRenderbufferParameteriv( GLuint renderbuffer, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedRenderbufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDRENDERBUFFERPARAMETERIV);
    call.renderbuffer = renderbuffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedRenderbufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetNamedRenderbufferParameteriv *c = (struct qemu_glGetNamedRenderbufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedRenderbufferParameteriv( c->renderbuffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedRenderbufferParameterivEXT
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedRenderbufferParameterivEXT( GLuint renderbuffer, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedRenderbufferParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT);
    call.renderbuffer = renderbuffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedRenderbufferParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetNamedRenderbufferParameterivEXT *c = (struct qemu_glGetNamedRenderbufferParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedRenderbufferParameterivEXT( c->renderbuffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNamedStringARB
{
    struct qemu_syscall super;
    uint64_t namelen;
    uint64_t name;
    uint64_t bufSize;
    uint64_t stringlen;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedStringARB( GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string )
{
    struct qemu_glGetNamedStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDSTRINGARB);
    call.namelen = namelen;
    call.name = (ULONG_PTR)name;
    call.bufSize = bufSize;
    call.stringlen = (ULONG_PTR)stringlen;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedStringARB(struct qemu_syscall *call)
{
    struct qemu_glGetNamedStringARB *c = (struct qemu_glGetNamedStringARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedStringARB( c->namelen, QEMU_G2H(c->name), c->bufSize, QEMU_G2H(c->stringlen), QEMU_G2H(c->string) ));
}

#endif

struct qemu_glGetNamedStringivARB
{
    struct qemu_syscall super;
    uint64_t namelen;
    uint64_t name;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNamedStringivARB( GLint namelen, const GLchar *name, GLenum pname, GLint *params )
{
    struct qemu_glGetNamedStringivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNAMEDSTRINGIVARB);
    call.namelen = namelen;
    call.name = (ULONG_PTR)name;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNamedStringivARB(struct qemu_syscall *call)
{
    struct qemu_glGetNamedStringivARB *c = (struct qemu_glGetNamedStringivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNamedStringivARB( c->namelen, QEMU_G2H(c->name), c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetNextPerfQueryIdINTEL
{
    struct qemu_syscall super;
    uint64_t queryId;
    uint64_t nextQueryId;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetNextPerfQueryIdINTEL( GLuint queryId, GLuint *nextQueryId )
{
    struct qemu_glGetNextPerfQueryIdINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNEXTPERFQUERYIDINTEL);
    call.queryId = queryId;
    call.nextQueryId = (ULONG_PTR)nextQueryId;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetNextPerfQueryIdINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetNextPerfQueryIdINTEL *c = (struct qemu_glGetNextPerfQueryIdINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetNextPerfQueryIdINTEL( c->queryId, QEMU_G2H(c->nextQueryId) ));
}

#endif

struct qemu_glGetObjectBufferfvATI
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectBufferfvATI( GLuint buffer, GLenum pname, GLfloat *params )
{
    struct qemu_glGetObjectBufferfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTBUFFERFVATI);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectBufferfvATI(struct qemu_syscall *call)
{
    struct qemu_glGetObjectBufferfvATI *c = (struct qemu_glGetObjectBufferfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectBufferfvATI( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetObjectBufferivATI
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectBufferivATI( GLuint buffer, GLenum pname, GLint *params )
{
    struct qemu_glGetObjectBufferivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTBUFFERIVATI);
    call.buffer = buffer;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectBufferivATI(struct qemu_syscall *call)
{
    struct qemu_glGetObjectBufferivATI *c = (struct qemu_glGetObjectBufferivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectBufferivATI( c->buffer, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetObjectLabel
{
    struct qemu_syscall super;
    uint64_t identifier;
    uint64_t name;
    uint64_t bufSize;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectLabel( GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label )
{
    struct qemu_glGetObjectLabel call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTLABEL);
    call.identifier = identifier;
    call.name = name;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectLabel(struct qemu_syscall *call)
{
    struct qemu_glGetObjectLabel *c = (struct qemu_glGetObjectLabel *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectLabel( c->identifier, c->name, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->label) ));
}

#endif

struct qemu_glGetObjectLabelEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t object;
    uint64_t bufSize;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectLabelEXT( GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label )
{
    struct qemu_glGetObjectLabelEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTLABELEXT);
    call.type = type;
    call.object = object;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectLabelEXT(struct qemu_syscall *call)
{
    struct qemu_glGetObjectLabelEXT *c = (struct qemu_glGetObjectLabelEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectLabelEXT( c->type, c->object, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->label) ));
}

#endif

struct qemu_glGetObjectParameterfvARB
{
    struct qemu_syscall super;
    uint64_t obj;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectParameterfvARB( GLhandleARB obj, GLenum pname, GLfloat *params )
{
    struct qemu_glGetObjectParameterfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTPARAMETERFVARB);
    call.obj = obj;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectParameterfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetObjectParameterfvARB *c = (struct qemu_glGetObjectParameterfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectParameterfvARB( c->obj, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetObjectParameterivAPPLE
{
    struct qemu_syscall super;
    uint64_t objectType;
    uint64_t name;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectParameterivAPPLE( GLenum objectType, GLuint name, GLenum pname, GLint *params )
{
    struct qemu_glGetObjectParameterivAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTPARAMETERIVAPPLE);
    call.objectType = objectType;
    call.name = name;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectParameterivAPPLE(struct qemu_syscall *call)
{
    struct qemu_glGetObjectParameterivAPPLE *c = (struct qemu_glGetObjectParameterivAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectParameterivAPPLE( c->objectType, c->name, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetObjectParameterivARB
{
    struct qemu_syscall super;
    uint64_t obj;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectParameterivARB( GLhandleARB obj, GLenum pname, GLint *params )
{
    struct qemu_glGetObjectParameterivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTPARAMETERIVARB);
    call.obj = obj;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectParameterivARB(struct qemu_syscall *call)
{
    struct qemu_glGetObjectParameterivARB *c = (struct qemu_glGetObjectParameterivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectParameterivARB( c->obj, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetObjectPtrLabel
{
    struct qemu_syscall super;
    uint64_t ptr;
    uint64_t bufSize;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetObjectPtrLabel( const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label )
{
    struct qemu_glGetObjectPtrLabel call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOBJECTPTRLABEL);
    call.ptr = (ULONG_PTR)ptr;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetObjectPtrLabel(struct qemu_syscall *call)
{
    struct qemu_glGetObjectPtrLabel *c = (struct qemu_glGetObjectPtrLabel *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetObjectPtrLabel( QEMU_G2H(c->ptr), c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->label) ));
}

#endif

struct qemu_glGetOcclusionQueryivNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetOcclusionQueryivNV( GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glGetOcclusionQueryivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOCCLUSIONQUERYIVNV);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetOcclusionQueryivNV(struct qemu_syscall *call)
{
    struct qemu_glGetOcclusionQueryivNV *c = (struct qemu_glGetOcclusionQueryivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetOcclusionQueryivNV( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetOcclusionQueryuivNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetOcclusionQueryuivNV( GLuint id, GLenum pname, GLuint *params )
{
    struct qemu_glGetOcclusionQueryuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETOCCLUSIONQUERYUIVNV);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetOcclusionQueryuivNV(struct qemu_syscall *call)
{
    struct qemu_glGetOcclusionQueryuivNV *c = (struct qemu_glGetOcclusionQueryuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetOcclusionQueryuivNV( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPathColorGenfvNV
{
    struct qemu_syscall super;
    uint64_t color;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathColorGenfvNV( GLenum color, GLenum pname, GLfloat *value )
{
    struct qemu_glGetPathColorGenfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHCOLORGENFVNV);
    call.color = color;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathColorGenfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathColorGenfvNV *c = (struct qemu_glGetPathColorGenfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathColorGenfvNV( c->color, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPathColorGenivNV
{
    struct qemu_syscall super;
    uint64_t color;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathColorGenivNV( GLenum color, GLenum pname, GLint *value )
{
    struct qemu_glGetPathColorGenivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHCOLORGENIVNV);
    call.color = color;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathColorGenivNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathColorGenivNV *c = (struct qemu_glGetPathColorGenivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathColorGenivNV( c->color, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPathCommandsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t commands;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathCommandsNV( GLuint path, GLubyte *commands )
{
    struct qemu_glGetPathCommandsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHCOMMANDSNV);
    call.path = path;
    call.commands = (ULONG_PTR)commands;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathCommandsNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathCommandsNV *c = (struct qemu_glGetPathCommandsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathCommandsNV( c->path, QEMU_G2H(c->commands) ));
}

#endif

struct qemu_glGetPathCoordsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathCoordsNV( GLuint path, GLfloat *coords )
{
    struct qemu_glGetPathCoordsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHCOORDSNV);
    call.path = path;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathCoordsNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathCoordsNV *c = (struct qemu_glGetPathCoordsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathCoordsNV( c->path, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glGetPathDashArrayNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t dashArray;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathDashArrayNV( GLuint path, GLfloat *dashArray )
{
    struct qemu_glGetPathDashArrayNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHDASHARRAYNV);
    call.path = path;
    call.dashArray = (ULONG_PTR)dashArray;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathDashArrayNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathDashArrayNV *c = (struct qemu_glGetPathDashArrayNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathDashArrayNV( c->path, QEMU_G2H(c->dashArray) ));
}

#endif

struct qemu_glGetPathLengthNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t startSegment;
    uint64_t numSegments;
};

#ifdef QEMU_DLL_GUEST

GLfloat WINAPI glGetPathLengthNV( GLuint path, GLsizei startSegment, GLsizei numSegments )
{
    struct qemu_glGetPathLengthNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHLENGTHNV);
    call.path = path;
    call.startSegment = startSegment;
    call.numSegments = numSegments;

    qemu_syscall(&call.super);

    return call.super.dret;
}

#else

void qemu_glGetPathLengthNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathLengthNV *c = (struct qemu_glGetPathLengthNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.dret = (p_glGetPathLengthNV( c->path, c->startSegment, c->numSegments ));
}

#endif

struct qemu_glGetPathMetricRangeNV
{
    struct qemu_syscall super;
    uint64_t metricQueryMask;
    uint64_t firstPathName;
    uint64_t numPaths;
    uint64_t stride;
    uint64_t metrics;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathMetricRangeNV( GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics )
{
    struct qemu_glGetPathMetricRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHMETRICRANGENV);
    call.metricQueryMask = metricQueryMask;
    call.firstPathName = firstPathName;
    call.numPaths = numPaths;
    call.stride = stride;
    call.metrics = (ULONG_PTR)metrics;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathMetricRangeNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathMetricRangeNV *c = (struct qemu_glGetPathMetricRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathMetricRangeNV( c->metricQueryMask, c->firstPathName, c->numPaths, c->stride, QEMU_G2H(c->metrics) ));
}

#endif

struct qemu_glGetPathMetricsNV
{
    struct qemu_syscall super;
    uint64_t metricQueryMask;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t stride;
    uint64_t metrics;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathMetricsNV( GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics )
{
    struct qemu_glGetPathMetricsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHMETRICSNV);
    call.metricQueryMask = metricQueryMask;
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.stride = stride;
    call.metrics = (ULONG_PTR)metrics;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathMetricsNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathMetricsNV *c = (struct qemu_glGetPathMetricsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathMetricsNV( c->metricQueryMask, c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->stride, QEMU_G2H(c->metrics) ));
}

#endif

struct qemu_glGetPathParameterfvNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathParameterfvNV( GLuint path, GLenum pname, GLfloat *value )
{
    struct qemu_glGetPathParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHPARAMETERFVNV);
    call.path = path;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathParameterfvNV *c = (struct qemu_glGetPathParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathParameterfvNV( c->path, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPathParameterivNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathParameterivNV( GLuint path, GLenum pname, GLint *value )
{
    struct qemu_glGetPathParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHPARAMETERIVNV);
    call.path = path;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathParameterivNV *c = (struct qemu_glGetPathParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathParameterivNV( c->path, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPathSpacingNV
{
    struct qemu_syscall super;
    uint64_t pathListMode;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    double advanceScale;
    double kerningScale;
    uint64_t transformType;
    uint64_t returnedSpacing;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathSpacingNV( GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing )
{
    struct qemu_glGetPathSpacingNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHSPACINGNV);
    call.pathListMode = pathListMode;
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.advanceScale = advanceScale;
    call.kerningScale = kerningScale;
    call.transformType = transformType;
    call.returnedSpacing = (ULONG_PTR)returnedSpacing;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathSpacingNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathSpacingNV *c = (struct qemu_glGetPathSpacingNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathSpacingNV( c->pathListMode, c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->advanceScale, c->kerningScale, c->transformType, QEMU_G2H(c->returnedSpacing) ));
}

#endif

struct qemu_glGetPathTexGenfvNV
{
    struct qemu_syscall super;
    uint64_t texCoordSet;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathTexGenfvNV( GLenum texCoordSet, GLenum pname, GLfloat *value )
{
    struct qemu_glGetPathTexGenfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHTEXGENFVNV);
    call.texCoordSet = texCoordSet;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathTexGenfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathTexGenfvNV *c = (struct qemu_glGetPathTexGenfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathTexGenfvNV( c->texCoordSet, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPathTexGenivNV
{
    struct qemu_syscall super;
    uint64_t texCoordSet;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPathTexGenivNV( GLenum texCoordSet, GLenum pname, GLint *value )
{
    struct qemu_glGetPathTexGenivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPATHTEXGENIVNV);
    call.texCoordSet = texCoordSet;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPathTexGenivNV(struct qemu_syscall *call)
{
    struct qemu_glGetPathTexGenivNV *c = (struct qemu_glGetPathTexGenivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPathTexGenivNV( c->texCoordSet, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glGetPerfCounterInfoINTEL
{
    struct qemu_syscall super;
    uint64_t queryId;
    uint64_t counterId;
    uint64_t counterNameLength;
    uint64_t counterName;
    uint64_t counterDescLength;
    uint64_t counterDesc;
    uint64_t counterOffset;
    uint64_t counterDataSize;
    uint64_t counterTypeEnum;
    uint64_t counterDataTypeEnum;
    uint64_t rawCounterMaxValue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfCounterInfoINTEL( GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue )
{
    struct qemu_glGetPerfCounterInfoINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFCOUNTERINFOINTEL);
    call.queryId = queryId;
    call.counterId = counterId;
    call.counterNameLength = counterNameLength;
    call.counterName = (ULONG_PTR)counterName;
    call.counterDescLength = counterDescLength;
    call.counterDesc = (ULONG_PTR)counterDesc;
    call.counterOffset = (ULONG_PTR)counterOffset;
    call.counterDataSize = (ULONG_PTR)counterDataSize;
    call.counterTypeEnum = (ULONG_PTR)counterTypeEnum;
    call.counterDataTypeEnum = (ULONG_PTR)counterDataTypeEnum;
    call.rawCounterMaxValue = (ULONG_PTR)rawCounterMaxValue;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfCounterInfoINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetPerfCounterInfoINTEL *c = (struct qemu_glGetPerfCounterInfoINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfCounterInfoINTEL( c->queryId, c->counterId, c->counterNameLength, QEMU_G2H(c->counterName), c->counterDescLength, QEMU_G2H(c->counterDesc), QEMU_G2H(c->counterOffset), QEMU_G2H(c->counterDataSize), QEMU_G2H(c->counterTypeEnum), QEMU_G2H(c->counterDataTypeEnum), QEMU_G2H(c->rawCounterMaxValue) ));
}

#endif

struct qemu_glGetPerfMonitorCounterDataAMD
{
    struct qemu_syscall super;
    uint64_t monitor;
    uint64_t pname;
    uint64_t dataSize;
    uint64_t data;
    uint64_t bytesWritten;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorCounterDataAMD( GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten )
{
    struct qemu_glGetPerfMonitorCounterDataAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORCOUNTERDATAAMD);
    call.monitor = monitor;
    call.pname = pname;
    call.dataSize = dataSize;
    call.data = (ULONG_PTR)data;
    call.bytesWritten = (ULONG_PTR)bytesWritten;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorCounterDataAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorCounterDataAMD *c = (struct qemu_glGetPerfMonitorCounterDataAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorCounterDataAMD( c->monitor, c->pname, c->dataSize, QEMU_G2H(c->data), QEMU_G2H(c->bytesWritten) ));
}

#endif

struct qemu_glGetPerfMonitorCounterInfoAMD
{
    struct qemu_syscall super;
    uint64_t group;
    uint64_t counter;
    uint64_t pname;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorCounterInfoAMD( GLuint group, GLuint counter, GLenum pname, void *data )
{
    struct qemu_glGetPerfMonitorCounterInfoAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORCOUNTERINFOAMD);
    call.group = group;
    call.counter = counter;
    call.pname = pname;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorCounterInfoAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorCounterInfoAMD *c = (struct qemu_glGetPerfMonitorCounterInfoAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorCounterInfoAMD( c->group, c->counter, c->pname, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetPerfMonitorCounterStringAMD
{
    struct qemu_syscall super;
    uint64_t group;
    uint64_t counter;
    uint64_t bufSize;
    uint64_t length;
    uint64_t counterString;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorCounterStringAMD( GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString )
{
    struct qemu_glGetPerfMonitorCounterStringAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORCOUNTERSTRINGAMD);
    call.group = group;
    call.counter = counter;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.counterString = (ULONG_PTR)counterString;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorCounterStringAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorCounterStringAMD *c = (struct qemu_glGetPerfMonitorCounterStringAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorCounterStringAMD( c->group, c->counter, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->counterString) ));
}

#endif

struct qemu_glGetPerfMonitorCountersAMD
{
    struct qemu_syscall super;
    uint64_t group;
    uint64_t numCounters;
    uint64_t maxActiveCounters;
    uint64_t counterSize;
    uint64_t counters;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorCountersAMD( GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters )
{
    struct qemu_glGetPerfMonitorCountersAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORCOUNTERSAMD);
    call.group = group;
    call.numCounters = (ULONG_PTR)numCounters;
    call.maxActiveCounters = (ULONG_PTR)maxActiveCounters;
    call.counterSize = counterSize;
    call.counters = (ULONG_PTR)counters;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorCountersAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorCountersAMD *c = (struct qemu_glGetPerfMonitorCountersAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorCountersAMD( c->group, QEMU_G2H(c->numCounters), QEMU_G2H(c->maxActiveCounters), c->counterSize, QEMU_G2H(c->counters) ));
}

#endif

struct qemu_glGetPerfMonitorGroupStringAMD
{
    struct qemu_syscall super;
    uint64_t group;
    uint64_t bufSize;
    uint64_t length;
    uint64_t groupString;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorGroupStringAMD( GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString )
{
    struct qemu_glGetPerfMonitorGroupStringAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORGROUPSTRINGAMD);
    call.group = group;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.groupString = (ULONG_PTR)groupString;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorGroupStringAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorGroupStringAMD *c = (struct qemu_glGetPerfMonitorGroupStringAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorGroupStringAMD( c->group, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->groupString) ));
}

#endif

struct qemu_glGetPerfMonitorGroupsAMD
{
    struct qemu_syscall super;
    uint64_t numGroups;
    uint64_t groupsSize;
    uint64_t groups;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfMonitorGroupsAMD( GLint *numGroups, GLsizei groupsSize, GLuint *groups )
{
    struct qemu_glGetPerfMonitorGroupsAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFMONITORGROUPSAMD);
    call.numGroups = (ULONG_PTR)numGroups;
    call.groupsSize = groupsSize;
    call.groups = (ULONG_PTR)groups;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfMonitorGroupsAMD(struct qemu_syscall *call)
{
    struct qemu_glGetPerfMonitorGroupsAMD *c = (struct qemu_glGetPerfMonitorGroupsAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfMonitorGroupsAMD( QEMU_G2H(c->numGroups), c->groupsSize, QEMU_G2H(c->groups) ));
}

#endif

struct qemu_glGetPerfQueryDataINTEL
{
    struct qemu_syscall super;
    uint64_t queryHandle;
    uint64_t flags;
    uint64_t dataSize;
    uint64_t data;
    uint64_t bytesWritten;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfQueryDataINTEL( GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten )
{
    struct qemu_glGetPerfQueryDataINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFQUERYDATAINTEL);
    call.queryHandle = queryHandle;
    call.flags = flags;
    call.dataSize = dataSize;
    call.data = (ULONG_PTR)data;
    call.bytesWritten = (ULONG_PTR)bytesWritten;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfQueryDataINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetPerfQueryDataINTEL *c = (struct qemu_glGetPerfQueryDataINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfQueryDataINTEL( c->queryHandle, c->flags, c->dataSize, QEMU_G2H(c->data), QEMU_G2H(c->bytesWritten) ));
}

#endif

struct qemu_glGetPerfQueryIdByNameINTEL
{
    struct qemu_syscall super;
    uint64_t queryName;
    uint64_t queryId;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfQueryIdByNameINTEL( GLchar *queryName, GLuint *queryId )
{
    struct qemu_glGetPerfQueryIdByNameINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFQUERYIDBYNAMEINTEL);
    call.queryName = (ULONG_PTR)queryName;
    call.queryId = (ULONG_PTR)queryId;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfQueryIdByNameINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetPerfQueryIdByNameINTEL *c = (struct qemu_glGetPerfQueryIdByNameINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfQueryIdByNameINTEL( QEMU_G2H(c->queryName), QEMU_G2H(c->queryId) ));
}

#endif

struct qemu_glGetPerfQueryInfoINTEL
{
    struct qemu_syscall super;
    uint64_t queryId;
    uint64_t queryNameLength;
    uint64_t queryName;
    uint64_t dataSize;
    uint64_t noCounters;
    uint64_t noInstances;
    uint64_t capsMask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPerfQueryInfoINTEL( GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask )
{
    struct qemu_glGetPerfQueryInfoINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPERFQUERYINFOINTEL);
    call.queryId = queryId;
    call.queryNameLength = queryNameLength;
    call.queryName = (ULONG_PTR)queryName;
    call.dataSize = (ULONG_PTR)dataSize;
    call.noCounters = (ULONG_PTR)noCounters;
    call.noInstances = (ULONG_PTR)noInstances;
    call.capsMask = (ULONG_PTR)capsMask;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPerfQueryInfoINTEL(struct qemu_syscall *call)
{
    struct qemu_glGetPerfQueryInfoINTEL *c = (struct qemu_glGetPerfQueryInfoINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPerfQueryInfoINTEL( c->queryId, c->queryNameLength, QEMU_G2H(c->queryName), QEMU_G2H(c->dataSize), QEMU_G2H(c->noCounters), QEMU_G2H(c->noInstances), QEMU_G2H(c->capsMask) ));
}

#endif

struct qemu_glGetPixelMapxv
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t size;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPixelMapxv( GLenum map, GLint size, GLfixed *values )
{
    struct qemu_glGetPixelMapxv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPIXELMAPXV);
    call.map = map;
    call.size = size;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPixelMapxv(struct qemu_syscall *call)
{
    struct qemu_glGetPixelMapxv *c = (struct qemu_glGetPixelMapxv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPixelMapxv( c->map, c->size, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetPixelTexGenParameterfvSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPixelTexGenParameterfvSGIS( GLenum pname, GLfloat *params )
{
    struct qemu_glGetPixelTexGenParameterfvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPIXELTEXGENPARAMETERFVSGIS);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPixelTexGenParameterfvSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetPixelTexGenParameterfvSGIS *c = (struct qemu_glGetPixelTexGenParameterfvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPixelTexGenParameterfvSGIS( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPixelTexGenParameterivSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPixelTexGenParameterivSGIS( GLenum pname, GLint *params )
{
    struct qemu_glGetPixelTexGenParameterivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPIXELTEXGENPARAMETERIVSGIS);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPixelTexGenParameterivSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetPixelTexGenParameterivSGIS *c = (struct qemu_glGetPixelTexGenParameterivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPixelTexGenParameterivSGIS( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPixelTransformParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPixelTransformParameterfvEXT( GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetPixelTransformParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPIXELTRANSFORMPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPixelTransformParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetPixelTransformParameterfvEXT *c = (struct qemu_glGetPixelTransformParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPixelTransformParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPixelTransformParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPixelTransformParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetPixelTransformParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPIXELTRANSFORMPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPixelTransformParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetPixelTransformParameterivEXT *c = (struct qemu_glGetPixelTransformParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPixelTransformParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPointerIndexedvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPointerIndexedvEXT( GLenum target, GLuint index, void **data )
{
    struct qemu_glGetPointerIndexedvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPOINTERINDEXEDVEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPointerIndexedvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetPointerIndexedvEXT *c = (struct qemu_glGetPointerIndexedvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPointerIndexedvEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetPointeri_vEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPointeri_vEXT( GLenum pname, GLuint index, void **params )
{
    struct qemu_glGetPointeri_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPOINTERI_VEXT);
    call.pname = pname;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPointeri_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetPointeri_vEXT *c = (struct qemu_glGetPointeri_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPointeri_vEXT( c->pname, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetPointervEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetPointervEXT( GLenum pname, void **params )
{
    struct qemu_glGetPointervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPOINTERVEXT);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetPointervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetPointervEXT *c = (struct qemu_glGetPointervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetPointervEXT( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramBinary
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t bufSize;
    uint64_t length;
    uint64_t binaryFormat;
    uint64_t binary;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramBinary( GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary )
{
    struct qemu_glGetProgramBinary call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMBINARY);
    call.program = program;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.binaryFormat = (ULONG_PTR)binaryFormat;
    call.binary = (ULONG_PTR)binary;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramBinary(struct qemu_syscall *call)
{
    struct qemu_glGetProgramBinary *c = (struct qemu_glGetProgramBinary *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramBinary( c->program, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->binaryFormat), QEMU_G2H(c->binary) ));
}

#endif

struct qemu_glGetProgramEnvParameterIivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramEnvParameterIivNV( GLenum target, GLuint index, GLint *params )
{
    struct qemu_glGetProgramEnvParameterIivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMENVPARAMETERIIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramEnvParameterIivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramEnvParameterIivNV *c = (struct qemu_glGetProgramEnvParameterIivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramEnvParameterIivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramEnvParameterIuivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramEnvParameterIuivNV( GLenum target, GLuint index, GLuint *params )
{
    struct qemu_glGetProgramEnvParameterIuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMENVPARAMETERIUIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramEnvParameterIuivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramEnvParameterIuivNV *c = (struct qemu_glGetProgramEnvParameterIuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramEnvParameterIuivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramEnvParameterdvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramEnvParameterdvARB( GLenum target, GLuint index, GLdouble *params )
{
    struct qemu_glGetProgramEnvParameterdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMENVPARAMETERDVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramEnvParameterdvARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramEnvParameterdvARB *c = (struct qemu_glGetProgramEnvParameterdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramEnvParameterdvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramEnvParameterfvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramEnvParameterfvARB( GLenum target, GLuint index, GLfloat *params )
{
    struct qemu_glGetProgramEnvParameterfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMENVPARAMETERFVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramEnvParameterfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramEnvParameterfvARB *c = (struct qemu_glGetProgramEnvParameterfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramEnvParameterfvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramInfoLog
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t bufSize;
    uint64_t length;
    uint64_t infoLog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramInfoLog( GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog )
{
    struct qemu_glGetProgramInfoLog call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMINFOLOG);
    call.program = program;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.infoLog = (ULONG_PTR)infoLog;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramInfoLog(struct qemu_syscall *call)
{
    struct qemu_glGetProgramInfoLog *c = (struct qemu_glGetProgramInfoLog *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramInfoLog( c->program, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->infoLog) ));
}

#endif

struct qemu_glGetProgramInterfaceiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramInterfaceiv( GLuint program, GLenum programInterface, GLenum pname, GLint *params )
{
    struct qemu_glGetProgramInterfaceiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMINTERFACEIV);
    call.program = program;
    call.programInterface = programInterface;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramInterfaceiv(struct qemu_syscall *call)
{
    struct qemu_glGetProgramInterfaceiv *c = (struct qemu_glGetProgramInterfaceiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramInterfaceiv( c->program, c->programInterface, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramLocalParameterIivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramLocalParameterIivNV( GLenum target, GLuint index, GLint *params )
{
    struct qemu_glGetProgramLocalParameterIivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMLOCALPARAMETERIIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramLocalParameterIivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramLocalParameterIivNV *c = (struct qemu_glGetProgramLocalParameterIivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramLocalParameterIivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramLocalParameterIuivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramLocalParameterIuivNV( GLenum target, GLuint index, GLuint *params )
{
    struct qemu_glGetProgramLocalParameterIuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMLOCALPARAMETERIUIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramLocalParameterIuivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramLocalParameterIuivNV *c = (struct qemu_glGetProgramLocalParameterIuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramLocalParameterIuivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramLocalParameterdvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramLocalParameterdvARB( GLenum target, GLuint index, GLdouble *params )
{
    struct qemu_glGetProgramLocalParameterdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMLOCALPARAMETERDVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramLocalParameterdvARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramLocalParameterdvARB *c = (struct qemu_glGetProgramLocalParameterdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramLocalParameterdvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramLocalParameterfvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramLocalParameterfvARB( GLenum target, GLuint index, GLfloat *params )
{
    struct qemu_glGetProgramLocalParameterfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMLOCALPARAMETERFVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramLocalParameterfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramLocalParameterfvARB *c = (struct qemu_glGetProgramLocalParameterfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramLocalParameterfvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramNamedParameterdvNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramNamedParameterdvNV( GLuint id, GLsizei len, const GLubyte *name, GLdouble *params )
{
    struct qemu_glGetProgramNamedParameterdvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMNAMEDPARAMETERDVNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramNamedParameterdvNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramNamedParameterdvNV *c = (struct qemu_glGetProgramNamedParameterdvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramNamedParameterdvNV( c->id, c->len, QEMU_G2H(c->name), QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramNamedParameterfvNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramNamedParameterfvNV( GLuint id, GLsizei len, const GLubyte *name, GLfloat *params )
{
    struct qemu_glGetProgramNamedParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMNAMEDPARAMETERFVNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramNamedParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramNamedParameterfvNV *c = (struct qemu_glGetProgramNamedParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramNamedParameterfvNV( c->id, c->len, QEMU_G2H(c->name), QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramParameterdvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramParameterdvNV( GLenum target, GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetProgramParameterdvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMPARAMETERDVNV);
    call.target = target;
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramParameterdvNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramParameterdvNV *c = (struct qemu_glGetProgramParameterdvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramParameterdvNV( c->target, c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramParameterfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramParameterfvNV( GLenum target, GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetProgramParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMPARAMETERFVNV);
    call.target = target;
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramParameterfvNV *c = (struct qemu_glGetProgramParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramParameterfvNV( c->target, c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramPipelineInfoLog
{
    struct qemu_syscall super;
    uint64_t pipeline;
    uint64_t bufSize;
    uint64_t length;
    uint64_t infoLog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramPipelineInfoLog( GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog )
{
    struct qemu_glGetProgramPipelineInfoLog call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMPIPELINEINFOLOG);
    call.pipeline = pipeline;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.infoLog = (ULONG_PTR)infoLog;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramPipelineInfoLog(struct qemu_syscall *call)
{
    struct qemu_glGetProgramPipelineInfoLog *c = (struct qemu_glGetProgramPipelineInfoLog *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramPipelineInfoLog( c->pipeline, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->infoLog) ));
}

#endif

struct qemu_glGetProgramPipelineiv
{
    struct qemu_syscall super;
    uint64_t pipeline;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramPipelineiv( GLuint pipeline, GLenum pname, GLint *params )
{
    struct qemu_glGetProgramPipelineiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMPIPELINEIV);
    call.pipeline = pipeline;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramPipelineiv(struct qemu_syscall *call)
{
    struct qemu_glGetProgramPipelineiv *c = (struct qemu_glGetProgramPipelineiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramPipelineiv( c->pipeline, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramResourceIndex
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetProgramResourceIndex( GLuint program, GLenum programInterface, const GLchar *name )
{
    struct qemu_glGetProgramResourceIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCEINDEX);
    call.program = program;
    call.programInterface = programInterface;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetProgramResourceIndex(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourceIndex *c = (struct qemu_glGetProgramResourceIndex *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetProgramResourceIndex( c->program, c->programInterface, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetProgramResourceLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetProgramResourceLocation( GLuint program, GLenum programInterface, const GLchar *name )
{
    struct qemu_glGetProgramResourceLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCELOCATION);
    call.program = program;
    call.programInterface = programInterface;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetProgramResourceLocation(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourceLocation *c = (struct qemu_glGetProgramResourceLocation *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetProgramResourceLocation( c->program, c->programInterface, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetProgramResourceLocationIndex
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetProgramResourceLocationIndex( GLuint program, GLenum programInterface, const GLchar *name )
{
    struct qemu_glGetProgramResourceLocationIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCELOCATIONINDEX);
    call.program = program;
    call.programInterface = programInterface;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetProgramResourceLocationIndex(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourceLocationIndex *c = (struct qemu_glGetProgramResourceLocationIndex *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetProgramResourceLocationIndex( c->program, c->programInterface, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetProgramResourceName
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramResourceName( GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name )
{
    struct qemu_glGetProgramResourceName call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCENAME);
    call.program = program;
    call.programInterface = programInterface;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramResourceName(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourceName *c = (struct qemu_glGetProgramResourceName *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramResourceName( c->program, c->programInterface, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetProgramResourcefvNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t index;
    uint64_t propCount;
    uint64_t props;
    uint64_t count;
    uint64_t length;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramResourcefvNV( GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLfloat *params )
{
    struct qemu_glGetProgramResourcefvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCEFVNV);
    call.program = program;
    call.programInterface = programInterface;
    call.index = index;
    call.propCount = propCount;
    call.props = (ULONG_PTR)props;
    call.count = count;
    call.length = (ULONG_PTR)length;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramResourcefvNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourcefvNV *c = (struct qemu_glGetProgramResourcefvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramResourcefvNV( c->program, c->programInterface, c->index, c->propCount, QEMU_G2H(c->props), c->count, QEMU_G2H(c->length), QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramResourceiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t programInterface;
    uint64_t index;
    uint64_t propCount;
    uint64_t props;
    uint64_t count;
    uint64_t length;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramResourceiv( GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params )
{
    struct qemu_glGetProgramResourceiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMRESOURCEIV);
    call.program = program;
    call.programInterface = programInterface;
    call.index = index;
    call.propCount = propCount;
    call.props = (ULONG_PTR)props;
    call.count = count;
    call.length = (ULONG_PTR)length;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramResourceiv(struct qemu_syscall *call)
{
    struct qemu_glGetProgramResourceiv *c = (struct qemu_glGetProgramResourceiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramResourceiv( c->program, c->programInterface, c->index, c->propCount, QEMU_G2H(c->props), c->count, QEMU_G2H(c->length), QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramStageiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t pname;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramStageiv( GLuint program, GLenum shadertype, GLenum pname, GLint *values )
{
    struct qemu_glGetProgramStageiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMSTAGEIV);
    call.program = program;
    call.shadertype = shadertype;
    call.pname = pname;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramStageiv(struct qemu_syscall *call)
{
    struct qemu_glGetProgramStageiv *c = (struct qemu_glGetProgramStageiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramStageiv( c->program, c->shadertype, c->pname, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetProgramStringARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramStringARB( GLenum target, GLenum pname, void *string )
{
    struct qemu_glGetProgramStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMSTRINGARB);
    call.target = target;
    call.pname = pname;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramStringARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramStringARB *c = (struct qemu_glGetProgramStringARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramStringARB( c->target, c->pname, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glGetProgramStringNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramStringNV( GLuint id, GLenum pname, GLubyte *program )
{
    struct qemu_glGetProgramStringNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMSTRINGNV);
    call.id = id;
    call.pname = pname;
    call.program = (ULONG_PTR)program;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramStringNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramStringNV *c = (struct qemu_glGetProgramStringNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramStringNV( c->id, c->pname, QEMU_G2H(c->program) ));
}

#endif

struct qemu_glGetProgramSubroutineParameteruivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramSubroutineParameteruivNV( GLenum target, GLuint index, GLuint *param )
{
    struct qemu_glGetProgramSubroutineParameteruivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV);
    call.target = target;
    call.index = index;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramSubroutineParameteruivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramSubroutineParameteruivNV *c = (struct qemu_glGetProgramSubroutineParameteruivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramSubroutineParameteruivNV( c->target, c->index, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetProgramiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramiv( GLuint program, GLenum pname, GLint *params )
{
    struct qemu_glGetProgramiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMIV);
    call.program = program;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramiv(struct qemu_syscall *call)
{
    struct qemu_glGetProgramiv *c = (struct qemu_glGetProgramiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramiv( c->program, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramivARB( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetProgramivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMIVARB);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramivARB(struct qemu_syscall *call)
{
    struct qemu_glGetProgramivARB *c = (struct qemu_glGetProgramivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramivARB( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetProgramivNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetProgramivNV( GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glGetProgramivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETPROGRAMIVNV);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetProgramivNV(struct qemu_syscall *call)
{
    struct qemu_glGetProgramivNV *c = (struct qemu_glGetProgramivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetProgramivNV( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryBufferObjecti64v
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t buffer;
    uint64_t pname;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryBufferObjecti64v( GLuint id, GLuint buffer, GLenum pname, GLintptr offset )
{
    struct qemu_glGetQueryBufferObjecti64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYBUFFEROBJECTI64V);
    call.id = id;
    call.buffer = buffer;
    call.pname = pname;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryBufferObjecti64v(struct qemu_syscall *call)
{
    struct qemu_glGetQueryBufferObjecti64v *c = (struct qemu_glGetQueryBufferObjecti64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryBufferObjecti64v( c->id, c->buffer, c->pname, c->offset ));
}

#endif

struct qemu_glGetQueryBufferObjectiv
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t buffer;
    uint64_t pname;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryBufferObjectiv( GLuint id, GLuint buffer, GLenum pname, GLintptr offset )
{
    struct qemu_glGetQueryBufferObjectiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYBUFFEROBJECTIV);
    call.id = id;
    call.buffer = buffer;
    call.pname = pname;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryBufferObjectiv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryBufferObjectiv *c = (struct qemu_glGetQueryBufferObjectiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryBufferObjectiv( c->id, c->buffer, c->pname, c->offset ));
}

#endif

struct qemu_glGetQueryBufferObjectui64v
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t buffer;
    uint64_t pname;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryBufferObjectui64v( GLuint id, GLuint buffer, GLenum pname, GLintptr offset )
{
    struct qemu_glGetQueryBufferObjectui64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYBUFFEROBJECTUI64V);
    call.id = id;
    call.buffer = buffer;
    call.pname = pname;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryBufferObjectui64v(struct qemu_syscall *call)
{
    struct qemu_glGetQueryBufferObjectui64v *c = (struct qemu_glGetQueryBufferObjectui64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryBufferObjectui64v( c->id, c->buffer, c->pname, c->offset ));
}

#endif

struct qemu_glGetQueryBufferObjectuiv
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t buffer;
    uint64_t pname;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryBufferObjectuiv( GLuint id, GLuint buffer, GLenum pname, GLintptr offset )
{
    struct qemu_glGetQueryBufferObjectuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYBUFFEROBJECTUIV);
    call.id = id;
    call.buffer = buffer;
    call.pname = pname;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryBufferObjectuiv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryBufferObjectuiv *c = (struct qemu_glGetQueryBufferObjectuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryBufferObjectuiv( c->id, c->buffer, c->pname, c->offset ));
}

#endif

struct qemu_glGetQueryIndexediv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryIndexediv( GLenum target, GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetQueryIndexediv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYINDEXEDIV);
    call.target = target;
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryIndexediv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryIndexediv *c = (struct qemu_glGetQueryIndexediv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryIndexediv( c->target, c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjecti64v
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjecti64v( GLuint id, GLenum pname, GLint64 *params )
{
    struct qemu_glGetQueryObjecti64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTI64V);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjecti64v(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjecti64v *c = (struct qemu_glGetQueryObjecti64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjecti64v( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjecti64vEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjecti64vEXT( GLuint id, GLenum pname, GLint64 *params )
{
    struct qemu_glGetQueryObjecti64vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTI64VEXT);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjecti64vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjecti64vEXT *c = (struct qemu_glGetQueryObjecti64vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjecti64vEXT( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectiv
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectiv( GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glGetQueryObjectiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTIV);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectiv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectiv *c = (struct qemu_glGetQueryObjectiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectiv( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectivARB
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectivARB( GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glGetQueryObjectivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTIVARB);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectivARB(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectivARB *c = (struct qemu_glGetQueryObjectivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectivARB( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectui64v
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectui64v( GLuint id, GLenum pname, GLuint64 *params )
{
    struct qemu_glGetQueryObjectui64v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTUI64V);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectui64v(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectui64v *c = (struct qemu_glGetQueryObjectui64v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectui64v( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectui64vEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectui64vEXT( GLuint id, GLenum pname, GLuint64 *params )
{
    struct qemu_glGetQueryObjectui64vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTUI64VEXT);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectui64vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectui64vEXT *c = (struct qemu_glGetQueryObjectui64vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectui64vEXT( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectuiv
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectuiv( GLuint id, GLenum pname, GLuint *params )
{
    struct qemu_glGetQueryObjectuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTUIV);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectuiv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectuiv *c = (struct qemu_glGetQueryObjectuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectuiv( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryObjectuivARB
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryObjectuivARB( GLuint id, GLenum pname, GLuint *params )
{
    struct qemu_glGetQueryObjectuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYOBJECTUIVARB);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryObjectuivARB(struct qemu_syscall *call)
{
    struct qemu_glGetQueryObjectuivARB *c = (struct qemu_glGetQueryObjectuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryObjectuivARB( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryiv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetQueryiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryiv(struct qemu_syscall *call)
{
    struct qemu_glGetQueryiv *c = (struct qemu_glGetQueryiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryiv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetQueryivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetQueryivARB( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetQueryivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETQUERYIVARB);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetQueryivARB(struct qemu_syscall *call)
{
    struct qemu_glGetQueryivARB *c = (struct qemu_glGetQueryivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetQueryivARB( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetRenderbufferParameteriv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetRenderbufferParameteriv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetRenderbufferParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETRENDERBUFFERPARAMETERIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetRenderbufferParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetRenderbufferParameteriv *c = (struct qemu_glGetRenderbufferParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetRenderbufferParameteriv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetRenderbufferParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetRenderbufferParameterivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetRenderbufferParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETRENDERBUFFERPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetRenderbufferParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetRenderbufferParameterivEXT *c = (struct qemu_glGetRenderbufferParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetRenderbufferParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSamplerParameterIiv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSamplerParameterIiv( GLuint sampler, GLenum pname, GLint *params )
{
    struct qemu_glGetSamplerParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSAMPLERPARAMETERIIV);
    call.sampler = sampler;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSamplerParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glGetSamplerParameterIiv *c = (struct qemu_glGetSamplerParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSamplerParameterIiv( c->sampler, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSamplerParameterIuiv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSamplerParameterIuiv( GLuint sampler, GLenum pname, GLuint *params )
{
    struct qemu_glGetSamplerParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSAMPLERPARAMETERIUIV);
    call.sampler = sampler;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSamplerParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glGetSamplerParameterIuiv *c = (struct qemu_glGetSamplerParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSamplerParameterIuiv( c->sampler, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSamplerParameterfv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSamplerParameterfv( GLuint sampler, GLenum pname, GLfloat *params )
{
    struct qemu_glGetSamplerParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSAMPLERPARAMETERFV);
    call.sampler = sampler;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSamplerParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetSamplerParameterfv *c = (struct qemu_glGetSamplerParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSamplerParameterfv( c->sampler, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSamplerParameteriv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSamplerParameteriv( GLuint sampler, GLenum pname, GLint *params )
{
    struct qemu_glGetSamplerParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSAMPLERPARAMETERIV);
    call.sampler = sampler;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSamplerParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetSamplerParameteriv *c = (struct qemu_glGetSamplerParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSamplerParameteriv( c->sampler, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSemaphoreParameterui64vEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSemaphoreParameterui64vEXT( GLuint semaphore, GLenum pname, GLuint64 *params )
{
    struct qemu_glGetSemaphoreParameterui64vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSEMAPHOREPARAMETERUI64VEXT);
    call.semaphore = semaphore;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSemaphoreParameterui64vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetSemaphoreParameterui64vEXT *c = (struct qemu_glGetSemaphoreParameterui64vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSemaphoreParameterui64vEXT( c->semaphore, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetSeparableFilter
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t row;
    uint64_t column;
    uint64_t span;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSeparableFilter( GLenum target, GLenum format, GLenum type, void *row, void *column, void *span )
{
    struct qemu_glGetSeparableFilter call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSEPARABLEFILTER);
    call.target = target;
    call.format = format;
    call.type = type;
    call.row = (ULONG_PTR)row;
    call.column = (ULONG_PTR)column;
    call.span = (ULONG_PTR)span;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSeparableFilter(struct qemu_syscall *call)
{
    struct qemu_glGetSeparableFilter *c = (struct qemu_glGetSeparableFilter *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSeparableFilter( c->target, c->format, c->type, QEMU_G2H(c->row), QEMU_G2H(c->column), QEMU_G2H(c->span) ));
}

#endif

struct qemu_glGetSeparableFilterEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t row;
    uint64_t column;
    uint64_t span;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSeparableFilterEXT( GLenum target, GLenum format, GLenum type, void *row, void *column, void *span )
{
    struct qemu_glGetSeparableFilterEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSEPARABLEFILTEREXT);
    call.target = target;
    call.format = format;
    call.type = type;
    call.row = (ULONG_PTR)row;
    call.column = (ULONG_PTR)column;
    call.span = (ULONG_PTR)span;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSeparableFilterEXT(struct qemu_syscall *call)
{
    struct qemu_glGetSeparableFilterEXT *c = (struct qemu_glGetSeparableFilterEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSeparableFilterEXT( c->target, c->format, c->type, QEMU_G2H(c->row), QEMU_G2H(c->column), QEMU_G2H(c->span) ));
}

#endif

struct qemu_glGetShaderInfoLog
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t bufSize;
    uint64_t length;
    uint64_t infoLog;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShaderInfoLog( GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog )
{
    struct qemu_glGetShaderInfoLog call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADERINFOLOG);
    call.shader = shader;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.infoLog = (ULONG_PTR)infoLog;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShaderInfoLog(struct qemu_syscall *call)
{
    struct qemu_glGetShaderInfoLog *c = (struct qemu_glGetShaderInfoLog *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShaderInfoLog( c->shader, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->infoLog) ));
}

#endif

struct qemu_glGetShaderPrecisionFormat
{
    struct qemu_syscall super;
    uint64_t shadertype;
    uint64_t precisiontype;
    uint64_t range;
    uint64_t precision;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShaderPrecisionFormat( GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision )
{
    struct qemu_glGetShaderPrecisionFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADERPRECISIONFORMAT);
    call.shadertype = shadertype;
    call.precisiontype = precisiontype;
    call.range = (ULONG_PTR)range;
    call.precision = (ULONG_PTR)precision;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShaderPrecisionFormat(struct qemu_syscall *call)
{
    struct qemu_glGetShaderPrecisionFormat *c = (struct qemu_glGetShaderPrecisionFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShaderPrecisionFormat( c->shadertype, c->precisiontype, QEMU_G2H(c->range), QEMU_G2H(c->precision) ));
}

#endif

struct qemu_glGetShaderSource
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t bufSize;
    uint64_t length;
    uint64_t source;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShaderSource( GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source )
{
    struct qemu_glGetShaderSource call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADERSOURCE);
    call.shader = shader;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.source = (ULONG_PTR)source;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShaderSource(struct qemu_syscall *call)
{
    struct qemu_glGetShaderSource *c = (struct qemu_glGetShaderSource *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShaderSource( c->shader, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->source) ));
}

#endif

struct qemu_glGetShaderSourceARB
{
    struct qemu_syscall super;
    uint64_t obj;
    uint64_t maxLength;
    uint64_t length;
    uint64_t source;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShaderSourceARB( GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source )
{
    struct qemu_glGetShaderSourceARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADERSOURCEARB);
    call.obj = obj;
    call.maxLength = maxLength;
    call.length = (ULONG_PTR)length;
    call.source = (ULONG_PTR)source;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShaderSourceARB(struct qemu_syscall *call)
{
    struct qemu_glGetShaderSourceARB *c = (struct qemu_glGetShaderSourceARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShaderSourceARB( c->obj, c->maxLength, QEMU_G2H(c->length), QEMU_G2H(c->source) ));
}

#endif

struct qemu_glGetShaderiv
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShaderiv( GLuint shader, GLenum pname, GLint *params )
{
    struct qemu_glGetShaderiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADERIV);
    call.shader = shader;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShaderiv(struct qemu_syscall *call)
{
    struct qemu_glGetShaderiv *c = (struct qemu_glGetShaderiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShaderiv( c->shader, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetShadingRateImagePaletteNV
{
    struct qemu_syscall super;
    uint64_t viewport;
    uint64_t entry;
    uint64_t rate;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShadingRateImagePaletteNV( GLuint viewport, GLuint entry, GLenum *rate )
{
    struct qemu_glGetShadingRateImagePaletteNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADINGRATEIMAGEPALETTENV);
    call.viewport = viewport;
    call.entry = entry;
    call.rate = (ULONG_PTR)rate;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShadingRateImagePaletteNV(struct qemu_syscall *call)
{
    struct qemu_glGetShadingRateImagePaletteNV *c = (struct qemu_glGetShadingRateImagePaletteNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShadingRateImagePaletteNV( c->viewport, c->entry, QEMU_G2H(c->rate) ));
}

#endif

struct qemu_glGetShadingRateSampleLocationivNV
{
    struct qemu_syscall super;
    uint64_t rate;
    uint64_t samples;
    uint64_t index;
    uint64_t location;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetShadingRateSampleLocationivNV( GLenum rate, GLuint samples, GLuint index, GLint *location )
{
    struct qemu_glGetShadingRateSampleLocationivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHADINGRATESAMPLELOCATIONIVNV);
    call.rate = rate;
    call.samples = samples;
    call.index = index;
    call.location = (ULONG_PTR)location;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetShadingRateSampleLocationivNV(struct qemu_syscall *call)
{
    struct qemu_glGetShadingRateSampleLocationivNV *c = (struct qemu_glGetShadingRateSampleLocationivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetShadingRateSampleLocationivNV( c->rate, c->samples, c->index, QEMU_G2H(c->location) ));
}

#endif

struct qemu_glGetSharpenTexFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSharpenTexFuncSGIS( GLenum target, GLfloat *points )
{
    struct qemu_glGetSharpenTexFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSHARPENTEXFUNCSGIS);
    call.target = target;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSharpenTexFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetSharpenTexFuncSGIS *c = (struct qemu_glGetSharpenTexFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSharpenTexFuncSGIS( c->target, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glGetStageIndexNV
{
    struct qemu_syscall super;
    uint64_t shadertype;
};

#ifdef QEMU_DLL_GUEST

GLushort WINAPI glGetStageIndexNV( GLenum shadertype )
{
    struct qemu_glGetStageIndexNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSTAGEINDEXNV);
    call.shadertype = shadertype;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetStageIndexNV(struct qemu_syscall *call)
{
    struct qemu_glGetStageIndexNV *c = (struct qemu_glGetStageIndexNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetStageIndexNV( c->shadertype ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_glGetSubroutineIndex
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetSubroutineIndex( GLuint program, GLenum shadertype, const GLchar *name )
{
    struct qemu_glGetSubroutineIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSUBROUTINEINDEX);
    call.program = program;
    call.shadertype = shadertype;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetSubroutineIndex(struct qemu_syscall *call)
{
    struct qemu_glGetSubroutineIndex *c = (struct qemu_glGetSubroutineIndex *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetSubroutineIndex( c->program, c->shadertype, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetSubroutineUniformLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t shadertype;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetSubroutineUniformLocation( GLuint program, GLenum shadertype, const GLchar *name )
{
    struct qemu_glGetSubroutineUniformLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSUBROUTINEUNIFORMLOCATION);
    call.program = program;
    call.shadertype = shadertype;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetSubroutineUniformLocation(struct qemu_syscall *call)
{
    struct qemu_glGetSubroutineUniformLocation *c = (struct qemu_glGetSubroutineUniformLocation *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetSubroutineUniformLocation( c->program, c->shadertype, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetSynciv
{
    struct qemu_syscall super;
    uint64_t sync;
    uint64_t pname;
    uint64_t count;
    uint64_t length;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetSynciv( GLsync sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values )
{
    struct qemu_glGetSynciv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETSYNCIV);
    call.sync = (ULONG_PTR)sync;
    call.pname = pname;
    call.count = count;
    call.length = (ULONG_PTR)length;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetSynciv(struct qemu_syscall *call)
{
    struct qemu_glGetSynciv *c = (struct qemu_glGetSynciv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetSynciv( QEMU_G2H(c->sync), c->pname, c->count, QEMU_G2H(c->length), QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetTexBumpParameterfvATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexBumpParameterfvATI( GLenum pname, GLfloat *param )
{
    struct qemu_glGetTexBumpParameterfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXBUMPPARAMETERFVATI);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexBumpParameterfvATI(struct qemu_syscall *call)
{
    struct qemu_glGetTexBumpParameterfvATI *c = (struct qemu_glGetTexBumpParameterfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexBumpParameterfvATI( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetTexBumpParameterivATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexBumpParameterivATI( GLenum pname, GLint *param )
{
    struct qemu_glGetTexBumpParameterivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXBUMPPARAMETERIVATI);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexBumpParameterivATI(struct qemu_syscall *call)
{
    struct qemu_glGetTexBumpParameterivATI *c = (struct qemu_glGetTexBumpParameterivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexBumpParameterivATI( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetTexEnvxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexEnvxvOES( GLenum target, GLenum pname, GLfixed *params )
{
    struct qemu_glGetTexEnvxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXENVXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexEnvxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetTexEnvxvOES *c = (struct qemu_glGetTexEnvxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexEnvxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexFilterFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t filter;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexFilterFuncSGIS( GLenum target, GLenum filter, GLfloat *weights )
{
    struct qemu_glGetTexFilterFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXFILTERFUNCSGIS);
    call.target = target;
    call.filter = filter;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexFilterFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glGetTexFilterFuncSGIS *c = (struct qemu_glGetTexFilterFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexFilterFuncSGIS( c->target, c->filter, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glGetTexGenxvOES
{
    struct qemu_syscall super;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexGenxvOES( GLenum coord, GLenum pname, GLfixed *params )
{
    struct qemu_glGetTexGenxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXGENXVOES);
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexGenxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetTexGenxvOES *c = (struct qemu_glGetTexGenxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexGenxvOES( c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexLevelParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexLevelParameterxvOES( GLenum target, GLint level, GLenum pname, GLfixed *params )
{
    struct qemu_glGetTexLevelParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXLEVELPARAMETERXVOES);
    call.target = target;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexLevelParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetTexLevelParameterxvOES *c = (struct qemu_glGetTexLevelParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexLevelParameterxvOES( c->target, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterIiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterIiv( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetTexParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERIIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterIiv *c = (struct qemu_glGetTexParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterIiv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetTexParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERIIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterIivEXT *c = (struct qemu_glGetTexParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterIivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterIuiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterIuiv( GLenum target, GLenum pname, GLuint *params )
{
    struct qemu_glGetTexParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERIUIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterIuiv *c = (struct qemu_glGetTexParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterIuiv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params )
{
    struct qemu_glGetTexParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERIUIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterIuivEXT *c = (struct qemu_glGetTexParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterIuivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterPointervAPPLE
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterPointervAPPLE( GLenum target, GLenum pname, void **params )
{
    struct qemu_glGetTexParameterPointervAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERPOINTERVAPPLE);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterPointervAPPLE(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterPointervAPPLE *c = (struct qemu_glGetTexParameterPointervAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterPointervAPPLE( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTexParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTexParameterxvOES( GLenum target, GLenum pname, GLfixed *params )
{
    struct qemu_glGetTexParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXPARAMETERXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTexParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glGetTexParameterxvOES *c = (struct qemu_glGetTexParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTexParameterxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureHandleARB
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetTextureHandleARB( GLuint texture )
{
    struct qemu_glGetTextureHandleARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREHANDLEARB);
    call.texture = texture;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetTextureHandleARB(struct qemu_syscall *call)
{
    struct qemu_glGetTextureHandleARB *c = (struct qemu_glGetTextureHandleARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetTextureHandleARB( c->texture ));
}

#endif

struct qemu_glGetTextureHandleNV
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetTextureHandleNV( GLuint texture )
{
    struct qemu_glGetTextureHandleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREHANDLENV);
    call.texture = texture;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetTextureHandleNV(struct qemu_syscall *call)
{
    struct qemu_glGetTextureHandleNV *c = (struct qemu_glGetTextureHandleNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetTextureHandleNV( c->texture ));
}

#endif

struct qemu_glGetTextureImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureImage( GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetTextureImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREIMAGE);
    call.texture = texture;
    call.level = level;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureImage(struct qemu_syscall *call)
{
    struct qemu_glGetTextureImage *c = (struct qemu_glGetTextureImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureImage( c->texture, c->level, c->format, c->type, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetTextureImageEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureImageEXT( GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels )
{
    struct qemu_glGetTextureImageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREIMAGEEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureImageEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureImageEXT *c = (struct qemu_glGetTextureImageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureImageEXT( c->texture, c->target, c->level, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetTextureLevelParameterfv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureLevelParameterfv( GLuint texture, GLint level, GLenum pname, GLfloat *params )
{
    struct qemu_glGetTextureLevelParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURELEVELPARAMETERFV);
    call.texture = texture;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureLevelParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureLevelParameterfv *c = (struct qemu_glGetTextureLevelParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureLevelParameterfv( c->texture, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureLevelParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureLevelParameterfvEXT( GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params )
{
    struct qemu_glGetTextureLevelParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURELEVELPARAMETERFVEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureLevelParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureLevelParameterfvEXT *c = (struct qemu_glGetTextureLevelParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureLevelParameterfvEXT( c->texture, c->target, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureLevelParameteriv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureLevelParameteriv( GLuint texture, GLint level, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureLevelParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURELEVELPARAMETERIV);
    call.texture = texture;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureLevelParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureLevelParameteriv *c = (struct qemu_glGetTextureLevelParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureLevelParameteriv( c->texture, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureLevelParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureLevelParameterivEXT( GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureLevelParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURELEVELPARAMETERIVEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureLevelParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureLevelParameterivEXT *c = (struct qemu_glGetTextureLevelParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureLevelParameterivEXT( c->texture, c->target, c->level, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterIiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterIiv( GLuint texture, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIIV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterIiv *c = (struct qemu_glGetTextureParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterIiv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterIivEXT( GLuint texture, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterIivEXT *c = (struct qemu_glGetTextureParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterIivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterIuiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterIuiv( GLuint texture, GLenum pname, GLuint *params )
{
    struct qemu_glGetTextureParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIUIV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterIuiv *c = (struct qemu_glGetTextureParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterIuiv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterIuivEXT( GLuint texture, GLenum target, GLenum pname, GLuint *params )
{
    struct qemu_glGetTextureParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIUIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterIuivEXT *c = (struct qemu_glGetTextureParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterIuivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterfv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterfv( GLuint texture, GLenum pname, GLfloat *params )
{
    struct qemu_glGetTextureParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERFV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterfv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterfv *c = (struct qemu_glGetTextureParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterfv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterfvEXT( GLuint texture, GLenum target, GLenum pname, GLfloat *params )
{
    struct qemu_glGetTextureParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERFVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterfvEXT *c = (struct qemu_glGetTextureParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterfvEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameteriv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameteriv( GLuint texture, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameteriv(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameteriv *c = (struct qemu_glGetTextureParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameteriv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureParameterivEXT( GLuint texture, GLenum target, GLenum pname, GLint *params )
{
    struct qemu_glGetTextureParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTUREPARAMETERIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTextureParameterivEXT *c = (struct qemu_glGetTextureParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureParameterivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTextureSamplerHandleARB
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t sampler;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetTextureSamplerHandleARB( GLuint texture, GLuint sampler )
{
    struct qemu_glGetTextureSamplerHandleARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURESAMPLERHANDLEARB);
    call.texture = texture;
    call.sampler = sampler;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetTextureSamplerHandleARB(struct qemu_syscall *call)
{
    struct qemu_glGetTextureSamplerHandleARB *c = (struct qemu_glGetTextureSamplerHandleARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetTextureSamplerHandleARB( c->texture, c->sampler ));
}

#endif

struct qemu_glGetTextureSamplerHandleNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t sampler;
};

#ifdef QEMU_DLL_GUEST

GLuint64 WINAPI glGetTextureSamplerHandleNV( GLuint texture, GLuint sampler )
{
    struct qemu_glGetTextureSamplerHandleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURESAMPLERHANDLENV);
    call.texture = texture;
    call.sampler = sampler;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetTextureSamplerHandleNV(struct qemu_syscall *call)
{
    struct qemu_glGetTextureSamplerHandleNV *c = (struct qemu_glGetTextureSamplerHandleNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetTextureSamplerHandleNV( c->texture, c->sampler ));
}

#endif

struct qemu_glGetTextureSubImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTextureSubImage( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetTextureSubImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTEXTURESUBIMAGE);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTextureSubImage(struct qemu_syscall *call)
{
    struct qemu_glGetTextureSubImage *c = (struct qemu_glGetTextureSubImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTextureSubImage( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetTrackMatrixivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t address;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTrackMatrixivNV( GLenum target, GLuint address, GLenum pname, GLint *params )
{
    struct qemu_glGetTrackMatrixivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRACKMATRIXIVNV);
    call.target = target;
    call.address = address;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTrackMatrixivNV(struct qemu_syscall *call)
{
    struct qemu_glGetTrackMatrixivNV *c = (struct qemu_glGetTrackMatrixivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTrackMatrixivNV( c->target, c->address, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetTransformFeedbackVarying
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbackVarying( GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name )
{
    struct qemu_glGetTransformFeedbackVarying call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKVARYING);
    call.program = program;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbackVarying(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbackVarying *c = (struct qemu_glGetTransformFeedbackVarying *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbackVarying( c->program, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetTransformFeedbackVaryingEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t bufSize;
    uint64_t length;
    uint64_t size;
    uint64_t type;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbackVaryingEXT( GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name )
{
    struct qemu_glGetTransformFeedbackVaryingEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKVARYINGEXT);
    call.program = program;
    call.index = index;
    call.bufSize = bufSize;
    call.length = (ULONG_PTR)length;
    call.size = (ULONG_PTR)size;
    call.type = (ULONG_PTR)type;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbackVaryingEXT(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbackVaryingEXT *c = (struct qemu_glGetTransformFeedbackVaryingEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbackVaryingEXT( c->program, c->index, c->bufSize, QEMU_G2H(c->length), QEMU_G2H(c->size), QEMU_G2H(c->type), QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetTransformFeedbackVaryingNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t index;
    uint64_t location;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbackVaryingNV( GLuint program, GLuint index, GLint *location )
{
    struct qemu_glGetTransformFeedbackVaryingNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKVARYINGNV);
    call.program = program;
    call.index = index;
    call.location = (ULONG_PTR)location;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbackVaryingNV(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbackVaryingNV *c = (struct qemu_glGetTransformFeedbackVaryingNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbackVaryingNV( c->program, c->index, QEMU_G2H(c->location) ));
}

#endif

struct qemu_glGetTransformFeedbacki64_v
{
    struct qemu_syscall super;
    uint64_t xfb;
    uint64_t pname;
    uint64_t index;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbacki64_v( GLuint xfb, GLenum pname, GLuint index, GLint64 *param )
{
    struct qemu_glGetTransformFeedbacki64_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKI64_V);
    call.xfb = xfb;
    call.pname = pname;
    call.index = index;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbacki64_v(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbacki64_v *c = (struct qemu_glGetTransformFeedbacki64_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbacki64_v( c->xfb, c->pname, c->index, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetTransformFeedbacki_v
{
    struct qemu_syscall super;
    uint64_t xfb;
    uint64_t pname;
    uint64_t index;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbacki_v( GLuint xfb, GLenum pname, GLuint index, GLint *param )
{
    struct qemu_glGetTransformFeedbacki_v call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKI_V);
    call.xfb = xfb;
    call.pname = pname;
    call.index = index;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbacki_v(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbacki_v *c = (struct qemu_glGetTransformFeedbacki_v *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbacki_v( c->xfb, c->pname, c->index, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetTransformFeedbackiv
{
    struct qemu_syscall super;
    uint64_t xfb;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetTransformFeedbackiv( GLuint xfb, GLenum pname, GLint *param )
{
    struct qemu_glGetTransformFeedbackiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETTRANSFORMFEEDBACKIV);
    call.xfb = xfb;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetTransformFeedbackiv(struct qemu_syscall *call)
{
    struct qemu_glGetTransformFeedbackiv *c = (struct qemu_glGetTransformFeedbackiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetTransformFeedbackiv( c->xfb, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetUniformBlockIndex
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformBlockName;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glGetUniformBlockIndex( GLuint program, const GLchar *uniformBlockName )
{
    struct qemu_glGetUniformBlockIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMBLOCKINDEX);
    call.program = program;
    call.uniformBlockName = (ULONG_PTR)uniformBlockName;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetUniformBlockIndex(struct qemu_syscall *call)
{
    struct qemu_glGetUniformBlockIndex *c = (struct qemu_glGetUniformBlockIndex *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetUniformBlockIndex( c->program, QEMU_G2H(c->uniformBlockName) ));
}

#endif

struct qemu_glGetUniformBufferSizeEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetUniformBufferSizeEXT( GLuint program, GLint location )
{
    struct qemu_glGetUniformBufferSizeEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMBUFFERSIZEEXT);
    call.program = program;
    call.location = location;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetUniformBufferSizeEXT(struct qemu_syscall *call)
{
    struct qemu_glGetUniformBufferSizeEXT *c = (struct qemu_glGetUniformBufferSizeEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetUniformBufferSizeEXT( c->program, c->location ));
}

#endif

struct qemu_glGetUniformIndices
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformCount;
    uint64_t uniformNames;
    uint64_t uniformIndices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformIndices( GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices )
{
    struct qemu_glGetUniformIndices call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMINDICES);
    call.program = program;
    call.uniformCount = uniformCount;
    call.uniformNames = (ULONG_PTR)uniformNames;
    call.uniformIndices = (ULONG_PTR)uniformIndices;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformIndices(struct qemu_syscall *call)
{
    struct qemu_glGetUniformIndices *c = (struct qemu_glGetUniformIndices *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformIndices( c->program, c->uniformCount, QEMU_G2H(c->uniformNames), QEMU_G2H(c->uniformIndices) ));
}

#endif

struct qemu_glGetUniformLocation
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetUniformLocation( GLuint program, const GLchar *name )
{
    struct qemu_glGetUniformLocation call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMLOCATION);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetUniformLocation(struct qemu_syscall *call)
{
    struct qemu_glGetUniformLocation *c = (struct qemu_glGetUniformLocation *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetUniformLocation( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetUniformLocationARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetUniformLocationARB( GLhandleARB programObj, const GLcharARB *name )
{
    struct qemu_glGetUniformLocationARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMLOCATIONARB);
    call.programObj = programObj;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetUniformLocationARB(struct qemu_syscall *call)
{
    struct qemu_glGetUniformLocationARB *c = (struct qemu_glGetUniformLocationARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetUniformLocationARB( c->programObj, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetUniformOffsetEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
};

#ifdef QEMU_DLL_GUEST

GLintptr WINAPI glGetUniformOffsetEXT( GLuint program, GLint location )
{
    struct qemu_glGetUniformOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMOFFSETEXT);
    call.program = program;
    call.location = location;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetUniformOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glGetUniformOffsetEXT *c = (struct qemu_glGetUniformOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetUniformOffsetEXT( c->program, c->location ));
}

#endif

struct qemu_glGetUniformSubroutineuiv
{
    struct qemu_syscall super;
    uint64_t shadertype;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformSubroutineuiv( GLenum shadertype, GLint location, GLuint *params )
{
    struct qemu_glGetUniformSubroutineuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMSUBROUTINEUIV);
    call.shadertype = shadertype;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformSubroutineuiv(struct qemu_syscall *call)
{
    struct qemu_glGetUniformSubroutineuiv *c = (struct qemu_glGetUniformSubroutineuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformSubroutineuiv( c->shadertype, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformdv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformdv( GLuint program, GLint location, GLdouble *params )
{
    struct qemu_glGetUniformdv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMDV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformdv(struct qemu_syscall *call)
{
    struct qemu_glGetUniformdv *c = (struct qemu_glGetUniformdv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformdv( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformfv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformfv( GLuint program, GLint location, GLfloat *params )
{
    struct qemu_glGetUniformfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMFV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformfv(struct qemu_syscall *call)
{
    struct qemu_glGetUniformfv *c = (struct qemu_glGetUniformfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformfv( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformfvARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformfvARB( GLhandleARB programObj, GLint location, GLfloat *params )
{
    struct qemu_glGetUniformfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMFVARB);
    call.programObj = programObj;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetUniformfvARB *c = (struct qemu_glGetUniformfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformfvARB( c->programObj, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformi64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformi64vARB( GLuint program, GLint location, GLint64 *params )
{
    struct qemu_glGetUniformi64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMI64VARB);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformi64vARB(struct qemu_syscall *call)
{
    struct qemu_glGetUniformi64vARB *c = (struct qemu_glGetUniformi64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformi64vARB( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformi64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformi64vNV( GLuint program, GLint location, GLint64EXT *params )
{
    struct qemu_glGetUniformi64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMI64VNV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformi64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetUniformi64vNV *c = (struct qemu_glGetUniformi64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformi64vNV( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformiv( GLuint program, GLint location, GLint *params )
{
    struct qemu_glGetUniformiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMIV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformiv(struct qemu_syscall *call)
{
    struct qemu_glGetUniformiv *c = (struct qemu_glGetUniformiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformiv( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformivARB
{
    struct qemu_syscall super;
    uint64_t programObj;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformivARB( GLhandleARB programObj, GLint location, GLint *params )
{
    struct qemu_glGetUniformivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMIVARB);
    call.programObj = programObj;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformivARB(struct qemu_syscall *call)
{
    struct qemu_glGetUniformivARB *c = (struct qemu_glGetUniformivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformivARB( c->programObj, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformui64vARB( GLuint program, GLint location, GLuint64 *params )
{
    struct qemu_glGetUniformui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMUI64VARB);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformui64vARB(struct qemu_syscall *call)
{
    struct qemu_glGetUniformui64vARB *c = (struct qemu_glGetUniformui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformui64vARB( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformui64vNV( GLuint program, GLint location, GLuint64EXT *params )
{
    struct qemu_glGetUniformui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMUI64VNV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetUniformui64vNV *c = (struct qemu_glGetUniformui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformui64vNV( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformuiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformuiv( GLuint program, GLint location, GLuint *params )
{
    struct qemu_glGetUniformuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMUIV);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformuiv(struct qemu_syscall *call)
{
    struct qemu_glGetUniformuiv *c = (struct qemu_glGetUniformuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformuiv( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUniformuivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUniformuivEXT( GLuint program, GLint location, GLuint *params )
{
    struct qemu_glGetUniformuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNIFORMUIVEXT);
    call.program = program;
    call.location = location;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUniformuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetUniformuivEXT *c = (struct qemu_glGetUniformuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUniformuivEXT( c->program, c->location, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetUnsignedBytei_vEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUnsignedBytei_vEXT( GLenum target, GLuint index, GLubyte *data )
{
    struct qemu_glGetUnsignedBytei_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNSIGNEDBYTEI_VEXT);
    call.target = target;
    call.index = index;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUnsignedBytei_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetUnsignedBytei_vEXT *c = (struct qemu_glGetUnsignedBytei_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUnsignedBytei_vEXT( c->target, c->index, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetUnsignedBytevEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetUnsignedBytevEXT( GLenum pname, GLubyte *data )
{
    struct qemu_glGetUnsignedBytevEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETUNSIGNEDBYTEVEXT);
    call.pname = pname;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetUnsignedBytevEXT(struct qemu_syscall *call)
{
    struct qemu_glGetUnsignedBytevEXT *c = (struct qemu_glGetUnsignedBytevEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetUnsignedBytevEXT( c->pname, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetVariantArrayObjectfvATI
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantArrayObjectfvATI( GLuint id, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVariantArrayObjectfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTARRAYOBJECTFVATI);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantArrayObjectfvATI(struct qemu_syscall *call)
{
    struct qemu_glGetVariantArrayObjectfvATI *c = (struct qemu_glGetVariantArrayObjectfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantArrayObjectfvATI( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVariantArrayObjectivATI
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantArrayObjectivATI( GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glGetVariantArrayObjectivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTARRAYOBJECTIVATI);
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantArrayObjectivATI(struct qemu_syscall *call)
{
    struct qemu_glGetVariantArrayObjectivATI *c = (struct qemu_glGetVariantArrayObjectivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantArrayObjectivATI( c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVariantBooleanvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantBooleanvEXT( GLuint id, GLenum value, GLboolean *data )
{
    struct qemu_glGetVariantBooleanvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTBOOLEANVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantBooleanvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVariantBooleanvEXT *c = (struct qemu_glGetVariantBooleanvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantBooleanvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetVariantFloatvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantFloatvEXT( GLuint id, GLenum value, GLfloat *data )
{
    struct qemu_glGetVariantFloatvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTFLOATVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantFloatvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVariantFloatvEXT *c = (struct qemu_glGetVariantFloatvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantFloatvEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetVariantIntegervEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantIntegervEXT( GLuint id, GLenum value, GLint *data )
{
    struct qemu_glGetVariantIntegervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTINTEGERVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantIntegervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVariantIntegervEXT *c = (struct qemu_glGetVariantIntegervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantIntegervEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetVariantPointervEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t value;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVariantPointervEXT( GLuint id, GLenum value, void **data )
{
    struct qemu_glGetVariantPointervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARIANTPOINTERVEXT);
    call.id = id;
    call.value = value;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVariantPointervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVariantPointervEXT *c = (struct qemu_glGetVariantPointervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVariantPointervEXT( c->id, c->value, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glGetVaryingLocationNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glGetVaryingLocationNV( GLuint program, const GLchar *name )
{
    struct qemu_glGetVaryingLocationNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVARYINGLOCATIONNV);
    call.program = program;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glGetVaryingLocationNV(struct qemu_syscall *call)
{
    struct qemu_glGetVaryingLocationNV *c = (struct qemu_glGetVaryingLocationNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glGetVaryingLocationNV( c->program, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetVertexArrayIndexed64iv
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayIndexed64iv( GLuint vaobj, GLuint index, GLenum pname, GLint64 *param )
{
    struct qemu_glGetVertexArrayIndexed64iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYINDEXED64IV);
    call.vaobj = vaobj;
    call.index = index;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayIndexed64iv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayIndexed64iv *c = (struct qemu_glGetVertexArrayIndexed64iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayIndexed64iv( c->vaobj, c->index, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayIndexediv
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayIndexediv( GLuint vaobj, GLuint index, GLenum pname, GLint *param )
{
    struct qemu_glGetVertexArrayIndexediv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYINDEXEDIV);
    call.vaobj = vaobj;
    call.index = index;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayIndexediv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayIndexediv *c = (struct qemu_glGetVertexArrayIndexediv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayIndexediv( c->vaobj, c->index, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayIntegeri_vEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayIntegeri_vEXT( GLuint vaobj, GLuint index, GLenum pname, GLint *param )
{
    struct qemu_glGetVertexArrayIntegeri_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYINTEGERI_VEXT);
    call.vaobj = vaobj;
    call.index = index;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayIntegeri_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayIntegeri_vEXT *c = (struct qemu_glGetVertexArrayIntegeri_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayIntegeri_vEXT( c->vaobj, c->index, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayIntegervEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayIntegervEXT( GLuint vaobj, GLenum pname, GLint *param )
{
    struct qemu_glGetVertexArrayIntegervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYINTEGERVEXT);
    call.vaobj = vaobj;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayIntegervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayIntegervEXT *c = (struct qemu_glGetVertexArrayIntegervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayIntegervEXT( c->vaobj, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayPointeri_vEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayPointeri_vEXT( GLuint vaobj, GLuint index, GLenum pname, void **param )
{
    struct qemu_glGetVertexArrayPointeri_vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYPOINTERI_VEXT);
    call.vaobj = vaobj;
    call.index = index;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayPointeri_vEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayPointeri_vEXT *c = (struct qemu_glGetVertexArrayPointeri_vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayPointeri_vEXT( c->vaobj, c->index, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayPointervEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayPointervEXT( GLuint vaobj, GLenum pname, void **param )
{
    struct qemu_glGetVertexArrayPointervEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYPOINTERVEXT);
    call.vaobj = vaobj;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayPointervEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayPointervEXT *c = (struct qemu_glGetVertexArrayPointervEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayPointervEXT( c->vaobj, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexArrayiv
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexArrayiv( GLuint vaobj, GLenum pname, GLint *param )
{
    struct qemu_glGetVertexArrayiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXARRAYIV);
    call.vaobj = vaobj;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexArrayiv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexArrayiv *c = (struct qemu_glGetVertexArrayiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexArrayiv( c->vaobj, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glGetVertexAttribArrayObjectfvATI
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribArrayObjectfvATI( GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVertexAttribArrayObjectfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBARRAYOBJECTFVATI);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribArrayObjectfvATI(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribArrayObjectfvATI *c = (struct qemu_glGetVertexAttribArrayObjectfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribArrayObjectfvATI( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribArrayObjectivATI
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribArrayObjectivATI( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribArrayObjectivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBARRAYOBJECTIVATI);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribArrayObjectivATI(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribArrayObjectivATI *c = (struct qemu_glGetVertexAttribArrayObjectivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribArrayObjectivATI( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribIiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribIiv( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIIV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribIiv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribIiv *c = (struct qemu_glGetVertexAttribIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribIiv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribIivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribIivEXT( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIIVEXT);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribIivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribIivEXT *c = (struct qemu_glGetVertexAttribIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribIivEXT( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribIuiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribIuiv( GLuint index, GLenum pname, GLuint *params )
{
    struct qemu_glGetVertexAttribIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIUIV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribIuiv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribIuiv *c = (struct qemu_glGetVertexAttribIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribIuiv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribIuivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribIuivEXT( GLuint index, GLenum pname, GLuint *params )
{
    struct qemu_glGetVertexAttribIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIUIVEXT);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribIuivEXT *c = (struct qemu_glGetVertexAttribIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribIuivEXT( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribLdv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribLdv( GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVertexAttribLdv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBLDV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribLdv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribLdv *c = (struct qemu_glGetVertexAttribLdv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribLdv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribLdvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribLdvEXT( GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVertexAttribLdvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBLDVEXT);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribLdvEXT(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribLdvEXT *c = (struct qemu_glGetVertexAttribLdvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribLdvEXT( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribLi64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribLi64vNV( GLuint index, GLenum pname, GLint64EXT *params )
{
    struct qemu_glGetVertexAttribLi64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBLI64VNV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribLi64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribLi64vNV *c = (struct qemu_glGetVertexAttribLi64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribLi64vNV( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribLui64vARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribLui64vARB( GLuint index, GLenum pname, GLuint64EXT *params )
{
    struct qemu_glGetVertexAttribLui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBLUI64VARB);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribLui64vARB(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribLui64vARB *c = (struct qemu_glGetVertexAttribLui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribLui64vARB( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribLui64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribLui64vNV( GLuint index, GLenum pname, GLuint64EXT *params )
{
    struct qemu_glGetVertexAttribLui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBLUI64VNV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribLui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribLui64vNV *c = (struct qemu_glGetVertexAttribLui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribLui64vNV( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribPointerv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribPointerv( GLuint index, GLenum pname, void **pointer )
{
    struct qemu_glGetVertexAttribPointerv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBPOINTERV);
    call.index = index;
    call.pname = pname;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribPointerv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribPointerv *c = (struct qemu_glGetVertexAttribPointerv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribPointerv( c->index, c->pname, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glGetVertexAttribPointervARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribPointervARB( GLuint index, GLenum pname, void **pointer )
{
    struct qemu_glGetVertexAttribPointervARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBPOINTERVARB);
    call.index = index;
    call.pname = pname;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribPointervARB(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribPointervARB *c = (struct qemu_glGetVertexAttribPointervARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribPointervARB( c->index, c->pname, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glGetVertexAttribPointervNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribPointervNV( GLuint index, GLenum pname, void **pointer )
{
    struct qemu_glGetVertexAttribPointervNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBPOINTERVNV);
    call.index = index;
    call.pname = pname;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribPointervNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribPointervNV *c = (struct qemu_glGetVertexAttribPointervNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribPointervNV( c->index, c->pname, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glGetVertexAttribdv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribdv( GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVertexAttribdv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBDV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribdv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribdv *c = (struct qemu_glGetVertexAttribdv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribdv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribdvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribdvARB( GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVertexAttribdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBDVARB);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribdvARB(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribdvARB *c = (struct qemu_glGetVertexAttribdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribdvARB( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribdvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribdvNV( GLuint index, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVertexAttribdvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBDVNV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribdvNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribdvNV *c = (struct qemu_glGetVertexAttribdvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribdvNV( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribfv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribfv( GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVertexAttribfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBFV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribfv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribfv *c = (struct qemu_glGetVertexAttribfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribfv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribfvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribfvARB( GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVertexAttribfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBFVARB);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribfvARB *c = (struct qemu_glGetVertexAttribfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribfvARB( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribfvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribfvNV( GLuint index, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVertexAttribfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBFVNV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribfvNV *c = (struct qemu_glGetVertexAttribfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribfvNV( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribiv( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribiv(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribiv *c = (struct qemu_glGetVertexAttribiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribiv( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribivARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribivARB( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIVARB);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribivARB(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribivARB *c = (struct qemu_glGetVertexAttribivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribivARB( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVertexAttribivNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVertexAttribivNV( GLuint index, GLenum pname, GLint *params )
{
    struct qemu_glGetVertexAttribivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVERTEXATTRIBIVNV);
    call.index = index;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVertexAttribivNV(struct qemu_syscall *call)
{
    struct qemu_glGetVertexAttribivNV *c = (struct qemu_glGetVertexAttribivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVertexAttribivNV( c->index, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoCaptureStreamdvNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoCaptureStreamdvNV( GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params )
{
    struct qemu_glGetVideoCaptureStreamdvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOCAPTURESTREAMDVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoCaptureStreamdvNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoCaptureStreamdvNV *c = (struct qemu_glGetVideoCaptureStreamdvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoCaptureStreamdvNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoCaptureStreamfvNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoCaptureStreamfvNV( GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params )
{
    struct qemu_glGetVideoCaptureStreamfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOCAPTURESTREAMFVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoCaptureStreamfvNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoCaptureStreamfvNV *c = (struct qemu_glGetVideoCaptureStreamfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoCaptureStreamfvNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoCaptureStreamivNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoCaptureStreamivNV( GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params )
{
    struct qemu_glGetVideoCaptureStreamivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOCAPTURESTREAMIVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoCaptureStreamivNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoCaptureStreamivNV *c = (struct qemu_glGetVideoCaptureStreamivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoCaptureStreamivNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoCaptureivNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoCaptureivNV( GLuint video_capture_slot, GLenum pname, GLint *params )
{
    struct qemu_glGetVideoCaptureivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOCAPTUREIVNV);
    call.video_capture_slot = video_capture_slot;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoCaptureivNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoCaptureivNV *c = (struct qemu_glGetVideoCaptureivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoCaptureivNV( c->video_capture_slot, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoi64vNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoi64vNV( GLuint video_slot, GLenum pname, GLint64EXT *params )
{
    struct qemu_glGetVideoi64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOI64VNV);
    call.video_slot = video_slot;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoi64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoi64vNV *c = (struct qemu_glGetVideoi64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoi64vNV( c->video_slot, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoivNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoivNV( GLuint video_slot, GLenum pname, GLint *params )
{
    struct qemu_glGetVideoivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOIVNV);
    call.video_slot = video_slot;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoivNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoivNV *c = (struct qemu_glGetVideoivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoivNV( c->video_slot, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideoui64vNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideoui64vNV( GLuint video_slot, GLenum pname, GLuint64EXT *params )
{
    struct qemu_glGetVideoui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOUI64VNV);
    call.video_slot = video_slot;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideoui64vNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideoui64vNV *c = (struct qemu_glGetVideoui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideoui64vNV( c->video_slot, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVideouivNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetVideouivNV( GLuint video_slot, GLenum pname, GLuint *params )
{
    struct qemu_glGetVideouivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVIDEOUIVNV);
    call.video_slot = video_slot;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetVideouivNV(struct qemu_syscall *call)
{
    struct qemu_glGetVideouivNV *c = (struct qemu_glGetVideouivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetVideouivNV( c->video_slot, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetVkProcAddrNV
{
    struct qemu_syscall super;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLVULKANPROCNV WINAPI glGetVkProcAddrNV( const GLchar *name )
{
    struct qemu_glGetVkProcAddrNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETVKPROCADDRNV);
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glGetVkProcAddrNV(struct qemu_syscall *call)
{
    struct qemu_glGetVkProcAddrNV *c = (struct qemu_glGetVkProcAddrNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glGetVkProcAddrNV( QEMU_G2H(c->name) ));
}

#endif

struct qemu_glGetnColorTable
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnColorTable( GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table )
{
    struct qemu_glGetnColorTable call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCOLORTABLE);
    call.target = target;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnColorTable(struct qemu_syscall *call)
{
    struct qemu_glGetnColorTable *c = (struct qemu_glGetnColorTable *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnColorTable( c->target, c->format, c->type, c->bufSize, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glGetnColorTableARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t table;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnColorTableARB( GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table )
{
    struct qemu_glGetnColorTableARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCOLORTABLEARB);
    call.target = target;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.table = (ULONG_PTR)table;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnColorTableARB(struct qemu_syscall *call)
{
    struct qemu_glGetnColorTableARB *c = (struct qemu_glGetnColorTableARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnColorTableARB( c->target, c->format, c->type, c->bufSize, QEMU_G2H(c->table) ));
}

#endif

struct qemu_glGetnCompressedTexImage
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t lod;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnCompressedTexImage( GLenum target, GLint lod, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetnCompressedTexImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCOMPRESSEDTEXIMAGE);
    call.target = target;
    call.lod = lod;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnCompressedTexImage(struct qemu_syscall *call)
{
    struct qemu_glGetnCompressedTexImage *c = (struct qemu_glGetnCompressedTexImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnCompressedTexImage( c->target, c->lod, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetnCompressedTexImageARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t lod;
    uint64_t bufSize;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnCompressedTexImageARB( GLenum target, GLint lod, GLsizei bufSize, void *img )
{
    struct qemu_glGetnCompressedTexImageARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCOMPRESSEDTEXIMAGEARB);
    call.target = target;
    call.lod = lod;
    call.bufSize = bufSize;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnCompressedTexImageARB(struct qemu_syscall *call)
{
    struct qemu_glGetnCompressedTexImageARB *c = (struct qemu_glGetnCompressedTexImageARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnCompressedTexImageARB( c->target, c->lod, c->bufSize, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetnConvolutionFilter
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnConvolutionFilter( GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image )
{
    struct qemu_glGetnConvolutionFilter call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCONVOLUTIONFILTER);
    call.target = target;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnConvolutionFilter(struct qemu_syscall *call)
{
    struct qemu_glGetnConvolutionFilter *c = (struct qemu_glGetnConvolutionFilter *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnConvolutionFilter( c->target, c->format, c->type, c->bufSize, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glGetnConvolutionFilterARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t image;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnConvolutionFilterARB( GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image )
{
    struct qemu_glGetnConvolutionFilterARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNCONVOLUTIONFILTERARB);
    call.target = target;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.image = (ULONG_PTR)image;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnConvolutionFilterARB(struct qemu_syscall *call)
{
    struct qemu_glGetnConvolutionFilterARB *c = (struct qemu_glGetnConvolutionFilterARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnConvolutionFilterARB( c->target, c->format, c->type, c->bufSize, QEMU_G2H(c->image) ));
}

#endif

struct qemu_glGetnHistogram
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnHistogram( GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values )
{
    struct qemu_glGetnHistogram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNHISTOGRAM);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnHistogram(struct qemu_syscall *call)
{
    struct qemu_glGetnHistogram *c = (struct qemu_glGetnHistogram *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnHistogram( c->target, c->reset, c->format, c->type, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnHistogramARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnHistogramARB( GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values )
{
    struct qemu_glGetnHistogramARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNHISTOGRAMARB);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnHistogramARB(struct qemu_syscall *call)
{
    struct qemu_glGetnHistogramARB *c = (struct qemu_glGetnHistogramARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnHistogramARB( c->target, c->reset, c->format, c->type, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnMapdv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapdv( GLenum target, GLenum query, GLsizei bufSize, GLdouble *v )
{
    struct qemu_glGetnMapdv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPDV);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapdv(struct qemu_syscall *call)
{
    struct qemu_glGetnMapdv *c = (struct qemu_glGetnMapdv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapdv( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMapdvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapdvARB( GLenum target, GLenum query, GLsizei bufSize, GLdouble *v )
{
    struct qemu_glGetnMapdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPDVARB);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapdvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnMapdvARB *c = (struct qemu_glGetnMapdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapdvARB( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMapfv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapfv( GLenum target, GLenum query, GLsizei bufSize, GLfloat *v )
{
    struct qemu_glGetnMapfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPFV);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapfv(struct qemu_syscall *call)
{
    struct qemu_glGetnMapfv *c = (struct qemu_glGetnMapfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapfv( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMapfvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapfvARB( GLenum target, GLenum query, GLsizei bufSize, GLfloat *v )
{
    struct qemu_glGetnMapfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPFVARB);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnMapfvARB *c = (struct qemu_glGetnMapfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapfvARB( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMapiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapiv( GLenum target, GLenum query, GLsizei bufSize, GLint *v )
{
    struct qemu_glGetnMapiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPIV);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapiv(struct qemu_syscall *call)
{
    struct qemu_glGetnMapiv *c = (struct qemu_glGetnMapiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapiv( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMapivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t query;
    uint64_t bufSize;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMapivARB( GLenum target, GLenum query, GLsizei bufSize, GLint *v )
{
    struct qemu_glGetnMapivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMAPIVARB);
    call.target = target;
    call.query = query;
    call.bufSize = bufSize;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMapivARB(struct qemu_syscall *call)
{
    struct qemu_glGetnMapivARB *c = (struct qemu_glGetnMapivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMapivARB( c->target, c->query, c->bufSize, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glGetnMinmax
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMinmax( GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values )
{
    struct qemu_glGetnMinmax call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMINMAX);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMinmax(struct qemu_syscall *call)
{
    struct qemu_glGetnMinmax *c = (struct qemu_glGetnMinmax *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMinmax( c->target, c->reset, c->format, c->type, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnMinmaxARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t reset;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnMinmaxARB( GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values )
{
    struct qemu_glGetnMinmaxARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNMINMAXARB);
    call.target = target;
    call.reset = reset;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnMinmaxARB(struct qemu_syscall *call)
{
    struct qemu_glGetnMinmaxARB *c = (struct qemu_glGetnMinmaxARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnMinmaxARB( c->target, c->reset, c->format, c->type, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapfv
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapfv( GLenum map, GLsizei bufSize, GLfloat *values )
{
    struct qemu_glGetnPixelMapfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPFV);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapfv(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapfv *c = (struct qemu_glGetnPixelMapfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapfv( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapfvARB
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapfvARB( GLenum map, GLsizei bufSize, GLfloat *values )
{
    struct qemu_glGetnPixelMapfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPFVARB);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapfvARB *c = (struct qemu_glGetnPixelMapfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapfvARB( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapuiv
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapuiv( GLenum map, GLsizei bufSize, GLuint *values )
{
    struct qemu_glGetnPixelMapuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPUIV);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapuiv(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapuiv *c = (struct qemu_glGetnPixelMapuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapuiv( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapuivARB
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapuivARB( GLenum map, GLsizei bufSize, GLuint *values )
{
    struct qemu_glGetnPixelMapuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPUIVARB);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapuivARB(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapuivARB *c = (struct qemu_glGetnPixelMapuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapuivARB( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapusv
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapusv( GLenum map, GLsizei bufSize, GLushort *values )
{
    struct qemu_glGetnPixelMapusv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPUSV);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapusv(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapusv *c = (struct qemu_glGetnPixelMapusv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapusv( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPixelMapusvARB
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t bufSize;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPixelMapusvARB( GLenum map, GLsizei bufSize, GLushort *values )
{
    struct qemu_glGetnPixelMapusvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPIXELMAPUSVARB);
    call.map = map;
    call.bufSize = bufSize;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPixelMapusvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnPixelMapusvARB *c = (struct qemu_glGetnPixelMapusvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPixelMapusvARB( c->map, c->bufSize, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glGetnPolygonStipple
{
    struct qemu_syscall super;
    uint64_t bufSize;
    uint64_t pattern;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPolygonStipple( GLsizei bufSize, GLubyte *pattern )
{
    struct qemu_glGetnPolygonStipple call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPOLYGONSTIPPLE);
    call.bufSize = bufSize;
    call.pattern = (ULONG_PTR)pattern;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPolygonStipple(struct qemu_syscall *call)
{
    struct qemu_glGetnPolygonStipple *c = (struct qemu_glGetnPolygonStipple *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPolygonStipple( c->bufSize, QEMU_G2H(c->pattern) ));
}

#endif

struct qemu_glGetnPolygonStippleARB
{
    struct qemu_syscall super;
    uint64_t bufSize;
    uint64_t pattern;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnPolygonStippleARB( GLsizei bufSize, GLubyte *pattern )
{
    struct qemu_glGetnPolygonStippleARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNPOLYGONSTIPPLEARB);
    call.bufSize = bufSize;
    call.pattern = (ULONG_PTR)pattern;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnPolygonStippleARB(struct qemu_syscall *call)
{
    struct qemu_glGetnPolygonStippleARB *c = (struct qemu_glGetnPolygonStippleARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnPolygonStippleARB( c->bufSize, QEMU_G2H(c->pattern) ));
}

#endif

struct qemu_glGetnSeparableFilter
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t rowBufSize;
    uint64_t row;
    uint64_t columnBufSize;
    uint64_t column;
    uint64_t span;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnSeparableFilter( GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span )
{
    struct qemu_glGetnSeparableFilter call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNSEPARABLEFILTER);
    call.target = target;
    call.format = format;
    call.type = type;
    call.rowBufSize = rowBufSize;
    call.row = (ULONG_PTR)row;
    call.columnBufSize = columnBufSize;
    call.column = (ULONG_PTR)column;
    call.span = (ULONG_PTR)span;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnSeparableFilter(struct qemu_syscall *call)
{
    struct qemu_glGetnSeparableFilter *c = (struct qemu_glGetnSeparableFilter *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnSeparableFilter( c->target, c->format, c->type, c->rowBufSize, QEMU_G2H(c->row), c->columnBufSize, QEMU_G2H(c->column), QEMU_G2H(c->span) ));
}

#endif

struct qemu_glGetnSeparableFilterARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t type;
    uint64_t rowBufSize;
    uint64_t row;
    uint64_t columnBufSize;
    uint64_t column;
    uint64_t span;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnSeparableFilterARB( GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span )
{
    struct qemu_glGetnSeparableFilterARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNSEPARABLEFILTERARB);
    call.target = target;
    call.format = format;
    call.type = type;
    call.rowBufSize = rowBufSize;
    call.row = (ULONG_PTR)row;
    call.columnBufSize = columnBufSize;
    call.column = (ULONG_PTR)column;
    call.span = (ULONG_PTR)span;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnSeparableFilterARB(struct qemu_syscall *call)
{
    struct qemu_glGetnSeparableFilterARB *c = (struct qemu_glGetnSeparableFilterARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnSeparableFilterARB( c->target, c->format, c->type, c->rowBufSize, QEMU_G2H(c->row), c->columnBufSize, QEMU_G2H(c->column), QEMU_G2H(c->span) ));
}

#endif

struct qemu_glGetnTexImage
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnTexImage( GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels )
{
    struct qemu_glGetnTexImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNTEXIMAGE);
    call.target = target;
    call.level = level;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnTexImage(struct qemu_syscall *call)
{
    struct qemu_glGetnTexImage *c = (struct qemu_glGetnTexImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnTexImage( c->target, c->level, c->format, c->type, c->bufSize, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glGetnTexImageARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t img;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnTexImageARB( GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img )
{
    struct qemu_glGetnTexImageARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNTEXIMAGEARB);
    call.target = target;
    call.level = level;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.img = (ULONG_PTR)img;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnTexImageARB(struct qemu_syscall *call)
{
    struct qemu_glGetnTexImageARB *c = (struct qemu_glGetnTexImageARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnTexImageARB( c->target, c->level, c->format, c->type, c->bufSize, QEMU_G2H(c->img) ));
}

#endif

struct qemu_glGetnUniformdv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformdv( GLuint program, GLint location, GLsizei bufSize, GLdouble *params )
{
    struct qemu_glGetnUniformdv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMDV);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformdv(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformdv *c = (struct qemu_glGetnUniformdv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformdv( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformdvARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformdvARB( GLuint program, GLint location, GLsizei bufSize, GLdouble *params )
{
    struct qemu_glGetnUniformdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMDVARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformdvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformdvARB *c = (struct qemu_glGetnUniformdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformdvARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformfv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformfv( GLuint program, GLint location, GLsizei bufSize, GLfloat *params )
{
    struct qemu_glGetnUniformfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMFV);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformfv(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformfv *c = (struct qemu_glGetnUniformfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformfv( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformfvARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformfvARB( GLuint program, GLint location, GLsizei bufSize, GLfloat *params )
{
    struct qemu_glGetnUniformfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMFVARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformfvARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformfvARB *c = (struct qemu_glGetnUniformfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformfvARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformi64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformi64vARB( GLuint program, GLint location, GLsizei bufSize, GLint64 *params )
{
    struct qemu_glGetnUniformi64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMI64VARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformi64vARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformi64vARB *c = (struct qemu_glGetnUniformi64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformi64vARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformiv( GLuint program, GLint location, GLsizei bufSize, GLint *params )
{
    struct qemu_glGetnUniformiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMIV);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformiv(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformiv *c = (struct qemu_glGetnUniformiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformiv( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformivARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformivARB( GLuint program, GLint location, GLsizei bufSize, GLint *params )
{
    struct qemu_glGetnUniformivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMIVARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformivARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformivARB *c = (struct qemu_glGetnUniformivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformivARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformui64vARB( GLuint program, GLint location, GLsizei bufSize, GLuint64 *params )
{
    struct qemu_glGetnUniformui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMUI64VARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformui64vARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformui64vARB *c = (struct qemu_glGetnUniformui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformui64vARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformuiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformuiv( GLuint program, GLint location, GLsizei bufSize, GLuint *params )
{
    struct qemu_glGetnUniformuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMUIV);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformuiv(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformuiv *c = (struct qemu_glGetnUniformuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformuiv( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGetnUniformuivARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t bufSize;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGetnUniformuivARB( GLuint program, GLint location, GLsizei bufSize, GLuint *params )
{
    struct qemu_glGetnUniformuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGETNUNIFORMUIVARB);
    call.program = program;
    call.location = location;
    call.bufSize = bufSize;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glGetnUniformuivARB(struct qemu_syscall *call)
{
    struct qemu_glGetnUniformuivARB *c = (struct qemu_glGetnUniformuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glGetnUniformuivARB( c->program, c->location, c->bufSize, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glGlobalAlphaFactorbSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactorbSUN( GLbyte factor )
{
    struct qemu_glGlobalAlphaFactorbSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORBSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactorbSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactorbSUN *c = (struct qemu_glGlobalAlphaFactorbSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactorbSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactordSUN
{
    struct qemu_syscall super;
    double factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactordSUN( GLdouble factor )
{
    struct qemu_glGlobalAlphaFactordSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORDSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactordSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactordSUN *c = (struct qemu_glGlobalAlphaFactordSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactordSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactorfSUN
{
    struct qemu_syscall super;
    double factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactorfSUN( GLfloat factor )
{
    struct qemu_glGlobalAlphaFactorfSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORFSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactorfSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactorfSUN *c = (struct qemu_glGlobalAlphaFactorfSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactorfSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactoriSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactoriSUN( GLint factor )
{
    struct qemu_glGlobalAlphaFactoriSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORISUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactoriSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactoriSUN *c = (struct qemu_glGlobalAlphaFactoriSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactoriSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactorsSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactorsSUN( GLshort factor )
{
    struct qemu_glGlobalAlphaFactorsSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORSSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactorsSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactorsSUN *c = (struct qemu_glGlobalAlphaFactorsSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactorsSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactorubSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactorubSUN( GLubyte factor )
{
    struct qemu_glGlobalAlphaFactorubSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORUBSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactorubSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactorubSUN *c = (struct qemu_glGlobalAlphaFactorubSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactorubSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactoruiSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactoruiSUN( GLuint factor )
{
    struct qemu_glGlobalAlphaFactoruiSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORUISUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactoruiSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactoruiSUN *c = (struct qemu_glGlobalAlphaFactoruiSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactoruiSUN( c->factor ));
}

#endif

struct qemu_glGlobalAlphaFactorusSUN
{
    struct qemu_syscall super;
    uint64_t factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glGlobalAlphaFactorusSUN( GLushort factor )
{
    struct qemu_glGlobalAlphaFactorusSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLGLOBALALPHAFACTORUSSUN);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glGlobalAlphaFactorusSUN(struct qemu_syscall *call)
{
    struct qemu_glGlobalAlphaFactorusSUN *c = (struct qemu_glGlobalAlphaFactorusSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glGlobalAlphaFactorusSUN( c->factor ));
}

#endif

struct qemu_glHintPGI
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glHintPGI( GLenum target, GLint mode )
{
    struct qemu_glHintPGI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLHINTPGI);
    call.target = target;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glHintPGI(struct qemu_syscall *call)
{
    struct qemu_glHintPGI *c = (struct qemu_glHintPGI *)call;
    WINE_FIXME("Unverified\n");
    (p_glHintPGI( c->target, c->mode ));
}

#endif

struct qemu_glHistogram
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t width;
    uint64_t internalformat;
    uint64_t sink;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glHistogram( GLenum target, GLsizei width, GLenum internalformat, GLboolean sink )
{
    struct qemu_glHistogram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLHISTOGRAM);
    call.target = target;
    call.width = width;
    call.internalformat = internalformat;
    call.sink = sink;

    qemu_syscall(&call.super);
}

#else

void qemu_glHistogram(struct qemu_syscall *call)
{
    struct qemu_glHistogram *c = (struct qemu_glHistogram *)call;
    WINE_FIXME("Unverified\n");
    (p_glHistogram( c->target, c->width, c->internalformat, c->sink ));
}

#endif

struct qemu_glHistogramEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t width;
    uint64_t internalformat;
    uint64_t sink;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glHistogramEXT( GLenum target, GLsizei width, GLenum internalformat, GLboolean sink )
{
    struct qemu_glHistogramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLHISTOGRAMEXT);
    call.target = target;
    call.width = width;
    call.internalformat = internalformat;
    call.sink = sink;

    qemu_syscall(&call.super);
}

#else

void qemu_glHistogramEXT(struct qemu_syscall *call)
{
    struct qemu_glHistogramEXT *c = (struct qemu_glHistogramEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glHistogramEXT( c->target, c->width, c->internalformat, c->sink ));
}

#endif

struct qemu_glIglooInterfaceSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIglooInterfaceSGIX( GLenum pname, const void *params )
{
    struct qemu_glIglooInterfaceSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIGLOOINTERFACESGIX);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glIglooInterfaceSGIX(struct qemu_syscall *call)
{
    struct qemu_glIglooInterfaceSGIX *c = (struct qemu_glIglooInterfaceSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glIglooInterfaceSGIX( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glImageTransformParameterfHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImageTransformParameterfHP( GLenum target, GLenum pname, GLfloat param )
{
    struct qemu_glImageTransformParameterfHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMAGETRANSFORMPARAMETERFHP);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glImageTransformParameterfHP(struct qemu_syscall *call)
{
    struct qemu_glImageTransformParameterfHP *c = (struct qemu_glImageTransformParameterfHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glImageTransformParameterfHP( c->target, c->pname, c->param ));
}

#endif

struct qemu_glImageTransformParameterfvHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImageTransformParameterfvHP( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glImageTransformParameterfvHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMAGETRANSFORMPARAMETERFVHP);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glImageTransformParameterfvHP(struct qemu_syscall *call)
{
    struct qemu_glImageTransformParameterfvHP *c = (struct qemu_glImageTransformParameterfvHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glImageTransformParameterfvHP( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glImageTransformParameteriHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImageTransformParameteriHP( GLenum target, GLenum pname, GLint param )
{
    struct qemu_glImageTransformParameteriHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMAGETRANSFORMPARAMETERIHP);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glImageTransformParameteriHP(struct qemu_syscall *call)
{
    struct qemu_glImageTransformParameteriHP *c = (struct qemu_glImageTransformParameteriHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glImageTransformParameteriHP( c->target, c->pname, c->param ));
}

#endif

struct qemu_glImageTransformParameterivHP
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImageTransformParameterivHP( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glImageTransformParameterivHP call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMAGETRANSFORMPARAMETERIVHP);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glImageTransformParameterivHP(struct qemu_syscall *call)
{
    struct qemu_glImageTransformParameterivHP *c = (struct qemu_glImageTransformParameterivHP *)call;
    WINE_FIXME("Unverified\n");
    (p_glImageTransformParameterivHP( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glImportMemoryFdEXT
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t size;
    uint64_t handleType;
    uint64_t fd;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportMemoryFdEXT( GLuint memory, GLuint64 size, GLenum handleType, GLint fd )
{
    struct qemu_glImportMemoryFdEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTMEMORYFDEXT);
    call.memory = memory;
    call.size = size;
    call.handleType = handleType;
    call.fd = fd;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportMemoryFdEXT(struct qemu_syscall *call)
{
    struct qemu_glImportMemoryFdEXT *c = (struct qemu_glImportMemoryFdEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportMemoryFdEXT( c->memory, c->size, c->handleType, c->fd ));
}

#endif

struct qemu_glImportMemoryWin32HandleEXT
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t size;
    uint64_t handleType;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportMemoryWin32HandleEXT( GLuint memory, GLuint64 size, GLenum handleType, void *handle )
{
    struct qemu_glImportMemoryWin32HandleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTMEMORYWIN32HANDLEEXT);
    call.memory = memory;
    call.size = size;
    call.handleType = handleType;
    call.handle = (ULONG_PTR)handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportMemoryWin32HandleEXT(struct qemu_syscall *call)
{
    struct qemu_glImportMemoryWin32HandleEXT *c = (struct qemu_glImportMemoryWin32HandleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportMemoryWin32HandleEXT( c->memory, c->size, c->handleType, QEMU_G2H(c->handle) ));
}

#endif

struct qemu_glImportMemoryWin32NameEXT
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t size;
    uint64_t handleType;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportMemoryWin32NameEXT( GLuint memory, GLuint64 size, GLenum handleType, const void *name )
{
    struct qemu_glImportMemoryWin32NameEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTMEMORYWIN32NAMEEXT);
    call.memory = memory;
    call.size = size;
    call.handleType = handleType;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportMemoryWin32NameEXT(struct qemu_syscall *call)
{
    struct qemu_glImportMemoryWin32NameEXT *c = (struct qemu_glImportMemoryWin32NameEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportMemoryWin32NameEXT( c->memory, c->size, c->handleType, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glImportSemaphoreFdEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t handleType;
    uint64_t fd;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportSemaphoreFdEXT( GLuint semaphore, GLenum handleType, GLint fd )
{
    struct qemu_glImportSemaphoreFdEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTSEMAPHOREFDEXT);
    call.semaphore = semaphore;
    call.handleType = handleType;
    call.fd = fd;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportSemaphoreFdEXT(struct qemu_syscall *call)
{
    struct qemu_glImportSemaphoreFdEXT *c = (struct qemu_glImportSemaphoreFdEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportSemaphoreFdEXT( c->semaphore, c->handleType, c->fd ));
}

#endif

struct qemu_glImportSemaphoreWin32HandleEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t handleType;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportSemaphoreWin32HandleEXT( GLuint semaphore, GLenum handleType, void *handle )
{
    struct qemu_glImportSemaphoreWin32HandleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTSEMAPHOREWIN32HANDLEEXT);
    call.semaphore = semaphore;
    call.handleType = handleType;
    call.handle = (ULONG_PTR)handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportSemaphoreWin32HandleEXT(struct qemu_syscall *call)
{
    struct qemu_glImportSemaphoreWin32HandleEXT *c = (struct qemu_glImportSemaphoreWin32HandleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportSemaphoreWin32HandleEXT( c->semaphore, c->handleType, QEMU_G2H(c->handle) ));
}

#endif

struct qemu_glImportSemaphoreWin32NameEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t handleType;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glImportSemaphoreWin32NameEXT( GLuint semaphore, GLenum handleType, const void *name )
{
    struct qemu_glImportSemaphoreWin32NameEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTSEMAPHOREWIN32NAMEEXT);
    call.semaphore = semaphore;
    call.handleType = handleType;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);
}

#else

void qemu_glImportSemaphoreWin32NameEXT(struct qemu_syscall *call)
{
    struct qemu_glImportSemaphoreWin32NameEXT *c = (struct qemu_glImportSemaphoreWin32NameEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glImportSemaphoreWin32NameEXT( c->semaphore, c->handleType, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glImportSyncEXT
{
    struct qemu_syscall super;
    uint64_t external_sync_type;
    uint64_t external_sync;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

GLsync WINAPI glImportSyncEXT( GLenum external_sync_type, GLintptr external_sync, GLbitfield flags )
{
    struct qemu_glImportSyncEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLIMPORTSYNCEXT);
    call.external_sync_type = external_sync_type;
    call.external_sync = external_sync;
    call.flags = flags;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glImportSyncEXT(struct qemu_syscall *call)
{
    struct qemu_glImportSyncEXT *c = (struct qemu_glImportSyncEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glImportSyncEXT( c->external_sync_type, c->external_sync, c->flags ));
}

#endif

struct qemu_glIndexFormatNV
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexFormatNV( GLenum type, GLsizei stride )
{
    struct qemu_glIndexFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXFORMATNV);
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexFormatNV(struct qemu_syscall *call)
{
    struct qemu_glIndexFormatNV *c = (struct qemu_glIndexFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexFormatNV( c->type, c->stride ));
}

#endif

struct qemu_glIndexFuncEXT
{
    struct qemu_syscall super;
    uint64_t func;
    double ref;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexFuncEXT( GLenum func, GLclampf ref )
{
    struct qemu_glIndexFuncEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXFUNCEXT);
    call.func = func;
    call.ref = ref;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexFuncEXT(struct qemu_syscall *call)
{
    struct qemu_glIndexFuncEXT *c = (struct qemu_glIndexFuncEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexFuncEXT( c->func, c->ref ));
}

#endif

struct qemu_glIndexMaterialEXT
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexMaterialEXT( GLenum face, GLenum mode )
{
    struct qemu_glIndexMaterialEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXMATERIALEXT);
    call.face = face;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexMaterialEXT(struct qemu_syscall *call)
{
    struct qemu_glIndexMaterialEXT *c = (struct qemu_glIndexMaterialEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexMaterialEXT( c->face, c->mode ));
}

#endif

struct qemu_glIndexPointerEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexPointerEXT( GLenum type, GLsizei stride, GLsizei count, const void *pointer )
{
    struct qemu_glIndexPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXPOINTEREXT);
    call.type = type;
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glIndexPointerEXT *c = (struct qemu_glIndexPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexPointerEXT( c->type, c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glIndexPointerListIBM
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexPointerListIBM( GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glIndexPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXPOINTERLISTIBM);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glIndexPointerListIBM *c = (struct qemu_glIndexPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexPointerListIBM( c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glIndexxOES
{
    struct qemu_syscall super;
    uint64_t component;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexxOES( GLfixed component )
{
    struct qemu_glIndexxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXXOES);
    call.component = component;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexxOES(struct qemu_syscall *call)
{
    struct qemu_glIndexxOES *c = (struct qemu_glIndexxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexxOES( c->component ));
}

#endif

struct qemu_glIndexxvOES
{
    struct qemu_syscall super;
    uint64_t component;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glIndexxvOES( const GLfixed *component )
{
    struct qemu_glIndexxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINDEXXVOES);
    call.component = (ULONG_PTR)component;

    qemu_syscall(&call.super);
}

#else

void qemu_glIndexxvOES(struct qemu_syscall *call)
{
    struct qemu_glIndexxvOES *c = (struct qemu_glIndexxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glIndexxvOES( QEMU_G2H(c->component) ));
}

#endif

struct qemu_glInsertComponentEXT
{
    struct qemu_syscall super;
    uint64_t res;
    uint64_t src;
    uint64_t num;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInsertComponentEXT( GLuint res, GLuint src, GLuint num )
{
    struct qemu_glInsertComponentEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINSERTCOMPONENTEXT);
    call.res = res;
    call.src = src;
    call.num = num;

    qemu_syscall(&call.super);
}

#else

void qemu_glInsertComponentEXT(struct qemu_syscall *call)
{
    struct qemu_glInsertComponentEXT *c = (struct qemu_glInsertComponentEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glInsertComponentEXT( c->res, c->src, c->num ));
}

#endif

struct qemu_glInsertEventMarkerEXT
{
    struct qemu_syscall super;
    uint64_t length;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInsertEventMarkerEXT( GLsizei length, const GLchar *marker )
{
    struct qemu_glInsertEventMarkerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINSERTEVENTMARKEREXT);
    call.length = length;
    call.marker = (ULONG_PTR)marker;

    qemu_syscall(&call.super);
}

#else

void qemu_glInsertEventMarkerEXT(struct qemu_syscall *call)
{
    struct qemu_glInsertEventMarkerEXT *c = (struct qemu_glInsertEventMarkerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glInsertEventMarkerEXT( c->length, QEMU_G2H(c->marker) ));
}

#endif

struct qemu_glInstrumentsBufferSGIX
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInstrumentsBufferSGIX( GLsizei size, GLint *buffer )
{
    struct qemu_glInstrumentsBufferSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINSTRUMENTSBUFFERSGIX);
    call.size = size;
    call.buffer = (ULONG_PTR)buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glInstrumentsBufferSGIX(struct qemu_syscall *call)
{
    struct qemu_glInstrumentsBufferSGIX *c = (struct qemu_glInstrumentsBufferSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glInstrumentsBufferSGIX( c->size, QEMU_G2H(c->buffer) ));
}

#endif

struct qemu_glInterpolatePathsNV
{
    struct qemu_syscall super;
    uint64_t resultPath;
    uint64_t pathA;
    uint64_t pathB;
    double weight;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInterpolatePathsNV( GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight )
{
    struct qemu_glInterpolatePathsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINTERPOLATEPATHSNV);
    call.resultPath = resultPath;
    call.pathA = pathA;
    call.pathB = pathB;
    call.weight = weight;

    qemu_syscall(&call.super);
}

#else

void qemu_glInterpolatePathsNV(struct qemu_syscall *call)
{
    struct qemu_glInterpolatePathsNV *c = (struct qemu_glInterpolatePathsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glInterpolatePathsNV( c->resultPath, c->pathA, c->pathB, c->weight ));
}

#endif

struct qemu_glInvalidateBufferData
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateBufferData( GLuint buffer )
{
    struct qemu_glInvalidateBufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATEBUFFERDATA);
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateBufferData(struct qemu_syscall *call)
{
    struct qemu_glInvalidateBufferData *c = (struct qemu_glInvalidateBufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateBufferData( c->buffer ));
}

#endif

struct qemu_glInvalidateBufferSubData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateBufferSubData( GLuint buffer, GLintptr offset, GLsizeiptr length )
{
    struct qemu_glInvalidateBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATEBUFFERSUBDATA);
    call.buffer = buffer;
    call.offset = offset;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glInvalidateBufferSubData *c = (struct qemu_glInvalidateBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateBufferSubData( c->buffer, c->offset, c->length ));
}

#endif

struct qemu_glInvalidateFramebuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t numAttachments;
    uint64_t attachments;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateFramebuffer( GLenum target, GLsizei numAttachments, const GLenum *attachments )
{
    struct qemu_glInvalidateFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATEFRAMEBUFFER);
    call.target = target;
    call.numAttachments = numAttachments;
    call.attachments = (ULONG_PTR)attachments;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glInvalidateFramebuffer *c = (struct qemu_glInvalidateFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateFramebuffer( c->target, c->numAttachments, QEMU_G2H(c->attachments) ));
}

#endif

struct qemu_glInvalidateNamedFramebufferData
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t numAttachments;
    uint64_t attachments;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateNamedFramebufferData( GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments )
{
    struct qemu_glInvalidateNamedFramebufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATENAMEDFRAMEBUFFERDATA);
    call.framebuffer = framebuffer;
    call.numAttachments = numAttachments;
    call.attachments = (ULONG_PTR)attachments;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateNamedFramebufferData(struct qemu_syscall *call)
{
    struct qemu_glInvalidateNamedFramebufferData *c = (struct qemu_glInvalidateNamedFramebufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateNamedFramebufferData( c->framebuffer, c->numAttachments, QEMU_G2H(c->attachments) ));
}

#endif

struct qemu_glInvalidateNamedFramebufferSubData
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t numAttachments;
    uint64_t attachments;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateNamedFramebufferSubData( GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glInvalidateNamedFramebufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATENAMEDFRAMEBUFFERSUBDATA);
    call.framebuffer = framebuffer;
    call.numAttachments = numAttachments;
    call.attachments = (ULONG_PTR)attachments;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateNamedFramebufferSubData(struct qemu_syscall *call)
{
    struct qemu_glInvalidateNamedFramebufferSubData *c = (struct qemu_glInvalidateNamedFramebufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateNamedFramebufferSubData( c->framebuffer, c->numAttachments, QEMU_G2H(c->attachments), c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glInvalidateSubFramebuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t numAttachments;
    uint64_t attachments;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateSubFramebuffer( GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glInvalidateSubFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATESUBFRAMEBUFFER);
    call.target = target;
    call.numAttachments = numAttachments;
    call.attachments = (ULONG_PTR)attachments;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateSubFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glInvalidateSubFramebuffer *c = (struct qemu_glInvalidateSubFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateSubFramebuffer( c->target, c->numAttachments, QEMU_G2H(c->attachments), c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glInvalidateTexImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateTexImage( GLuint texture, GLint level )
{
    struct qemu_glInvalidateTexImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATETEXIMAGE);
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateTexImage(struct qemu_syscall *call)
{
    struct qemu_glInvalidateTexImage *c = (struct qemu_glInvalidateTexImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateTexImage( c->texture, c->level ));
}

#endif

struct qemu_glInvalidateTexSubImage
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glInvalidateTexSubImage( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glInvalidateTexSubImage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLINVALIDATETEXSUBIMAGE);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glInvalidateTexSubImage(struct qemu_syscall *call)
{
    struct qemu_glInvalidateTexSubImage *c = (struct qemu_glInvalidateTexSubImage *)call;
    WINE_FIXME("Unverified\n");
    (p_glInvalidateTexSubImage( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth ));
}

#endif

struct qemu_glIsAsyncMarkerSGIX
{
    struct qemu_syscall super;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsAsyncMarkerSGIX( GLuint marker )
{
    struct qemu_glIsAsyncMarkerSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISASYNCMARKERSGIX);
    call.marker = marker;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsAsyncMarkerSGIX(struct qemu_syscall *call)
{
    struct qemu_glIsAsyncMarkerSGIX *c = (struct qemu_glIsAsyncMarkerSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsAsyncMarkerSGIX( c->marker ));
}

#endif

struct qemu_glIsBuffer
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsBuffer( GLuint buffer )
{
    struct qemu_glIsBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISBUFFER);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsBuffer(struct qemu_syscall *call)
{
    struct qemu_glIsBuffer *c = (struct qemu_glIsBuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsBuffer( c->buffer ));
}

#endif

struct qemu_glIsBufferARB
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsBufferARB( GLuint buffer )
{
    struct qemu_glIsBufferARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISBUFFERARB);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsBufferARB(struct qemu_syscall *call)
{
    struct qemu_glIsBufferARB *c = (struct qemu_glIsBufferARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsBufferARB( c->buffer ));
}

#endif

struct qemu_glIsBufferResidentNV
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsBufferResidentNV( GLenum target )
{
    struct qemu_glIsBufferResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISBUFFERRESIDENTNV);
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsBufferResidentNV(struct qemu_syscall *call)
{
    struct qemu_glIsBufferResidentNV *c = (struct qemu_glIsBufferResidentNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsBufferResidentNV( c->target ));
}

#endif

struct qemu_glIsCommandListNV
{
    struct qemu_syscall super;
    uint64_t list;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsCommandListNV( GLuint list )
{
    struct qemu_glIsCommandListNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISCOMMANDLISTNV);
    call.list = list;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsCommandListNV(struct qemu_syscall *call)
{
    struct qemu_glIsCommandListNV *c = (struct qemu_glIsCommandListNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsCommandListNV( c->list ));
}

#endif

struct qemu_glIsEnabledIndexedEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsEnabledIndexedEXT( GLenum target, GLuint index )
{
    struct qemu_glIsEnabledIndexedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISENABLEDINDEXEDEXT);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsEnabledIndexedEXT(struct qemu_syscall *call)
{
    struct qemu_glIsEnabledIndexedEXT *c = (struct qemu_glIsEnabledIndexedEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsEnabledIndexedEXT( c->target, c->index ));
}

#endif

struct qemu_glIsEnabledi
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsEnabledi( GLenum target, GLuint index )
{
    struct qemu_glIsEnabledi call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISENABLEDI);
    call.target = target;
    call.index = index;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsEnabledi(struct qemu_syscall *call)
{
    struct qemu_glIsEnabledi *c = (struct qemu_glIsEnabledi *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsEnabledi( c->target, c->index ));
}

#endif

struct qemu_glIsFenceAPPLE
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsFenceAPPLE( GLuint fence )
{
    struct qemu_glIsFenceAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISFENCEAPPLE);
    call.fence = fence;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsFenceAPPLE(struct qemu_syscall *call)
{
    struct qemu_glIsFenceAPPLE *c = (struct qemu_glIsFenceAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsFenceAPPLE( c->fence ));
}

#endif

struct qemu_glIsFenceNV
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsFenceNV( GLuint fence )
{
    struct qemu_glIsFenceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISFENCENV);
    call.fence = fence;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsFenceNV(struct qemu_syscall *call)
{
    struct qemu_glIsFenceNV *c = (struct qemu_glIsFenceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsFenceNV( c->fence ));
}

#endif

struct qemu_glIsFramebuffer
{
    struct qemu_syscall super;
    uint64_t framebuffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsFramebuffer( GLuint framebuffer )
{
    struct qemu_glIsFramebuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISFRAMEBUFFER);
    call.framebuffer = framebuffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsFramebuffer(struct qemu_syscall *call)
{
    struct qemu_glIsFramebuffer *c = (struct qemu_glIsFramebuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsFramebuffer( c->framebuffer ));
}

#endif

struct qemu_glIsFramebufferEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsFramebufferEXT( GLuint framebuffer )
{
    struct qemu_glIsFramebufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISFRAMEBUFFEREXT);
    call.framebuffer = framebuffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsFramebufferEXT(struct qemu_syscall *call)
{
    struct qemu_glIsFramebufferEXT *c = (struct qemu_glIsFramebufferEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsFramebufferEXT( c->framebuffer ));
}

#endif

struct qemu_glIsImageHandleResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsImageHandleResidentARB( GLuint64 handle )
{
    struct qemu_glIsImageHandleResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISIMAGEHANDLERESIDENTARB);
    call.handle = handle;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsImageHandleResidentARB(struct qemu_syscall *call)
{
    struct qemu_glIsImageHandleResidentARB *c = (struct qemu_glIsImageHandleResidentARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsImageHandleResidentARB( c->handle ));
}

#endif

struct qemu_glIsImageHandleResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsImageHandleResidentNV( GLuint64 handle )
{
    struct qemu_glIsImageHandleResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISIMAGEHANDLERESIDENTNV);
    call.handle = handle;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsImageHandleResidentNV(struct qemu_syscall *call)
{
    struct qemu_glIsImageHandleResidentNV *c = (struct qemu_glIsImageHandleResidentNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsImageHandleResidentNV( c->handle ));
}

#endif

struct qemu_glIsMemoryObjectEXT
{
    struct qemu_syscall super;
    uint64_t memoryObject;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsMemoryObjectEXT( GLuint memoryObject )
{
    struct qemu_glIsMemoryObjectEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISMEMORYOBJECTEXT);
    call.memoryObject = memoryObject;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsMemoryObjectEXT(struct qemu_syscall *call)
{
    struct qemu_glIsMemoryObjectEXT *c = (struct qemu_glIsMemoryObjectEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsMemoryObjectEXT( c->memoryObject ));
}

#endif

struct qemu_glIsNameAMD
{
    struct qemu_syscall super;
    uint64_t identifier;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsNameAMD( GLenum identifier, GLuint name )
{
    struct qemu_glIsNameAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISNAMEAMD);
    call.identifier = identifier;
    call.name = name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsNameAMD(struct qemu_syscall *call)
{
    struct qemu_glIsNameAMD *c = (struct qemu_glIsNameAMD *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsNameAMD( c->identifier, c->name ));
}

#endif

struct qemu_glIsNamedBufferResidentNV
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsNamedBufferResidentNV( GLuint buffer )
{
    struct qemu_glIsNamedBufferResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISNAMEDBUFFERRESIDENTNV);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsNamedBufferResidentNV(struct qemu_syscall *call)
{
    struct qemu_glIsNamedBufferResidentNV *c = (struct qemu_glIsNamedBufferResidentNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsNamedBufferResidentNV( c->buffer ));
}

#endif

struct qemu_glIsNamedStringARB
{
    struct qemu_syscall super;
    uint64_t namelen;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsNamedStringARB( GLint namelen, const GLchar *name )
{
    struct qemu_glIsNamedStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISNAMEDSTRINGARB);
    call.namelen = namelen;
    call.name = (ULONG_PTR)name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsNamedStringARB(struct qemu_syscall *call)
{
    struct qemu_glIsNamedStringARB *c = (struct qemu_glIsNamedStringARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsNamedStringARB( c->namelen, QEMU_G2H(c->name) ));
}

#endif

struct qemu_glIsObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsObjectBufferATI( GLuint buffer )
{
    struct qemu_glIsObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISOBJECTBUFFERATI);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glIsObjectBufferATI *c = (struct qemu_glIsObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsObjectBufferATI( c->buffer ));
}

#endif

struct qemu_glIsOcclusionQueryNV
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsOcclusionQueryNV( GLuint id )
{
    struct qemu_glIsOcclusionQueryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISOCCLUSIONQUERYNV);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsOcclusionQueryNV(struct qemu_syscall *call)
{
    struct qemu_glIsOcclusionQueryNV *c = (struct qemu_glIsOcclusionQueryNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsOcclusionQueryNV( c->id ));
}

#endif

struct qemu_glIsPathNV
{
    struct qemu_syscall super;
    uint64_t path;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsPathNV( GLuint path )
{
    struct qemu_glIsPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPATHNV);
    call.path = path;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsPathNV(struct qemu_syscall *call)
{
    struct qemu_glIsPathNV *c = (struct qemu_glIsPathNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsPathNV( c->path ));
}

#endif

struct qemu_glIsPointInFillPathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t mask;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsPointInFillPathNV( GLuint path, GLuint mask, GLfloat x, GLfloat y )
{
    struct qemu_glIsPointInFillPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPOINTINFILLPATHNV);
    call.path = path;
    call.mask = mask;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsPointInFillPathNV(struct qemu_syscall *call)
{
    struct qemu_glIsPointInFillPathNV *c = (struct qemu_glIsPointInFillPathNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsPointInFillPathNV( c->path, c->mask, c->x, c->y ));
}

#endif

struct qemu_glIsPointInStrokePathNV
{
    struct qemu_syscall super;
    uint64_t path;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsPointInStrokePathNV( GLuint path, GLfloat x, GLfloat y )
{
    struct qemu_glIsPointInStrokePathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPOINTINSTROKEPATHNV);
    call.path = path;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsPointInStrokePathNV(struct qemu_syscall *call)
{
    struct qemu_glIsPointInStrokePathNV *c = (struct qemu_glIsPointInStrokePathNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsPointInStrokePathNV( c->path, c->x, c->y ));
}

#endif

struct qemu_glIsProgram
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsProgram( GLuint program )
{
    struct qemu_glIsProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPROGRAM);
    call.program = program;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsProgram(struct qemu_syscall *call)
{
    struct qemu_glIsProgram *c = (struct qemu_glIsProgram *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsProgram( c->program ));
}

#endif

struct qemu_glIsProgramARB
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsProgramARB( GLuint program )
{
    struct qemu_glIsProgramARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPROGRAMARB);
    call.program = program;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsProgramARB(struct qemu_syscall *call)
{
    struct qemu_glIsProgramARB *c = (struct qemu_glIsProgramARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsProgramARB( c->program ));
}

#endif

struct qemu_glIsProgramNV
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsProgramNV( GLuint id )
{
    struct qemu_glIsProgramNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPROGRAMNV);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsProgramNV(struct qemu_syscall *call)
{
    struct qemu_glIsProgramNV *c = (struct qemu_glIsProgramNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsProgramNV( c->id ));
}

#endif

struct qemu_glIsProgramPipeline
{
    struct qemu_syscall super;
    uint64_t pipeline;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsProgramPipeline( GLuint pipeline )
{
    struct qemu_glIsProgramPipeline call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISPROGRAMPIPELINE);
    call.pipeline = pipeline;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsProgramPipeline(struct qemu_syscall *call)
{
    struct qemu_glIsProgramPipeline *c = (struct qemu_glIsProgramPipeline *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsProgramPipeline( c->pipeline ));
}

#endif

struct qemu_glIsQuery
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsQuery( GLuint id )
{
    struct qemu_glIsQuery call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISQUERY);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsQuery(struct qemu_syscall *call)
{
    struct qemu_glIsQuery *c = (struct qemu_glIsQuery *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsQuery( c->id ));
}

#endif

struct qemu_glIsQueryARB
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsQueryARB( GLuint id )
{
    struct qemu_glIsQueryARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISQUERYARB);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsQueryARB(struct qemu_syscall *call)
{
    struct qemu_glIsQueryARB *c = (struct qemu_glIsQueryARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsQueryARB( c->id ));
}

#endif

struct qemu_glIsRenderbuffer
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsRenderbuffer( GLuint renderbuffer )
{
    struct qemu_glIsRenderbuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISRENDERBUFFER);
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsRenderbuffer(struct qemu_syscall *call)
{
    struct qemu_glIsRenderbuffer *c = (struct qemu_glIsRenderbuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsRenderbuffer( c->renderbuffer ));
}

#endif

struct qemu_glIsRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsRenderbufferEXT( GLuint renderbuffer )
{
    struct qemu_glIsRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISRENDERBUFFEREXT);
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glIsRenderbufferEXT *c = (struct qemu_glIsRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsRenderbufferEXT( c->renderbuffer ));
}

#endif

struct qemu_glIsSampler
{
    struct qemu_syscall super;
    uint64_t sampler;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsSampler( GLuint sampler )
{
    struct qemu_glIsSampler call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISSAMPLER);
    call.sampler = sampler;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsSampler(struct qemu_syscall *call)
{
    struct qemu_glIsSampler *c = (struct qemu_glIsSampler *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsSampler( c->sampler ));
}

#endif

struct qemu_glIsSemaphoreEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsSemaphoreEXT( GLuint semaphore )
{
    struct qemu_glIsSemaphoreEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISSEMAPHOREEXT);
    call.semaphore = semaphore;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsSemaphoreEXT(struct qemu_syscall *call)
{
    struct qemu_glIsSemaphoreEXT *c = (struct qemu_glIsSemaphoreEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsSemaphoreEXT( c->semaphore ));
}

#endif

struct qemu_glIsShader
{
    struct qemu_syscall super;
    uint64_t shader;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsShader( GLuint shader )
{
    struct qemu_glIsShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISSHADER);
    call.shader = shader;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsShader(struct qemu_syscall *call)
{
    struct qemu_glIsShader *c = (struct qemu_glIsShader *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsShader( c->shader ));
}

#endif

struct qemu_glIsStateNV
{
    struct qemu_syscall super;
    uint64_t state;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsStateNV( GLuint state )
{
    struct qemu_glIsStateNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISSTATENV);
    call.state = state;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsStateNV(struct qemu_syscall *call)
{
    struct qemu_glIsStateNV *c = (struct qemu_glIsStateNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsStateNV( c->state ));
}

#endif

struct qemu_glIsSync
{
    struct qemu_syscall super;
    uint64_t sync;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsSync( GLsync sync )
{
    struct qemu_glIsSync call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISSYNC);
    call.sync = (ULONG_PTR)sync;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsSync(struct qemu_syscall *call)
{
    struct qemu_glIsSync *c = (struct qemu_glIsSync *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsSync( QEMU_G2H(c->sync) ));
}

#endif

struct qemu_glIsTextureEXT
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsTextureEXT( GLuint texture )
{
    struct qemu_glIsTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISTEXTUREEXT);
    call.texture = texture;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glIsTextureEXT *c = (struct qemu_glIsTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsTextureEXT( c->texture ));
}

#endif

struct qemu_glIsTextureHandleResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsTextureHandleResidentARB( GLuint64 handle )
{
    struct qemu_glIsTextureHandleResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISTEXTUREHANDLERESIDENTARB);
    call.handle = handle;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsTextureHandleResidentARB(struct qemu_syscall *call)
{
    struct qemu_glIsTextureHandleResidentARB *c = (struct qemu_glIsTextureHandleResidentARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsTextureHandleResidentARB( c->handle ));
}

#endif

struct qemu_glIsTextureHandleResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsTextureHandleResidentNV( GLuint64 handle )
{
    struct qemu_glIsTextureHandleResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISTEXTUREHANDLERESIDENTNV);
    call.handle = handle;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsTextureHandleResidentNV(struct qemu_syscall *call)
{
    struct qemu_glIsTextureHandleResidentNV *c = (struct qemu_glIsTextureHandleResidentNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsTextureHandleResidentNV( c->handle ));
}

#endif

struct qemu_glIsTransformFeedback
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsTransformFeedback( GLuint id )
{
    struct qemu_glIsTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISTRANSFORMFEEDBACK);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glIsTransformFeedback *c = (struct qemu_glIsTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsTransformFeedback( c->id ));
}

#endif

struct qemu_glIsTransformFeedbackNV
{
    struct qemu_syscall super;
    uint64_t id;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsTransformFeedbackNV( GLuint id )
{
    struct qemu_glIsTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISTRANSFORMFEEDBACKNV);
    call.id = id;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glIsTransformFeedbackNV *c = (struct qemu_glIsTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsTransformFeedbackNV( c->id ));
}

#endif

struct qemu_glIsVariantEnabledEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t cap;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsVariantEnabledEXT( GLuint id, GLenum cap )
{
    struct qemu_glIsVariantEnabledEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISVARIANTENABLEDEXT);
    call.id = id;
    call.cap = cap;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsVariantEnabledEXT(struct qemu_syscall *call)
{
    struct qemu_glIsVariantEnabledEXT *c = (struct qemu_glIsVariantEnabledEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsVariantEnabledEXT( c->id, c->cap ));
}

#endif

struct qemu_glIsVertexArray
{
    struct qemu_syscall super;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsVertexArray( GLuint array )
{
    struct qemu_glIsVertexArray call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISVERTEXARRAY);
    call.array = array;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsVertexArray(struct qemu_syscall *call)
{
    struct qemu_glIsVertexArray *c = (struct qemu_glIsVertexArray *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsVertexArray( c->array ));
}

#endif

struct qemu_glIsVertexArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t array;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsVertexArrayAPPLE( GLuint array )
{
    struct qemu_glIsVertexArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISVERTEXARRAYAPPLE);
    call.array = array;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsVertexArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glIsVertexArrayAPPLE *c = (struct qemu_glIsVertexArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsVertexArrayAPPLE( c->array ));
}

#endif

struct qemu_glIsVertexAttribEnabledAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glIsVertexAttribEnabledAPPLE( GLuint index, GLenum pname )
{
    struct qemu_glIsVertexAttribEnabledAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLISVERTEXATTRIBENABLEDAPPLE);
    call.index = index;
    call.pname = pname;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glIsVertexAttribEnabledAPPLE(struct qemu_syscall *call)
{
    struct qemu_glIsVertexAttribEnabledAPPLE *c = (struct qemu_glIsVertexAttribEnabledAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glIsVertexAttribEnabledAPPLE( c->index, c->pname ));
}

#endif

struct qemu_glLGPUCopyImageSubDataNVX
{
    struct qemu_syscall super;
    uint64_t sourceGpu;
    uint64_t destinationGpuMask;
    uint64_t srcName;
    uint64_t srcTarget;
    uint64_t srcLevel;
    uint64_t srcX;
    uint64_t srxY;
    uint64_t srcZ;
    uint64_t dstName;
    uint64_t dstTarget;
    uint64_t dstLevel;
    uint64_t dstX;
    uint64_t dstY;
    uint64_t dstZ;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLGPUCopyImageSubDataNVX( GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glLGPUCopyImageSubDataNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLGPUCOPYIMAGESUBDATANVX);
    call.sourceGpu = sourceGpu;
    call.destinationGpuMask = destinationGpuMask;
    call.srcName = srcName;
    call.srcTarget = srcTarget;
    call.srcLevel = srcLevel;
    call.srcX = srcX;
    call.srxY = srxY;
    call.srcZ = srcZ;
    call.dstName = dstName;
    call.dstTarget = dstTarget;
    call.dstLevel = dstLevel;
    call.dstX = dstX;
    call.dstY = dstY;
    call.dstZ = dstZ;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glLGPUCopyImageSubDataNVX(struct qemu_syscall *call)
{
    struct qemu_glLGPUCopyImageSubDataNVX *c = (struct qemu_glLGPUCopyImageSubDataNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glLGPUCopyImageSubDataNVX( c->sourceGpu, c->destinationGpuMask, c->srcName, c->srcTarget, c->srcLevel, c->srcX, c->srxY, c->srcZ, c->dstName, c->dstTarget, c->dstLevel, c->dstX, c->dstY, c->dstZ, c->width, c->height, c->depth ));
}

#endif

struct qemu_glLGPUInterlockNVX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLGPUInterlockNVX(void)
{
    struct qemu_glLGPUInterlockNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLGPUINTERLOCKNVX);

    qemu_syscall(&call.super);
}

#else

void qemu_glLGPUInterlockNVX(struct qemu_syscall *call)
{
    struct qemu_glLGPUInterlockNVX *c = (struct qemu_glLGPUInterlockNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glLGPUInterlockNVX());
}

#endif

struct qemu_glLGPUNamedBufferSubDataNVX
{
    struct qemu_syscall super;
    uint64_t gpuMask;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLGPUNamedBufferSubDataNVX( GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data )
{
    struct qemu_glLGPUNamedBufferSubDataNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLGPUNAMEDBUFFERSUBDATANVX);
    call.gpuMask = gpuMask;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glLGPUNamedBufferSubDataNVX(struct qemu_syscall *call)
{
    struct qemu_glLGPUNamedBufferSubDataNVX *c = (struct qemu_glLGPUNamedBufferSubDataNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glLGPUNamedBufferSubDataNVX( c->gpuMask, c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glLabelObjectEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t object;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLabelObjectEXT( GLenum type, GLuint object, GLsizei length, const GLchar *label )
{
    struct qemu_glLabelObjectEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLABELOBJECTEXT);
    call.type = type;
    call.object = object;
    call.length = length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glLabelObjectEXT(struct qemu_syscall *call)
{
    struct qemu_glLabelObjectEXT *c = (struct qemu_glLabelObjectEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glLabelObjectEXT( c->type, c->object, c->length, QEMU_G2H(c->label) ));
}

#endif

struct qemu_glLightEnviSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLightEnviSGIX( GLenum pname, GLint param )
{
    struct qemu_glLightEnviSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLIGHTENVISGIX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glLightEnviSGIX(struct qemu_syscall *call)
{
    struct qemu_glLightEnviSGIX *c = (struct qemu_glLightEnviSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glLightEnviSGIX( c->pname, c->param ));
}

#endif

struct qemu_glLightModelxOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLightModelxOES( GLenum pname, GLfixed param )
{
    struct qemu_glLightModelxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLIGHTMODELXOES);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glLightModelxOES(struct qemu_syscall *call)
{
    struct qemu_glLightModelxOES *c = (struct qemu_glLightModelxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLightModelxOES( c->pname, c->param ));
}

#endif

struct qemu_glLightModelxvOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLightModelxvOES( GLenum pname, const GLfixed *param )
{
    struct qemu_glLightModelxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLIGHTMODELXVOES);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glLightModelxvOES(struct qemu_syscall *call)
{
    struct qemu_glLightModelxvOES *c = (struct qemu_glLightModelxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLightModelxvOES( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glLightxOES
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLightxOES( GLenum light, GLenum pname, GLfixed param )
{
    struct qemu_glLightxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLIGHTXOES);
    call.light = light;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glLightxOES(struct qemu_syscall *call)
{
    struct qemu_glLightxOES *c = (struct qemu_glLightxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLightxOES( c->light, c->pname, c->param ));
}

#endif

struct qemu_glLightxvOES
{
    struct qemu_syscall super;
    uint64_t light;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLightxvOES( GLenum light, GLenum pname, const GLfixed *params )
{
    struct qemu_glLightxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLIGHTXVOES);
    call.light = light;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glLightxvOES(struct qemu_syscall *call)
{
    struct qemu_glLightxvOES *c = (struct qemu_glLightxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLightxvOES( c->light, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glLineWidthxOES
{
    struct qemu_syscall super;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLineWidthxOES( GLfixed width )
{
    struct qemu_glLineWidthxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLINEWIDTHXOES);
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glLineWidthxOES(struct qemu_syscall *call)
{
    struct qemu_glLineWidthxOES *c = (struct qemu_glLineWidthxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLineWidthxOES( c->width ));
}

#endif

struct qemu_glLinkProgram
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLinkProgram( GLuint program )
{
    struct qemu_glLinkProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLINKPROGRAM);
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glLinkProgram(struct qemu_syscall *call)
{
    struct qemu_glLinkProgram *c = (struct qemu_glLinkProgram *)call;
    WINE_FIXME("Unverified\n");
    (p_glLinkProgram( c->program ));
}

#endif

struct qemu_glLinkProgramARB
{
    struct qemu_syscall super;
    uint64_t programObj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLinkProgramARB( GLhandleARB programObj )
{
    struct qemu_glLinkProgramARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLINKPROGRAMARB);
    call.programObj = programObj;

    qemu_syscall(&call.super);
}

#else

void qemu_glLinkProgramARB(struct qemu_syscall *call)
{
    struct qemu_glLinkProgramARB *c = (struct qemu_glLinkProgramARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glLinkProgramARB( c->programObj ));
}

#endif

struct qemu_glListDrawCommandsStatesClientNV
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t segment;
    uint64_t indirects;
    uint64_t sizes;
    uint64_t states;
    uint64_t fbos;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glListDrawCommandsStatesClientNV( GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count )
{
    struct qemu_glListDrawCommandsStatesClientNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLISTDRAWCOMMANDSSTATESCLIENTNV);
    call.list = list;
    call.segment = segment;
    call.indirects = (ULONG_PTR)indirects;
    call.sizes = (ULONG_PTR)sizes;
    call.states = (ULONG_PTR)states;
    call.fbos = (ULONG_PTR)fbos;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glListDrawCommandsStatesClientNV(struct qemu_syscall *call)
{
    struct qemu_glListDrawCommandsStatesClientNV *c = (struct qemu_glListDrawCommandsStatesClientNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glListDrawCommandsStatesClientNV( c->list, c->segment, QEMU_G2H(c->indirects), QEMU_G2H(c->sizes), QEMU_G2H(c->states), QEMU_G2H(c->fbos), c->count ));
}

#endif

struct qemu_glListParameterfSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glListParameterfSGIX( GLuint list, GLenum pname, GLfloat param )
{
    struct qemu_glListParameterfSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLISTPARAMETERFSGIX);
    call.list = list;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glListParameterfSGIX(struct qemu_syscall *call)
{
    struct qemu_glListParameterfSGIX *c = (struct qemu_glListParameterfSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glListParameterfSGIX( c->list, c->pname, c->param ));
}

#endif

struct qemu_glListParameterfvSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glListParameterfvSGIX( GLuint list, GLenum pname, const GLfloat *params )
{
    struct qemu_glListParameterfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLISTPARAMETERFVSGIX);
    call.list = list;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glListParameterfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glListParameterfvSGIX *c = (struct qemu_glListParameterfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glListParameterfvSGIX( c->list, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glListParameteriSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glListParameteriSGIX( GLuint list, GLenum pname, GLint param )
{
    struct qemu_glListParameteriSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLISTPARAMETERISGIX);
    call.list = list;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glListParameteriSGIX(struct qemu_syscall *call)
{
    struct qemu_glListParameteriSGIX *c = (struct qemu_glListParameteriSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glListParameteriSGIX( c->list, c->pname, c->param ));
}

#endif

struct qemu_glListParameterivSGIX
{
    struct qemu_syscall super;
    uint64_t list;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glListParameterivSGIX( GLuint list, GLenum pname, const GLint *params )
{
    struct qemu_glListParameterivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLISTPARAMETERIVSGIX);
    call.list = list;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glListParameterivSGIX(struct qemu_syscall *call)
{
    struct qemu_glListParameterivSGIX *c = (struct qemu_glListParameterivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glListParameterivSGIX( c->list, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glLoadIdentityDeformationMapSGIX
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadIdentityDeformationMapSGIX( GLbitfield mask )
{
    struct qemu_glLoadIdentityDeformationMapSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADIDENTITYDEFORMATIONMAPSGIX);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadIdentityDeformationMapSGIX(struct qemu_syscall *call)
{
    struct qemu_glLoadIdentityDeformationMapSGIX *c = (struct qemu_glLoadIdentityDeformationMapSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadIdentityDeformationMapSGIX( c->mask ));
}

#endif

struct qemu_glLoadMatrixxOES
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadMatrixxOES( const GLfixed *m )
{
    struct qemu_glLoadMatrixxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADMATRIXXOES);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadMatrixxOES(struct qemu_syscall *call)
{
    struct qemu_glLoadMatrixxOES *c = (struct qemu_glLoadMatrixxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadMatrixxOES( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLoadProgramNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
    uint64_t len;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadProgramNV( GLenum target, GLuint id, GLsizei len, const GLubyte *program )
{
    struct qemu_glLoadProgramNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADPROGRAMNV);
    call.target = target;
    call.id = id;
    call.len = len;
    call.program = (ULONG_PTR)program;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadProgramNV(struct qemu_syscall *call)
{
    struct qemu_glLoadProgramNV *c = (struct qemu_glLoadProgramNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadProgramNV( c->target, c->id, c->len, QEMU_G2H(c->program) ));
}

#endif

struct qemu_glLoadTransposeMatrixd
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadTransposeMatrixd( const GLdouble *m )
{
    struct qemu_glLoadTransposeMatrixd call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADTRANSPOSEMATRIXD);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadTransposeMatrixd(struct qemu_syscall *call)
{
    struct qemu_glLoadTransposeMatrixd *c = (struct qemu_glLoadTransposeMatrixd *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadTransposeMatrixd( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLoadTransposeMatrixdARB
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadTransposeMatrixdARB( const GLdouble *m )
{
    struct qemu_glLoadTransposeMatrixdARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADTRANSPOSEMATRIXDARB);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadTransposeMatrixdARB(struct qemu_syscall *call)
{
    struct qemu_glLoadTransposeMatrixdARB *c = (struct qemu_glLoadTransposeMatrixdARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadTransposeMatrixdARB( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLoadTransposeMatrixf
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadTransposeMatrixf( const GLfloat *m )
{
    struct qemu_glLoadTransposeMatrixf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADTRANSPOSEMATRIXF);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadTransposeMatrixf(struct qemu_syscall *call)
{
    struct qemu_glLoadTransposeMatrixf *c = (struct qemu_glLoadTransposeMatrixf *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadTransposeMatrixf( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLoadTransposeMatrixfARB
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadTransposeMatrixfARB( const GLfloat *m )
{
    struct qemu_glLoadTransposeMatrixfARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADTRANSPOSEMATRIXFARB);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadTransposeMatrixfARB(struct qemu_syscall *call)
{
    struct qemu_glLoadTransposeMatrixfARB *c = (struct qemu_glLoadTransposeMatrixfARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadTransposeMatrixfARB( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLoadTransposeMatrixxOES
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLoadTransposeMatrixxOES( const GLfixed *m )
{
    struct qemu_glLoadTransposeMatrixxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOADTRANSPOSEMATRIXXOES);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glLoadTransposeMatrixxOES(struct qemu_syscall *call)
{
    struct qemu_glLoadTransposeMatrixxOES *c = (struct qemu_glLoadTransposeMatrixxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glLoadTransposeMatrixxOES( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glLockArraysEXT
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glLockArraysEXT( GLint first, GLsizei count )
{
    struct qemu_glLockArraysEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLLOCKARRAYSEXT);
    call.first = first;
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glLockArraysEXT(struct qemu_syscall *call)
{
    struct qemu_glLockArraysEXT *c = (struct qemu_glLockArraysEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glLockArraysEXT( c->first, c->count ));
}

#endif

struct qemu_glMTexCoord2fSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMTexCoord2fSGIS( GLenum target, GLfloat s, GLfloat t )
{
    struct qemu_glMTexCoord2fSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMTEXCOORD2FSGIS);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMTexCoord2fSGIS(struct qemu_syscall *call)
{
    struct qemu_glMTexCoord2fSGIS *c = (struct qemu_glMTexCoord2fSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMTexCoord2fSGIS( c->target, c->s, c->t ));
}

#endif

struct qemu_glMTexCoord2fvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMTexCoord2fvSGIS( GLenum target, GLfloat * v )
{
    struct qemu_glMTexCoord2fvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMTEXCOORD2FVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMTexCoord2fvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMTexCoord2fvSGIS *c = (struct qemu_glMTexCoord2fvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMTexCoord2fvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMakeBufferNonResidentNV
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeBufferNonResidentNV( GLenum target )
{
    struct qemu_glMakeBufferNonResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEBUFFERNONRESIDENTNV);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeBufferNonResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeBufferNonResidentNV *c = (struct qemu_glMakeBufferNonResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeBufferNonResidentNV( c->target ));
}

#endif

struct qemu_glMakeBufferResidentNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeBufferResidentNV( GLenum target, GLenum access )
{
    struct qemu_glMakeBufferResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEBUFFERRESIDENTNV);
    call.target = target;
    call.access = access;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeBufferResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeBufferResidentNV *c = (struct qemu_glMakeBufferResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeBufferResidentNV( c->target, c->access ));
}

#endif

struct qemu_glMakeImageHandleNonResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeImageHandleNonResidentARB( GLuint64 handle )
{
    struct qemu_glMakeImageHandleNonResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEIMAGEHANDLENONRESIDENTARB);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeImageHandleNonResidentARB(struct qemu_syscall *call)
{
    struct qemu_glMakeImageHandleNonResidentARB *c = (struct qemu_glMakeImageHandleNonResidentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeImageHandleNonResidentARB( c->handle ));
}

#endif

struct qemu_glMakeImageHandleNonResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeImageHandleNonResidentNV( GLuint64 handle )
{
    struct qemu_glMakeImageHandleNonResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEIMAGEHANDLENONRESIDENTNV);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeImageHandleNonResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeImageHandleNonResidentNV *c = (struct qemu_glMakeImageHandleNonResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeImageHandleNonResidentNV( c->handle ));
}

#endif

struct qemu_glMakeImageHandleResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeImageHandleResidentARB( GLuint64 handle, GLenum access )
{
    struct qemu_glMakeImageHandleResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEIMAGEHANDLERESIDENTARB);
    call.handle = handle;
    call.access = access;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeImageHandleResidentARB(struct qemu_syscall *call)
{
    struct qemu_glMakeImageHandleResidentARB *c = (struct qemu_glMakeImageHandleResidentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeImageHandleResidentARB( c->handle, c->access ));
}

#endif

struct qemu_glMakeImageHandleResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeImageHandleResidentNV( GLuint64 handle, GLenum access )
{
    struct qemu_glMakeImageHandleResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKEIMAGEHANDLERESIDENTNV);
    call.handle = handle;
    call.access = access;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeImageHandleResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeImageHandleResidentNV *c = (struct qemu_glMakeImageHandleResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeImageHandleResidentNV( c->handle, c->access ));
}

#endif

struct qemu_glMakeNamedBufferNonResidentNV
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeNamedBufferNonResidentNV( GLuint buffer )
{
    struct qemu_glMakeNamedBufferNonResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKENAMEDBUFFERNONRESIDENTNV);
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeNamedBufferNonResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeNamedBufferNonResidentNV *c = (struct qemu_glMakeNamedBufferNonResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeNamedBufferNonResidentNV( c->buffer ));
}

#endif

struct qemu_glMakeNamedBufferResidentNV
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeNamedBufferResidentNV( GLuint buffer, GLenum access )
{
    struct qemu_glMakeNamedBufferResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKENAMEDBUFFERRESIDENTNV);
    call.buffer = buffer;
    call.access = access;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeNamedBufferResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeNamedBufferResidentNV *c = (struct qemu_glMakeNamedBufferResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeNamedBufferResidentNV( c->buffer, c->access ));
}

#endif

struct qemu_glMakeTextureHandleNonResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeTextureHandleNonResidentARB( GLuint64 handle )
{
    struct qemu_glMakeTextureHandleNonResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKETEXTUREHANDLENONRESIDENTARB);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeTextureHandleNonResidentARB(struct qemu_syscall *call)
{
    struct qemu_glMakeTextureHandleNonResidentARB *c = (struct qemu_glMakeTextureHandleNonResidentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeTextureHandleNonResidentARB( c->handle ));
}

#endif

struct qemu_glMakeTextureHandleNonResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeTextureHandleNonResidentNV( GLuint64 handle )
{
    struct qemu_glMakeTextureHandleNonResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKETEXTUREHANDLENONRESIDENTNV);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeTextureHandleNonResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeTextureHandleNonResidentNV *c = (struct qemu_glMakeTextureHandleNonResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeTextureHandleNonResidentNV( c->handle ));
}

#endif

struct qemu_glMakeTextureHandleResidentARB
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeTextureHandleResidentARB( GLuint64 handle )
{
    struct qemu_glMakeTextureHandleResidentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKETEXTUREHANDLERESIDENTARB);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeTextureHandleResidentARB(struct qemu_syscall *call)
{
    struct qemu_glMakeTextureHandleResidentARB *c = (struct qemu_glMakeTextureHandleResidentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeTextureHandleResidentARB( c->handle ));
}

#endif

struct qemu_glMakeTextureHandleResidentNV
{
    struct qemu_syscall super;
    uint64_t handle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMakeTextureHandleResidentNV( GLuint64 handle )
{
    struct qemu_glMakeTextureHandleResidentNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAKETEXTUREHANDLERESIDENTNV);
    call.handle = handle;

    qemu_syscall(&call.super);
}

#else

void qemu_glMakeTextureHandleResidentNV(struct qemu_syscall *call)
{
    struct qemu_glMakeTextureHandleResidentNV *c = (struct qemu_glMakeTextureHandleResidentNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMakeTextureHandleResidentNV( c->handle ));
}

#endif

struct qemu_glMap1xOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t u1;
    uint64_t u2;
    uint64_t stride;
    uint64_t order;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMap1xOES( GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points )
{
    struct qemu_glMap1xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAP1XOES);
    call.target = target;
    call.u1 = u1;
    call.u2 = u2;
    call.stride = stride;
    call.order = order;
    call.points = points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMap1xOES(struct qemu_syscall *call)
{
    struct qemu_glMap1xOES *c = (struct qemu_glMap1xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMap1xOES( c->target, c->u1, c->u2, c->stride, c->order, c->points ));
}

#endif

struct qemu_glMap2xOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t u1;
    uint64_t u2;
    uint64_t ustride;
    uint64_t uorder;
    uint64_t v1;
    uint64_t v2;
    uint64_t vstride;
    uint64_t vorder;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMap2xOES( GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points )
{
    struct qemu_glMap2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAP2XOES);
    call.target = target;
    call.u1 = u1;
    call.u2 = u2;
    call.ustride = ustride;
    call.uorder = uorder;
    call.v1 = v1;
    call.v2 = v2;
    call.vstride = vstride;
    call.vorder = vorder;
    call.points = points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMap2xOES(struct qemu_syscall *call)
{
    struct qemu_glMap2xOES *c = (struct qemu_glMap2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMap2xOES( c->target, c->u1, c->u2, c->ustride, c->uorder, c->v1, c->v2, c->vstride, c->vorder, c->points ));
}

#endif

struct qemu_glMapBuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapBuffer( GLenum target, GLenum access )
{
    struct qemu_glMapBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPBUFFER);
    call.target = target;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapBuffer(struct qemu_syscall *call)
{
    struct qemu_glMapBuffer *c = (struct qemu_glMapBuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapBuffer( c->target, c->access ));
}

#endif

struct qemu_glMapBufferARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapBufferARB( GLenum target, GLenum access )
{
    struct qemu_glMapBufferARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPBUFFERARB);
    call.target = target;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapBufferARB(struct qemu_syscall *call)
{
    struct qemu_glMapBufferARB *c = (struct qemu_glMapBufferARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapBufferARB( c->target, c->access ));
}

#endif

struct qemu_glMapBufferRange
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t offset;
    uint64_t length;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapBufferRange( GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access )
{
    struct qemu_glMapBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPBUFFERRANGE);
    call.target = target;
    call.offset = offset;
    call.length = length;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapBufferRange(struct qemu_syscall *call)
{
    struct qemu_glMapBufferRange *c = (struct qemu_glMapBufferRange *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapBufferRange( c->target, c->offset, c->length, c->access ));
}

#endif

struct qemu_glMapControlPointsNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t type;
    uint64_t ustride;
    uint64_t vstride;
    uint64_t uorder;
    uint64_t vorder;
    uint64_t packed;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapControlPointsNV( GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points )
{
    struct qemu_glMapControlPointsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPCONTROLPOINTSNV);
    call.target = target;
    call.index = index;
    call.type = type;
    call.ustride = ustride;
    call.vstride = vstride;
    call.uorder = uorder;
    call.vorder = vorder;
    call.packed = packed;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapControlPointsNV(struct qemu_syscall *call)
{
    struct qemu_glMapControlPointsNV *c = (struct qemu_glMapControlPointsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapControlPointsNV( c->target, c->index, c->type, c->ustride, c->vstride, c->uorder, c->vorder, c->packed, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glMapGrid1xOES
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t u1;
    uint64_t u2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapGrid1xOES( GLint n, GLfixed u1, GLfixed u2 )
{
    struct qemu_glMapGrid1xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPGRID1XOES);
    call.n = n;
    call.u1 = u1;
    call.u2 = u2;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapGrid1xOES(struct qemu_syscall *call)
{
    struct qemu_glMapGrid1xOES *c = (struct qemu_glMapGrid1xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapGrid1xOES( c->n, c->u1, c->u2 ));
}

#endif

struct qemu_glMapGrid2xOES
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t u1;
    uint64_t u2;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapGrid2xOES( GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2 )
{
    struct qemu_glMapGrid2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPGRID2XOES);
    call.n = n;
    call.u1 = u1;
    call.u2 = u2;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapGrid2xOES(struct qemu_syscall *call)
{
    struct qemu_glMapGrid2xOES *c = (struct qemu_glMapGrid2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapGrid2xOES( c->n, c->u1, c->u2, c->v1, c->v2 ));
}

#endif

struct qemu_glMapNamedBuffer
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapNamedBuffer( GLuint buffer, GLenum access )
{
    struct qemu_glMapNamedBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPNAMEDBUFFER);
    call.buffer = buffer;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapNamedBuffer(struct qemu_syscall *call)
{
    struct qemu_glMapNamedBuffer *c = (struct qemu_glMapNamedBuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapNamedBuffer( c->buffer, c->access ));
}

#endif

struct qemu_glMapNamedBufferEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapNamedBufferEXT( GLuint buffer, GLenum access )
{
    struct qemu_glMapNamedBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPNAMEDBUFFEREXT);
    call.buffer = buffer;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapNamedBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glMapNamedBufferEXT *c = (struct qemu_glMapNamedBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapNamedBufferEXT( c->buffer, c->access ));
}

#endif

struct qemu_glMapNamedBufferRange
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t length;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapNamedBufferRange( GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access )
{
    struct qemu_glMapNamedBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPNAMEDBUFFERRANGE);
    call.buffer = buffer;
    call.offset = offset;
    call.length = length;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapNamedBufferRange(struct qemu_syscall *call)
{
    struct qemu_glMapNamedBufferRange *c = (struct qemu_glMapNamedBufferRange *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapNamedBufferRange( c->buffer, c->offset, c->length, c->access ));
}

#endif

struct qemu_glMapNamedBufferRangeEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t length;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapNamedBufferRangeEXT( GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access )
{
    struct qemu_glMapNamedBufferRangeEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPNAMEDBUFFERRANGEEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.length = length;
    call.access = access;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapNamedBufferRangeEXT(struct qemu_syscall *call)
{
    struct qemu_glMapNamedBufferRangeEXT *c = (struct qemu_glMapNamedBufferRangeEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapNamedBufferRangeEXT( c->buffer, c->offset, c->length, c->access ));
}

#endif

struct qemu_glMapObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapObjectBufferATI( GLuint buffer )
{
    struct qemu_glMapObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPOBJECTBUFFERATI);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glMapObjectBufferATI *c = (struct qemu_glMapObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapObjectBufferATI( c->buffer ));
}

#endif

struct qemu_glMapParameterfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapParameterfvNV( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glMapParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPPARAMETERFVNV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glMapParameterfvNV *c = (struct qemu_glMapParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapParameterfvNV( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMapParameterivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapParameterivNV( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glMapParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPPARAMETERIVNV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glMapParameterivNV *c = (struct qemu_glMapParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapParameterivNV( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMapTexture2DINTEL
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t access;
    uint64_t stride;
    uint64_t layout;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI glMapTexture2DINTEL( GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout )
{
    struct qemu_glMapTexture2DINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPTEXTURE2DINTEL);
    call.texture = texture;
    call.level = level;
    call.access = access;
    call.stride = (ULONG_PTR)stride;
    call.layout = (ULONG_PTR)layout;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_glMapTexture2DINTEL(struct qemu_syscall *call)
{
    struct qemu_glMapTexture2DINTEL *c = (struct qemu_glMapTexture2DINTEL *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_glMapTexture2DINTEL( c->texture, c->level, c->access, QEMU_G2H(c->stride), QEMU_G2H(c->layout) ));
}

#endif

struct qemu_glMapVertexAttrib1dAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    double u1;
    double u2;
    uint64_t stride;
    uint64_t order;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapVertexAttrib1dAPPLE( GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points )
{
    struct qemu_glMapVertexAttrib1dAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPVERTEXATTRIB1DAPPLE);
    call.index = index;
    call.size = size;
    call.u1 = u1;
    call.u2 = u2;
    call.stride = stride;
    call.order = order;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapVertexAttrib1dAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMapVertexAttrib1dAPPLE *c = (struct qemu_glMapVertexAttrib1dAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapVertexAttrib1dAPPLE( c->index, c->size, c->u1, c->u2, c->stride, c->order, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glMapVertexAttrib1fAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    double u1;
    double u2;
    uint64_t stride;
    uint64_t order;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapVertexAttrib1fAPPLE( GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points )
{
    struct qemu_glMapVertexAttrib1fAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPVERTEXATTRIB1FAPPLE);
    call.index = index;
    call.size = size;
    call.u1 = u1;
    call.u2 = u2;
    call.stride = stride;
    call.order = order;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapVertexAttrib1fAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMapVertexAttrib1fAPPLE *c = (struct qemu_glMapVertexAttrib1fAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapVertexAttrib1fAPPLE( c->index, c->size, c->u1, c->u2, c->stride, c->order, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glMapVertexAttrib2dAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    double u1;
    double u2;
    uint64_t ustride;
    uint64_t uorder;
    double v1;
    double v2;
    uint64_t vstride;
    uint64_t vorder;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapVertexAttrib2dAPPLE( GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points )
{
    struct qemu_glMapVertexAttrib2dAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPVERTEXATTRIB2DAPPLE);
    call.index = index;
    call.size = size;
    call.u1 = u1;
    call.u2 = u2;
    call.ustride = ustride;
    call.uorder = uorder;
    call.v1 = v1;
    call.v2 = v2;
    call.vstride = vstride;
    call.vorder = vorder;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapVertexAttrib2dAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMapVertexAttrib2dAPPLE *c = (struct qemu_glMapVertexAttrib2dAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapVertexAttrib2dAPPLE( c->index, c->size, c->u1, c->u2, c->ustride, c->uorder, c->v1, c->v2, c->vstride, c->vorder, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glMapVertexAttrib2fAPPLE
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    double u1;
    double u2;
    uint64_t ustride;
    uint64_t uorder;
    double v1;
    double v2;
    uint64_t vstride;
    uint64_t vorder;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMapVertexAttrib2fAPPLE( GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points )
{
    struct qemu_glMapVertexAttrib2fAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAPVERTEXATTRIB2FAPPLE);
    call.index = index;
    call.size = size;
    call.u1 = u1;
    call.u2 = u2;
    call.ustride = ustride;
    call.uorder = uorder;
    call.v1 = v1;
    call.v2 = v2;
    call.vstride = vstride;
    call.vorder = vorder;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glMapVertexAttrib2fAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMapVertexAttrib2fAPPLE *c = (struct qemu_glMapVertexAttrib2fAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMapVertexAttrib2fAPPLE( c->index, c->size, c->u1, c->u2, c->ustride, c->uorder, c->v1, c->v2, c->vstride, c->vorder, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glMaterialxOES
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMaterialxOES( GLenum face, GLenum pname, GLfixed param )
{
    struct qemu_glMaterialxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATERIALXOES);
    call.face = face;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMaterialxOES(struct qemu_syscall *call)
{
    struct qemu_glMaterialxOES *c = (struct qemu_glMaterialxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMaterialxOES( c->face, c->pname, c->param ));
}

#endif

struct qemu_glMaterialxvOES
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMaterialxvOES( GLenum face, GLenum pname, const GLfixed *param )
{
    struct qemu_glMaterialxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATERIALXVOES);
    call.face = face;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMaterialxvOES(struct qemu_syscall *call)
{
    struct qemu_glMaterialxvOES *c = (struct qemu_glMaterialxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMaterialxvOES( c->face, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glMatrixFrustumEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double left;
    double right;
    double bottom;
    double top;
    double zNear;
    double zFar;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixFrustumEXT( GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
    struct qemu_glMatrixFrustumEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXFRUSTUMEXT);
    call.mode = mode;
    call.left = left;
    call.right = right;
    call.bottom = bottom;
    call.top = top;
    call.zNear = zNear;
    call.zFar = zFar;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixFrustumEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixFrustumEXT *c = (struct qemu_glMatrixFrustumEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixFrustumEXT( c->mode, c->left, c->right, c->bottom, c->top, c->zNear, c->zFar ));
}

#endif

struct qemu_glMatrixIndexPointerARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixIndexPointerARB( GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glMatrixIndexPointerARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXINDEXPOINTERARB);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixIndexPointerARB(struct qemu_syscall *call)
{
    struct qemu_glMatrixIndexPointerARB *c = (struct qemu_glMatrixIndexPointerARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixIndexPointerARB( c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glMatrixIndexubvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixIndexubvARB( GLint size, const GLubyte *indices )
{
    struct qemu_glMatrixIndexubvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXINDEXUBVARB);
    call.size = size;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixIndexubvARB(struct qemu_syscall *call)
{
    struct qemu_glMatrixIndexubvARB *c = (struct qemu_glMatrixIndexubvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixIndexubvARB( c->size, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glMatrixIndexuivARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixIndexuivARB( GLint size, const GLuint *indices )
{
    struct qemu_glMatrixIndexuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXINDEXUIVARB);
    call.size = size;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixIndexuivARB(struct qemu_syscall *call)
{
    struct qemu_glMatrixIndexuivARB *c = (struct qemu_glMatrixIndexuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixIndexuivARB( c->size, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glMatrixIndexusvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixIndexusvARB( GLint size, const GLushort *indices )
{
    struct qemu_glMatrixIndexusvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXINDEXUSVARB);
    call.size = size;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixIndexusvARB(struct qemu_syscall *call)
{
    struct qemu_glMatrixIndexusvARB *c = (struct qemu_glMatrixIndexusvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixIndexusvARB( c->size, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glMatrixLoad3x2fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoad3x2fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixLoad3x2fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOAD3X2FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoad3x2fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoad3x2fNV *c = (struct qemu_glMatrixLoad3x2fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoad3x2fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoad3x3fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoad3x3fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixLoad3x3fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOAD3X3FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoad3x3fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoad3x3fNV *c = (struct qemu_glMatrixLoad3x3fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoad3x3fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoadIdentityEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoadIdentityEXT( GLenum mode )
{
    struct qemu_glMatrixLoadIdentityEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADIDENTITYEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoadIdentityEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoadIdentityEXT *c = (struct qemu_glMatrixLoadIdentityEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoadIdentityEXT( c->mode ));
}

#endif

struct qemu_glMatrixLoadTranspose3x3fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoadTranspose3x3fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixLoadTranspose3x3fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADTRANSPOSE3X3FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoadTranspose3x3fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoadTranspose3x3fNV *c = (struct qemu_glMatrixLoadTranspose3x3fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoadTranspose3x3fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoadTransposedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoadTransposedEXT( GLenum mode, const GLdouble *m )
{
    struct qemu_glMatrixLoadTransposedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADTRANSPOSEDEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoadTransposedEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoadTransposedEXT *c = (struct qemu_glMatrixLoadTransposedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoadTransposedEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoadTransposefEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoadTransposefEXT( GLenum mode, const GLfloat *m )
{
    struct qemu_glMatrixLoadTransposefEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADTRANSPOSEFEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoadTransposefEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoadTransposefEXT *c = (struct qemu_glMatrixLoadTransposefEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoadTransposefEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoaddEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoaddEXT( GLenum mode, const GLdouble *m )
{
    struct qemu_glMatrixLoaddEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADDEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoaddEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoaddEXT *c = (struct qemu_glMatrixLoaddEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoaddEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixLoadfEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixLoadfEXT( GLenum mode, const GLfloat *m )
{
    struct qemu_glMatrixLoadfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXLOADFEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixLoadfEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixLoadfEXT *c = (struct qemu_glMatrixLoadfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixLoadfEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMult3x2fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMult3x2fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixMult3x2fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULT3X2FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMult3x2fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixMult3x2fNV *c = (struct qemu_glMatrixMult3x2fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMult3x2fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMult3x3fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMult3x3fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixMult3x3fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULT3X3FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMult3x3fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixMult3x3fNV *c = (struct qemu_glMatrixMult3x3fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMult3x3fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMultTranspose3x3fNV
{
    struct qemu_syscall super;
    uint64_t matrixMode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMultTranspose3x3fNV( GLenum matrixMode, const GLfloat *m )
{
    struct qemu_glMatrixMultTranspose3x3fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULTTRANSPOSE3X3FNV);
    call.matrixMode = matrixMode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMultTranspose3x3fNV(struct qemu_syscall *call)
{
    struct qemu_glMatrixMultTranspose3x3fNV *c = (struct qemu_glMatrixMultTranspose3x3fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMultTranspose3x3fNV( c->matrixMode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMultTransposedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMultTransposedEXT( GLenum mode, const GLdouble *m )
{
    struct qemu_glMatrixMultTransposedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULTTRANSPOSEDEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMultTransposedEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixMultTransposedEXT *c = (struct qemu_glMatrixMultTransposedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMultTransposedEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMultTransposefEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMultTransposefEXT( GLenum mode, const GLfloat *m )
{
    struct qemu_glMatrixMultTransposefEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULTTRANSPOSEFEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMultTransposefEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixMultTransposefEXT *c = (struct qemu_glMatrixMultTransposefEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMultTransposefEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMultdEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMultdEXT( GLenum mode, const GLdouble *m )
{
    struct qemu_glMatrixMultdEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULTDEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMultdEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixMultdEXT *c = (struct qemu_glMatrixMultdEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMultdEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixMultfEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixMultfEXT( GLenum mode, const GLfloat *m )
{
    struct qemu_glMatrixMultfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXMULTFEXT);
    call.mode = mode;
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixMultfEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixMultfEXT *c = (struct qemu_glMatrixMultfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixMultfEXT( c->mode, QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMatrixOrthoEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double left;
    double right;
    double bottom;
    double top;
    double zNear;
    double zFar;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixOrthoEXT( GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
    struct qemu_glMatrixOrthoEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXORTHOEXT);
    call.mode = mode;
    call.left = left;
    call.right = right;
    call.bottom = bottom;
    call.top = top;
    call.zNear = zNear;
    call.zFar = zFar;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixOrthoEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixOrthoEXT *c = (struct qemu_glMatrixOrthoEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixOrthoEXT( c->mode, c->left, c->right, c->bottom, c->top, c->zNear, c->zFar ));
}

#endif

struct qemu_glMatrixPopEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixPopEXT( GLenum mode )
{
    struct qemu_glMatrixPopEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXPOPEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixPopEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixPopEXT *c = (struct qemu_glMatrixPopEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixPopEXT( c->mode ));
}

#endif

struct qemu_glMatrixPushEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixPushEXT( GLenum mode )
{
    struct qemu_glMatrixPushEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXPUSHEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixPushEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixPushEXT *c = (struct qemu_glMatrixPushEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixPushEXT( c->mode ));
}

#endif

struct qemu_glMatrixRotatedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double angle;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixRotatedEXT( GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glMatrixRotatedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXROTATEDEXT);
    call.mode = mode;
    call.angle = angle;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixRotatedEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixRotatedEXT *c = (struct qemu_glMatrixRotatedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixRotatedEXT( c->mode, c->angle, c->x, c->y, c->z ));
}

#endif

struct qemu_glMatrixRotatefEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double angle;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixRotatefEXT( GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glMatrixRotatefEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXROTATEFEXT);
    call.mode = mode;
    call.angle = angle;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixRotatefEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixRotatefEXT *c = (struct qemu_glMatrixRotatefEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixRotatefEXT( c->mode, c->angle, c->x, c->y, c->z ));
}

#endif

struct qemu_glMatrixScaledEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixScaledEXT( GLenum mode, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glMatrixScaledEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXSCALEDEXT);
    call.mode = mode;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixScaledEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixScaledEXT *c = (struct qemu_glMatrixScaledEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixScaledEXT( c->mode, c->x, c->y, c->z ));
}

#endif

struct qemu_glMatrixScalefEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixScalefEXT( GLenum mode, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glMatrixScalefEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXSCALEFEXT);
    call.mode = mode;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixScalefEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixScalefEXT *c = (struct qemu_glMatrixScalefEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixScalefEXT( c->mode, c->x, c->y, c->z ));
}

#endif

struct qemu_glMatrixTranslatedEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixTranslatedEXT( GLenum mode, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glMatrixTranslatedEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXTRANSLATEDEXT);
    call.mode = mode;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixTranslatedEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixTranslatedEXT *c = (struct qemu_glMatrixTranslatedEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixTranslatedEXT( c->mode, c->x, c->y, c->z ));
}

#endif

struct qemu_glMatrixTranslatefEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMatrixTranslatefEXT( GLenum mode, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glMatrixTranslatefEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMATRIXTRANSLATEFEXT);
    call.mode = mode;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glMatrixTranslatefEXT(struct qemu_syscall *call)
{
    struct qemu_glMatrixTranslatefEXT *c = (struct qemu_glMatrixTranslatefEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMatrixTranslatefEXT( c->mode, c->x, c->y, c->z ));
}

#endif

struct qemu_glMaxShaderCompilerThreadsARB
{
    struct qemu_syscall super;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMaxShaderCompilerThreadsARB( GLuint count )
{
    struct qemu_glMaxShaderCompilerThreadsARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAXSHADERCOMPILERTHREADSARB);
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glMaxShaderCompilerThreadsARB(struct qemu_syscall *call)
{
    struct qemu_glMaxShaderCompilerThreadsARB *c = (struct qemu_glMaxShaderCompilerThreadsARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMaxShaderCompilerThreadsARB( c->count ));
}

#endif

struct qemu_glMaxShaderCompilerThreadsKHR
{
    struct qemu_syscall super;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMaxShaderCompilerThreadsKHR( GLuint count )
{
    struct qemu_glMaxShaderCompilerThreadsKHR call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMAXSHADERCOMPILERTHREADSKHR);
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glMaxShaderCompilerThreadsKHR(struct qemu_syscall *call)
{
    struct qemu_glMaxShaderCompilerThreadsKHR *c = (struct qemu_glMaxShaderCompilerThreadsKHR *)call;
    WINE_FIXME("Unverified\n");
    (p_glMaxShaderCompilerThreadsKHR( c->count ));
}

#endif

struct qemu_glMemoryBarrier
{
    struct qemu_syscall super;
    uint64_t barriers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMemoryBarrier( GLbitfield barriers )
{
    struct qemu_glMemoryBarrier call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMEMORYBARRIER);
    call.barriers = barriers;

    qemu_syscall(&call.super);
}

#else

void qemu_glMemoryBarrier(struct qemu_syscall *call)
{
    struct qemu_glMemoryBarrier *c = (struct qemu_glMemoryBarrier *)call;
    WINE_FIXME("Unverified\n");
    (p_glMemoryBarrier( c->barriers ));
}

#endif

struct qemu_glMemoryBarrierByRegion
{
    struct qemu_syscall super;
    uint64_t barriers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMemoryBarrierByRegion( GLbitfield barriers )
{
    struct qemu_glMemoryBarrierByRegion call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMEMORYBARRIERBYREGION);
    call.barriers = barriers;

    qemu_syscall(&call.super);
}

#else

void qemu_glMemoryBarrierByRegion(struct qemu_syscall *call)
{
    struct qemu_glMemoryBarrierByRegion *c = (struct qemu_glMemoryBarrierByRegion *)call;
    WINE_FIXME("Unverified\n");
    (p_glMemoryBarrierByRegion( c->barriers ));
}

#endif

struct qemu_glMemoryBarrierEXT
{
    struct qemu_syscall super;
    uint64_t barriers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMemoryBarrierEXT( GLbitfield barriers )
{
    struct qemu_glMemoryBarrierEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMEMORYBARRIEREXT);
    call.barriers = barriers;

    qemu_syscall(&call.super);
}

#else

void qemu_glMemoryBarrierEXT(struct qemu_syscall *call)
{
    struct qemu_glMemoryBarrierEXT *c = (struct qemu_glMemoryBarrierEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMemoryBarrierEXT( c->barriers ));
}

#endif

struct qemu_glMemoryObjectParameterivEXT
{
    struct qemu_syscall super;
    uint64_t memoryObject;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMemoryObjectParameterivEXT( GLuint memoryObject, GLenum pname, const GLint *params )
{
    struct qemu_glMemoryObjectParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMEMORYOBJECTPARAMETERIVEXT);
    call.memoryObject = memoryObject;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMemoryObjectParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glMemoryObjectParameterivEXT *c = (struct qemu_glMemoryObjectParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMemoryObjectParameterivEXT( c->memoryObject, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMinSampleShading
{
    struct qemu_syscall super;
    double value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMinSampleShading( GLfloat value )
{
    struct qemu_glMinSampleShading call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMINSAMPLESHADING);
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glMinSampleShading(struct qemu_syscall *call)
{
    struct qemu_glMinSampleShading *c = (struct qemu_glMinSampleShading *)call;
    WINE_FIXME("Unverified\n");
    (p_glMinSampleShading( c->value ));
}

#endif

struct qemu_glMinSampleShadingARB
{
    struct qemu_syscall super;
    double value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMinSampleShadingARB( GLfloat value )
{
    struct qemu_glMinSampleShadingARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMINSAMPLESHADINGARB);
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glMinSampleShadingARB(struct qemu_syscall *call)
{
    struct qemu_glMinSampleShadingARB *c = (struct qemu_glMinSampleShadingARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMinSampleShadingARB( c->value ));
}

#endif

struct qemu_glMinmax
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t sink;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMinmax( GLenum target, GLenum internalformat, GLboolean sink )
{
    struct qemu_glMinmax call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMINMAX);
    call.target = target;
    call.internalformat = internalformat;
    call.sink = sink;

    qemu_syscall(&call.super);
}

#else

void qemu_glMinmax(struct qemu_syscall *call)
{
    struct qemu_glMinmax *c = (struct qemu_glMinmax *)call;
    WINE_FIXME("Unverified\n");
    (p_glMinmax( c->target, c->internalformat, c->sink ));
}

#endif

struct qemu_glMinmaxEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t sink;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMinmaxEXT( GLenum target, GLenum internalformat, GLboolean sink )
{
    struct qemu_glMinmaxEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMINMAXEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.sink = sink;

    qemu_syscall(&call.super);
}

#else

void qemu_glMinmaxEXT(struct qemu_syscall *call)
{
    struct qemu_glMinmaxEXT *c = (struct qemu_glMinmaxEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMinmaxEXT( c->target, c->internalformat, c->sink ));
}

#endif

struct qemu_glMultMatrixxOES
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultMatrixxOES( const GLfixed *m )
{
    struct qemu_glMultMatrixxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTMATRIXXOES);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultMatrixxOES(struct qemu_syscall *call)
{
    struct qemu_glMultMatrixxOES *c = (struct qemu_glMultMatrixxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultMatrixxOES( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultTransposeMatrixd
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultTransposeMatrixd( const GLdouble *m )
{
    struct qemu_glMultTransposeMatrixd call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTTRANSPOSEMATRIXD);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultTransposeMatrixd(struct qemu_syscall *call)
{
    struct qemu_glMultTransposeMatrixd *c = (struct qemu_glMultTransposeMatrixd *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultTransposeMatrixd( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultTransposeMatrixdARB
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultTransposeMatrixdARB( const GLdouble *m )
{
    struct qemu_glMultTransposeMatrixdARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTTRANSPOSEMATRIXDARB);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultTransposeMatrixdARB(struct qemu_syscall *call)
{
    struct qemu_glMultTransposeMatrixdARB *c = (struct qemu_glMultTransposeMatrixdARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultTransposeMatrixdARB( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultTransposeMatrixf
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultTransposeMatrixf( const GLfloat *m )
{
    struct qemu_glMultTransposeMatrixf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTTRANSPOSEMATRIXF);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultTransposeMatrixf(struct qemu_syscall *call)
{
    struct qemu_glMultTransposeMatrixf *c = (struct qemu_glMultTransposeMatrixf *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultTransposeMatrixf( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultTransposeMatrixfARB
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultTransposeMatrixfARB( const GLfloat *m )
{
    struct qemu_glMultTransposeMatrixfARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTTRANSPOSEMATRIXFARB);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultTransposeMatrixfARB(struct qemu_syscall *call)
{
    struct qemu_glMultTransposeMatrixfARB *c = (struct qemu_glMultTransposeMatrixfARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultTransposeMatrixfARB( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultTransposeMatrixxOES
{
    struct qemu_syscall super;
    uint64_t m;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultTransposeMatrixxOES( const GLfixed *m )
{
    struct qemu_glMultTransposeMatrixxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTTRANSPOSEMATRIXXOES);
    call.m = (ULONG_PTR)m;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultTransposeMatrixxOES(struct qemu_syscall *call)
{
    struct qemu_glMultTransposeMatrixxOES *c = (struct qemu_glMultTransposeMatrixxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultTransposeMatrixxOES( QEMU_G2H(c->m) ));
}

#endif

struct qemu_glMultiDrawArrays
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t drawcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArrays( GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount )
{
    struct qemu_glMultiDrawArrays call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYS);
    call.mode = mode;
    call.first = (ULONG_PTR)first;
    call.count = (ULONG_PTR)count;
    call.drawcount = drawcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArrays(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArrays *c = (struct qemu_glMultiDrawArrays *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArrays( c->mode, QEMU_G2H(c->first), QEMU_G2H(c->count), c->drawcount ));
}

#endif

struct qemu_glMultiDrawArraysEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysEXT( GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount )
{
    struct qemu_glMultiDrawArraysEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSEXT);
    call.mode = mode;
    call.first = (ULONG_PTR)first;
    call.count = (ULONG_PTR)count;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysEXT *c = (struct qemu_glMultiDrawArraysEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysEXT( c->mode, QEMU_G2H(c->first), QEMU_G2H(c->count), c->primcount ));
}

#endif

struct qemu_glMultiDrawArraysIndirect
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirect( GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride )
{
    struct qemu_glMultiDrawArraysIndirect call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECT);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirect(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirect *c = (struct qemu_glMultiDrawArraysIndirect *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirect( c->mode, QEMU_G2H(c->indirect), c->drawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawArraysIndirectAMD
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t primcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirectAMD( GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride )
{
    struct qemu_glMultiDrawArraysIndirectAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECTAMD);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.primcount = primcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirectAMD(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirectAMD *c = (struct qemu_glMultiDrawArraysIndirectAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirectAMD( c->mode, QEMU_G2H(c->indirect), c->primcount, c->stride ));
}

#endif

struct qemu_glMultiDrawArraysIndirectBindlessCountNV
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t drawCount;
    uint64_t maxDrawCount;
    uint64_t stride;
    uint64_t vertexBufferCount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirectBindlessCountNV( GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount )
{
    struct qemu_glMultiDrawArraysIndirectBindlessCountNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNV);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.drawCount = drawCount;
    call.maxDrawCount = maxDrawCount;
    call.stride = stride;
    call.vertexBufferCount = vertexBufferCount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirectBindlessCountNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirectBindlessCountNV *c = (struct qemu_glMultiDrawArraysIndirectBindlessCountNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirectBindlessCountNV( c->mode, QEMU_G2H(c->indirect), c->drawCount, c->maxDrawCount, c->stride, c->vertexBufferCount ));
}

#endif

struct qemu_glMultiDrawArraysIndirectBindlessNV
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t drawCount;
    uint64_t stride;
    uint64_t vertexBufferCount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirectBindlessNV( GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount )
{
    struct qemu_glMultiDrawArraysIndirectBindlessNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECTBINDLESSNV);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.drawCount = drawCount;
    call.stride = stride;
    call.vertexBufferCount = vertexBufferCount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirectBindlessNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirectBindlessNV *c = (struct qemu_glMultiDrawArraysIndirectBindlessNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirectBindlessNV( c->mode, QEMU_G2H(c->indirect), c->drawCount, c->stride, c->vertexBufferCount ));
}

#endif

struct qemu_glMultiDrawArraysIndirectCount
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t maxdrawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirectCount( GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride )
{
    struct qemu_glMultiDrawArraysIndirectCount call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECTCOUNT);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.maxdrawcount = maxdrawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirectCount(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirectCount *c = (struct qemu_glMultiDrawArraysIndirectCount *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirectCount( c->mode, QEMU_G2H(c->indirect), c->drawcount, c->maxdrawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawArraysIndirectCountARB
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t maxdrawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawArraysIndirectCountARB( GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride )
{
    struct qemu_glMultiDrawArraysIndirectCountARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWARRAYSINDIRECTCOUNTARB);
    call.mode = mode;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.maxdrawcount = maxdrawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawArraysIndirectCountARB(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawArraysIndirectCountARB *c = (struct qemu_glMultiDrawArraysIndirectCountARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawArraysIndirectCountARB( c->mode, QEMU_G2H(c->indirect), c->drawcount, c->maxdrawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawElementArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementArrayAPPLE( GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount )
{
    struct qemu_glMultiDrawElementArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTARRAYAPPLE);
    call.mode = mode;
    call.first = (ULONG_PTR)first;
    call.count = (ULONG_PTR)count;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementArrayAPPLE *c = (struct qemu_glMultiDrawElementArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementArrayAPPLE( c->mode, QEMU_G2H(c->first), QEMU_G2H(c->count), c->primcount ));
}

#endif

struct qemu_glMultiDrawElements
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t drawcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElements( GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount )
{
    struct qemu_glMultiDrawElements call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTS);
    call.mode = mode;
    call.count = (ULONG_PTR)count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.drawcount = drawcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElements(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElements *c = (struct qemu_glMultiDrawElements *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElements( c->mode, QEMU_G2H(c->count), c->type, QEMU_G2H(c->indices), c->drawcount ));
}

#endif

struct qemu_glMultiDrawElementsBaseVertex
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t drawcount;
    uint64_t basevertex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsBaseVertex( GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex )
{
    struct qemu_glMultiDrawElementsBaseVertex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSBASEVERTEX);
    call.mode = mode;
    call.count = (ULONG_PTR)count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.drawcount = drawcount;
    call.basevertex = (ULONG_PTR)basevertex;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsBaseVertex(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsBaseVertex *c = (struct qemu_glMultiDrawElementsBaseVertex *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsBaseVertex( c->mode, QEMU_G2H(c->count), c->type, QEMU_G2H(c->indices), c->drawcount, QEMU_G2H(c->basevertex) ));
}

#endif

struct qemu_glMultiDrawElementsEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsEXT( GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount )
{
    struct qemu_glMultiDrawElementsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSEXT);
    call.mode = mode;
    call.count = (ULONG_PTR)count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsEXT *c = (struct qemu_glMultiDrawElementsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsEXT( c->mode, QEMU_G2H(c->count), c->type, QEMU_G2H(c->indices), c->primcount ));
}

#endif

struct qemu_glMultiDrawElementsIndirect
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirect( GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride )
{
    struct qemu_glMultiDrawElementsIndirect call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECT);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirect(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirect *c = (struct qemu_glMultiDrawElementsIndirect *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirect( c->mode, c->type, QEMU_G2H(c->indirect), c->drawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawElementsIndirectAMD
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t primcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirectAMD( GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride )
{
    struct qemu_glMultiDrawElementsIndirectAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECTAMD);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.primcount = primcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirectAMD(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirectAMD *c = (struct qemu_glMultiDrawElementsIndirectAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirectAMD( c->mode, c->type, QEMU_G2H(c->indirect), c->primcount, c->stride ));
}

#endif

struct qemu_glMultiDrawElementsIndirectBindlessCountNV
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t drawCount;
    uint64_t maxDrawCount;
    uint64_t stride;
    uint64_t vertexBufferCount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirectBindlessCountNV( GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount )
{
    struct qemu_glMultiDrawElementsIndirectBindlessCountNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNV);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.drawCount = drawCount;
    call.maxDrawCount = maxDrawCount;
    call.stride = stride;
    call.vertexBufferCount = vertexBufferCount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirectBindlessCountNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirectBindlessCountNV *c = (struct qemu_glMultiDrawElementsIndirectBindlessCountNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirectBindlessCountNV( c->mode, c->type, QEMU_G2H(c->indirect), c->drawCount, c->maxDrawCount, c->stride, c->vertexBufferCount ));
}

#endif

struct qemu_glMultiDrawElementsIndirectBindlessNV
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t drawCount;
    uint64_t stride;
    uint64_t vertexBufferCount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirectBindlessNV( GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount )
{
    struct qemu_glMultiDrawElementsIndirectBindlessNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECTBINDLESSNV);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.drawCount = drawCount;
    call.stride = stride;
    call.vertexBufferCount = vertexBufferCount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirectBindlessNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirectBindlessNV *c = (struct qemu_glMultiDrawElementsIndirectBindlessNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirectBindlessNV( c->mode, c->type, QEMU_G2H(c->indirect), c->drawCount, c->stride, c->vertexBufferCount ));
}

#endif

struct qemu_glMultiDrawElementsIndirectCount
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t maxdrawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirectCount( GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride )
{
    struct qemu_glMultiDrawElementsIndirectCount call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECTCOUNT);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.maxdrawcount = maxdrawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirectCount(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirectCount *c = (struct qemu_glMultiDrawElementsIndirectCount *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirectCount( c->mode, c->type, QEMU_G2H(c->indirect), c->drawcount, c->maxdrawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawElementsIndirectCountARB
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t type;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t maxdrawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawElementsIndirectCountARB( GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride )
{
    struct qemu_glMultiDrawElementsIndirectCountARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWELEMENTSINDIRECTCOUNTARB);
    call.mode = mode;
    call.type = type;
    call.indirect = (ULONG_PTR)indirect;
    call.drawcount = drawcount;
    call.maxdrawcount = maxdrawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawElementsIndirectCountARB(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawElementsIndirectCountARB *c = (struct qemu_glMultiDrawElementsIndirectCountARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawElementsIndirectCountARB( c->mode, c->type, QEMU_G2H(c->indirect), c->drawcount, c->maxdrawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawMeshTasksIndirectCountNV
{
    struct qemu_syscall super;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t maxdrawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawMeshTasksIndirectCountNV( GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride )
{
    struct qemu_glMultiDrawMeshTasksIndirectCountNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWMESHTASKSINDIRECTCOUNTNV);
    call.indirect = indirect;
    call.drawcount = drawcount;
    call.maxdrawcount = maxdrawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawMeshTasksIndirectCountNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawMeshTasksIndirectCountNV *c = (struct qemu_glMultiDrawMeshTasksIndirectCountNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawMeshTasksIndirectCountNV( c->indirect, c->drawcount, c->maxdrawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawMeshTasksIndirectNV
{
    struct qemu_syscall super;
    uint64_t indirect;
    uint64_t drawcount;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawMeshTasksIndirectNV( GLintptr indirect, GLsizei drawcount, GLsizei stride )
{
    struct qemu_glMultiDrawMeshTasksIndirectNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWMESHTASKSINDIRECTNV);
    call.indirect = indirect;
    call.drawcount = drawcount;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawMeshTasksIndirectNV(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawMeshTasksIndirectNV *c = (struct qemu_glMultiDrawMeshTasksIndirectNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawMeshTasksIndirectNV( c->indirect, c->drawcount, c->stride ));
}

#endif

struct qemu_glMultiDrawRangeElementArrayAPPLE
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t start;
    uint64_t end;
    uint64_t first;
    uint64_t count;
    uint64_t primcount;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiDrawRangeElementArrayAPPLE( GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount )
{
    struct qemu_glMultiDrawRangeElementArrayAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIDRAWRANGEELEMENTARRAYAPPLE);
    call.mode = mode;
    call.start = start;
    call.end = end;
    call.first = (ULONG_PTR)first;
    call.count = (ULONG_PTR)count;
    call.primcount = primcount;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiDrawRangeElementArrayAPPLE(struct qemu_syscall *call)
{
    struct qemu_glMultiDrawRangeElementArrayAPPLE *c = (struct qemu_glMultiDrawRangeElementArrayAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiDrawRangeElementArrayAPPLE( c->mode, c->start, c->end, QEMU_G2H(c->first), QEMU_G2H(c->count), c->primcount ));
}

#endif

struct qemu_glMultiModeDrawArraysIBM
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t first;
    uint64_t count;
    uint64_t primcount;
    uint64_t modestride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiModeDrawArraysIBM( const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride )
{
    struct qemu_glMultiModeDrawArraysIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIMODEDRAWARRAYSIBM);
    call.mode = (ULONG_PTR)mode;
    call.first = (ULONG_PTR)first;
    call.count = (ULONG_PTR)count;
    call.primcount = primcount;
    call.modestride = modestride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiModeDrawArraysIBM(struct qemu_syscall *call)
{
    struct qemu_glMultiModeDrawArraysIBM *c = (struct qemu_glMultiModeDrawArraysIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiModeDrawArraysIBM( QEMU_G2H(c->mode), QEMU_G2H(c->first), QEMU_G2H(c->count), c->primcount, c->modestride ));
}

#endif

struct qemu_glMultiModeDrawElementsIBM
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t type;
    uint64_t indices;
    uint64_t primcount;
    uint64_t modestride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiModeDrawElementsIBM( const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride )
{
    struct qemu_glMultiModeDrawElementsIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTIMODEDRAWELEMENTSIBM);
    call.mode = (ULONG_PTR)mode;
    call.count = (ULONG_PTR)count;
    call.type = type;
    call.indices = (ULONG_PTR)indices;
    call.primcount = primcount;
    call.modestride = modestride;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiModeDrawElementsIBM(struct qemu_syscall *call)
{
    struct qemu_glMultiModeDrawElementsIBM *c = (struct qemu_glMultiModeDrawElementsIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiModeDrawElementsIBM( QEMU_G2H(c->mode), QEMU_G2H(c->count), c->type, QEMU_G2H(c->indices), c->primcount, c->modestride ));
}

#endif

struct qemu_glMultiTexBufferEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexBufferEXT( GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer )
{
    struct qemu_glMultiTexBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXBUFFEREXT);
    call.texunit = texunit;
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexBufferEXT *c = (struct qemu_glMultiTexBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexBufferEXT( c->texunit, c->target, c->internalformat, c->buffer ));
}

#endif

struct qemu_glMultiTexCoord1bOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1bOES( GLenum texture, GLbyte s )
{
    struct qemu_glMultiTexCoord1bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1BOES);
    call.texture = texture;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1bOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1bOES *c = (struct qemu_glMultiTexCoord1bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1bOES( c->texture, c->s ));
}

#endif

struct qemu_glMultiTexCoord1bvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1bvOES( GLenum texture, const GLbyte *coords )
{
    struct qemu_glMultiTexCoord1bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1BVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1bvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1bvOES *c = (struct qemu_glMultiTexCoord1bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1bvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord1d
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1d( GLenum target, GLdouble s )
{
    struct qemu_glMultiTexCoord1d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1D);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1d(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1d *c = (struct qemu_glMultiTexCoord1d *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1d( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1dARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1dARB( GLenum target, GLdouble s )
{
    struct qemu_glMultiTexCoord1dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1DARB);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1dARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1dARB *c = (struct qemu_glMultiTexCoord1dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1dARB( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1dSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1dSGIS( GLenum target, GLdouble s )
{
    struct qemu_glMultiTexCoord1dSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1DSGIS);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1dSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1dSGIS *c = (struct qemu_glMultiTexCoord1dSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1dSGIS( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1dv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1dv( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord1dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1DV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1dv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1dv *c = (struct qemu_glMultiTexCoord1dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1dv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1dvARB( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord1dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1DVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1dvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1dvARB *c = (struct qemu_glMultiTexCoord1dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1dvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1dvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1dvSGIS( GLenum target, GLdouble * v )
{
    struct qemu_glMultiTexCoord1dvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1DVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1dvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1dvSGIS *c = (struct qemu_glMultiTexCoord1dvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1dvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1f
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1f( GLenum target, GLfloat s )
{
    struct qemu_glMultiTexCoord1f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1F);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1f(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1f *c = (struct qemu_glMultiTexCoord1f *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1f( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1fARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1fARB( GLenum target, GLfloat s )
{
    struct qemu_glMultiTexCoord1fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1FARB);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1fARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1fARB *c = (struct qemu_glMultiTexCoord1fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1fARB( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1fSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1fSGIS( GLenum target, GLfloat s )
{
    struct qemu_glMultiTexCoord1fSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1FSGIS);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1fSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1fSGIS *c = (struct qemu_glMultiTexCoord1fSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1fSGIS( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1fv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1fv( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord1fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1FV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1fv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1fv *c = (struct qemu_glMultiTexCoord1fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1fv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1fvARB( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord1fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1FVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1fvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1fvARB *c = (struct qemu_glMultiTexCoord1fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1fvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1fvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1fvSGIS( GLenum target, const GLfloat * v )
{
    struct qemu_glMultiTexCoord1fvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1FVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1fvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1fvSGIS *c = (struct qemu_glMultiTexCoord1fvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1fvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1hNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1hNV( GLenum target, GLhalfNV s )
{
    struct qemu_glMultiTexCoord1hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1HNV);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1hNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1hNV *c = (struct qemu_glMultiTexCoord1hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1hNV( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1hvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1hvNV( GLenum target, const GLhalfNV *v )
{
    struct qemu_glMultiTexCoord1hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1HVNV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1hvNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1hvNV *c = (struct qemu_glMultiTexCoord1hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1hvNV( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1i
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1i( GLenum target, GLint s )
{
    struct qemu_glMultiTexCoord1i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1I);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1i(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1i *c = (struct qemu_glMultiTexCoord1i *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1i( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1iARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1iARB( GLenum target, GLint s )
{
    struct qemu_glMultiTexCoord1iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1IARB);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1iARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1iARB *c = (struct qemu_glMultiTexCoord1iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1iARB( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1iSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1iSGIS( GLenum target, GLint s )
{
    struct qemu_glMultiTexCoord1iSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1ISGIS);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1iSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1iSGIS *c = (struct qemu_glMultiTexCoord1iSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1iSGIS( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1iv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1iv( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord1iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1IV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1iv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1iv *c = (struct qemu_glMultiTexCoord1iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1iv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1ivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1ivARB( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord1ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1IVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1ivARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1ivARB *c = (struct qemu_glMultiTexCoord1ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1ivARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1ivSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1ivSGIS( GLenum target, GLint * v )
{
    struct qemu_glMultiTexCoord1ivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1IVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1ivSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1ivSGIS *c = (struct qemu_glMultiTexCoord1ivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1ivSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1s
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1s( GLenum target, GLshort s )
{
    struct qemu_glMultiTexCoord1s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1S);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1s(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1s *c = (struct qemu_glMultiTexCoord1s *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1s( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1sARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1sARB( GLenum target, GLshort s )
{
    struct qemu_glMultiTexCoord1sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1SARB);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1sARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1sARB *c = (struct qemu_glMultiTexCoord1sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1sARB( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1sSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1sSGIS( GLenum target, GLshort s )
{
    struct qemu_glMultiTexCoord1sSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1SSGIS);
    call.target = target;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1sSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1sSGIS *c = (struct qemu_glMultiTexCoord1sSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1sSGIS( c->target, c->s ));
}

#endif

struct qemu_glMultiTexCoord1sv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1sv( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord1sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1SV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1sv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1sv *c = (struct qemu_glMultiTexCoord1sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1sv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1svARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1svARB( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord1svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1SVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1svARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1svARB *c = (struct qemu_glMultiTexCoord1svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1svARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1svSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1svSGIS( GLenum target, GLshort * v )
{
    struct qemu_glMultiTexCoord1svSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1SVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1svSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1svSGIS *c = (struct qemu_glMultiTexCoord1svSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1svSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord1xOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1xOES( GLenum texture, GLfixed s )
{
    struct qemu_glMultiTexCoord1xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1XOES);
    call.texture = texture;
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1xOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1xOES *c = (struct qemu_glMultiTexCoord1xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1xOES( c->texture, c->s ));
}

#endif

struct qemu_glMultiTexCoord1xvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord1xvOES( GLenum texture, const GLfixed *coords )
{
    struct qemu_glMultiTexCoord1xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD1XVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord1xvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord1xvOES *c = (struct qemu_glMultiTexCoord1xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord1xvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord2bOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2bOES( GLenum texture, GLbyte s, GLbyte t )
{
    struct qemu_glMultiTexCoord2bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2BOES);
    call.texture = texture;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2bOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2bOES *c = (struct qemu_glMultiTexCoord2bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2bOES( c->texture, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2bvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2bvOES( GLenum texture, const GLbyte *coords )
{
    struct qemu_glMultiTexCoord2bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2BVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2bvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2bvOES *c = (struct qemu_glMultiTexCoord2bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2bvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord2d
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2d( GLenum target, GLdouble s, GLdouble t )
{
    struct qemu_glMultiTexCoord2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2D);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2d(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2d *c = (struct qemu_glMultiTexCoord2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2d( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2dARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2dARB( GLenum target, GLdouble s, GLdouble t )
{
    struct qemu_glMultiTexCoord2dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2DARB);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2dARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2dARB *c = (struct qemu_glMultiTexCoord2dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2dARB( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2dSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2dSGIS( GLenum target, GLdouble s, GLdouble t )
{
    struct qemu_glMultiTexCoord2dSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2DSGIS);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2dSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2dSGIS *c = (struct qemu_glMultiTexCoord2dSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2dSGIS( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2dv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2dv( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2DV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2dv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2dv *c = (struct qemu_glMultiTexCoord2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2dv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2dvARB( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord2dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2DVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2dvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2dvARB *c = (struct qemu_glMultiTexCoord2dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2dvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2dvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2dvSGIS( GLenum target, GLdouble * v )
{
    struct qemu_glMultiTexCoord2dvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2DVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2dvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2dvSGIS *c = (struct qemu_glMultiTexCoord2dvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2dvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2f
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2f( GLenum target, GLfloat s, GLfloat t )
{
    struct qemu_glMultiTexCoord2f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2F);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2f(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2f *c = (struct qemu_glMultiTexCoord2f *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2f( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2fARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2fARB( GLenum target, GLfloat s, GLfloat t )
{
    struct qemu_glMultiTexCoord2fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2FARB);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2fARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2fARB *c = (struct qemu_glMultiTexCoord2fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2fARB( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2fSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2fSGIS( GLenum target, GLfloat s, GLfloat t )
{
    struct qemu_glMultiTexCoord2fSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2FSGIS);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2fSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2fSGIS *c = (struct qemu_glMultiTexCoord2fSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2fSGIS( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2fv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2fv( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2FV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2fv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2fv *c = (struct qemu_glMultiTexCoord2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2fv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2fvARB( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord2fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2FVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2fvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2fvARB *c = (struct qemu_glMultiTexCoord2fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2fvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2fvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2fvSGIS( GLenum target, GLfloat * v )
{
    struct qemu_glMultiTexCoord2fvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2FVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2fvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2fvSGIS *c = (struct qemu_glMultiTexCoord2fvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2fvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2hNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2hNV( GLenum target, GLhalfNV s, GLhalfNV t )
{
    struct qemu_glMultiTexCoord2hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2HNV);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2hNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2hNV *c = (struct qemu_glMultiTexCoord2hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2hNV( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2hvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2hvNV( GLenum target, const GLhalfNV *v )
{
    struct qemu_glMultiTexCoord2hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2HVNV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2hvNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2hvNV *c = (struct qemu_glMultiTexCoord2hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2hvNV( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2i
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2i( GLenum target, GLint s, GLint t )
{
    struct qemu_glMultiTexCoord2i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2I);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2i(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2i *c = (struct qemu_glMultiTexCoord2i *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2i( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2iARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2iARB( GLenum target, GLint s, GLint t )
{
    struct qemu_glMultiTexCoord2iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2IARB);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2iARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2iARB *c = (struct qemu_glMultiTexCoord2iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2iARB( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2iSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2iSGIS( GLenum target, GLint s, GLint t )
{
    struct qemu_glMultiTexCoord2iSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2ISGIS);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2iSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2iSGIS *c = (struct qemu_glMultiTexCoord2iSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2iSGIS( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2iv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2iv( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord2iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2IV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2iv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2iv *c = (struct qemu_glMultiTexCoord2iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2iv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2ivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2ivARB( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord2ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2IVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2ivARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2ivARB *c = (struct qemu_glMultiTexCoord2ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2ivARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2ivSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2ivSGIS( GLenum target, GLint * v )
{
    struct qemu_glMultiTexCoord2ivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2IVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2ivSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2ivSGIS *c = (struct qemu_glMultiTexCoord2ivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2ivSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2s
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2s( GLenum target, GLshort s, GLshort t )
{
    struct qemu_glMultiTexCoord2s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2S);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2s(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2s *c = (struct qemu_glMultiTexCoord2s *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2s( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2sARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2sARB( GLenum target, GLshort s, GLshort t )
{
    struct qemu_glMultiTexCoord2sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2SARB);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2sARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2sARB *c = (struct qemu_glMultiTexCoord2sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2sARB( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2sSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2sSGIS( GLenum target, GLshort s, GLshort t )
{
    struct qemu_glMultiTexCoord2sSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2SSGIS);
    call.target = target;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2sSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2sSGIS *c = (struct qemu_glMultiTexCoord2sSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2sSGIS( c->target, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2sv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2sv( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord2sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2SV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2sv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2sv *c = (struct qemu_glMultiTexCoord2sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2sv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2svARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2svARB( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord2svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2SVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2svARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2svARB *c = (struct qemu_glMultiTexCoord2svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2svARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2svSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2svSGIS( GLenum target, GLshort * v )
{
    struct qemu_glMultiTexCoord2svSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2SVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2svSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2svSGIS *c = (struct qemu_glMultiTexCoord2svSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2svSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord2xOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2xOES( GLenum texture, GLfixed s, GLfixed t )
{
    struct qemu_glMultiTexCoord2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2XOES);
    call.texture = texture;
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2xOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2xOES *c = (struct qemu_glMultiTexCoord2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2xOES( c->texture, c->s, c->t ));
}

#endif

struct qemu_glMultiTexCoord2xvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord2xvOES( GLenum texture, const GLfixed *coords )
{
    struct qemu_glMultiTexCoord2xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD2XVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord2xvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord2xvOES *c = (struct qemu_glMultiTexCoord2xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord2xvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord3bOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3bOES( GLenum texture, GLbyte s, GLbyte t, GLbyte r )
{
    struct qemu_glMultiTexCoord3bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3BOES);
    call.texture = texture;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3bOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3bOES *c = (struct qemu_glMultiTexCoord3bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3bOES( c->texture, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3bvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3bvOES( GLenum texture, const GLbyte *coords )
{
    struct qemu_glMultiTexCoord3bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3BVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3bvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3bvOES *c = (struct qemu_glMultiTexCoord3bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3bvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord3d
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3d( GLenum target, GLdouble s, GLdouble t, GLdouble r )
{
    struct qemu_glMultiTexCoord3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3D);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3d(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3d *c = (struct qemu_glMultiTexCoord3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3d( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3dARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3dARB( GLenum target, GLdouble s, GLdouble t, GLdouble r )
{
    struct qemu_glMultiTexCoord3dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3DARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3dARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3dARB *c = (struct qemu_glMultiTexCoord3dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3dARB( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3dSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3dSGIS( GLenum target, GLdouble s, GLdouble t, GLdouble r )
{
    struct qemu_glMultiTexCoord3dSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3DSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3dSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3dSGIS *c = (struct qemu_glMultiTexCoord3dSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3dSGIS( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3dv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3dv( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3DV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3dv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3dv *c = (struct qemu_glMultiTexCoord3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3dv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3dvARB( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord3dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3DVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3dvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3dvARB *c = (struct qemu_glMultiTexCoord3dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3dvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3dvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3dvSGIS( GLenum target, GLdouble * v )
{
    struct qemu_glMultiTexCoord3dvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3DVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3dvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3dvSGIS *c = (struct qemu_glMultiTexCoord3dvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3dvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3f
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3f( GLenum target, GLfloat s, GLfloat t, GLfloat r )
{
    struct qemu_glMultiTexCoord3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3F);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3f(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3f *c = (struct qemu_glMultiTexCoord3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3f( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3fARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3fARB( GLenum target, GLfloat s, GLfloat t, GLfloat r )
{
    struct qemu_glMultiTexCoord3fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3FARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3fARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3fARB *c = (struct qemu_glMultiTexCoord3fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3fARB( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3fSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3fSGIS( GLenum target, GLfloat s, GLfloat t, GLfloat r )
{
    struct qemu_glMultiTexCoord3fSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3FSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3fSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3fSGIS *c = (struct qemu_glMultiTexCoord3fSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3fSGIS( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3fv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3fv( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3FV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3fv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3fv *c = (struct qemu_glMultiTexCoord3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3fv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3fvARB( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord3fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3FVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3fvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3fvARB *c = (struct qemu_glMultiTexCoord3fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3fvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3fvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3fvSGIS( GLenum target, GLfloat * v )
{
    struct qemu_glMultiTexCoord3fvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3FVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3fvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3fvSGIS *c = (struct qemu_glMultiTexCoord3fvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3fvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3hNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3hNV( GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r )
{
    struct qemu_glMultiTexCoord3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3HNV);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3hNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3hNV *c = (struct qemu_glMultiTexCoord3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3hNV( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3hvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3hvNV( GLenum target, const GLhalfNV *v )
{
    struct qemu_glMultiTexCoord3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3HVNV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3hvNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3hvNV *c = (struct qemu_glMultiTexCoord3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3hvNV( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3i
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3i( GLenum target, GLint s, GLint t, GLint r )
{
    struct qemu_glMultiTexCoord3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3I);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3i(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3i *c = (struct qemu_glMultiTexCoord3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3i( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3iARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3iARB( GLenum target, GLint s, GLint t, GLint r )
{
    struct qemu_glMultiTexCoord3iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3IARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3iARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3iARB *c = (struct qemu_glMultiTexCoord3iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3iARB( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3iSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3iSGIS( GLenum target, GLint s, GLint t, GLint r )
{
    struct qemu_glMultiTexCoord3iSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3ISGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3iSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3iSGIS *c = (struct qemu_glMultiTexCoord3iSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3iSGIS( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3iv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3iv( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3IV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3iv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3iv *c = (struct qemu_glMultiTexCoord3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3iv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3ivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3ivARB( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord3ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3IVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3ivARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3ivARB *c = (struct qemu_glMultiTexCoord3ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3ivARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3ivSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3ivSGIS( GLenum target, GLint * v )
{
    struct qemu_glMultiTexCoord3ivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3IVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3ivSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3ivSGIS *c = (struct qemu_glMultiTexCoord3ivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3ivSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3s
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3s( GLenum target, GLshort s, GLshort t, GLshort r )
{
    struct qemu_glMultiTexCoord3s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3S);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3s(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3s *c = (struct qemu_glMultiTexCoord3s *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3s( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3sARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3sARB( GLenum target, GLshort s, GLshort t, GLshort r )
{
    struct qemu_glMultiTexCoord3sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3SARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3sARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3sARB *c = (struct qemu_glMultiTexCoord3sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3sARB( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3sSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3sSGIS( GLenum target, GLshort s, GLshort t, GLshort r )
{
    struct qemu_glMultiTexCoord3sSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3SSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3sSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3sSGIS *c = (struct qemu_glMultiTexCoord3sSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3sSGIS( c->target, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3sv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3sv( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord3sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3SV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3sv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3sv *c = (struct qemu_glMultiTexCoord3sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3sv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3svARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3svARB( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord3svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3SVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3svARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3svARB *c = (struct qemu_glMultiTexCoord3svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3svARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3svSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3svSGIS( GLenum target, GLshort * v )
{
    struct qemu_glMultiTexCoord3svSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3SVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3svSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3svSGIS *c = (struct qemu_glMultiTexCoord3svSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3svSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord3xOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3xOES( GLenum texture, GLfixed s, GLfixed t, GLfixed r )
{
    struct qemu_glMultiTexCoord3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3XOES);
    call.texture = texture;
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3xOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3xOES *c = (struct qemu_glMultiTexCoord3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3xOES( c->texture, c->s, c->t, c->r ));
}

#endif

struct qemu_glMultiTexCoord3xvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord3xvOES( GLenum texture, const GLfixed *coords )
{
    struct qemu_glMultiTexCoord3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD3XVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord3xvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord3xvOES *c = (struct qemu_glMultiTexCoord3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord3xvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord4bOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4bOES( GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q )
{
    struct qemu_glMultiTexCoord4bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4BOES);
    call.texture = texture;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4bOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4bOES *c = (struct qemu_glMultiTexCoord4bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4bOES( c->texture, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4bvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4bvOES( GLenum texture, const GLbyte *coords )
{
    struct qemu_glMultiTexCoord4bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4BVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4bvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4bvOES *c = (struct qemu_glMultiTexCoord4bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4bvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoord4d
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4d( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
    struct qemu_glMultiTexCoord4d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4D);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4d(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4d *c = (struct qemu_glMultiTexCoord4d *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4d( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4dARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4dARB( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
    struct qemu_glMultiTexCoord4dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4DARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4dARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4dARB *c = (struct qemu_glMultiTexCoord4dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4dARB( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4dSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4dSGIS( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
    struct qemu_glMultiTexCoord4dSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4DSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4dSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4dSGIS *c = (struct qemu_glMultiTexCoord4dSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4dSGIS( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4dv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4dv( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4DV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4dv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4dv *c = (struct qemu_glMultiTexCoord4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4dv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4dvARB( GLenum target, const GLdouble *v )
{
    struct qemu_glMultiTexCoord4dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4DVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4dvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4dvARB *c = (struct qemu_glMultiTexCoord4dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4dvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4dvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4dvSGIS( GLenum target, GLdouble * v )
{
    struct qemu_glMultiTexCoord4dvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4DVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4dvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4dvSGIS *c = (struct qemu_glMultiTexCoord4dvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4dvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4f
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4f( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
    struct qemu_glMultiTexCoord4f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4F);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4f(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4f *c = (struct qemu_glMultiTexCoord4f *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4f( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4fARB
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4fARB( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
    struct qemu_glMultiTexCoord4fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4FARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4fARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4fARB *c = (struct qemu_glMultiTexCoord4fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4fARB( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4fSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    double s;
    double t;
    double r;
    double q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4fSGIS( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
    struct qemu_glMultiTexCoord4fSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4FSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4fSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4fSGIS *c = (struct qemu_glMultiTexCoord4fSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4fSGIS( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4fv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4fv( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4FV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4fv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4fv *c = (struct qemu_glMultiTexCoord4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4fv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4fvARB( GLenum target, const GLfloat *v )
{
    struct qemu_glMultiTexCoord4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4FVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4fvARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4fvARB *c = (struct qemu_glMultiTexCoord4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4fvARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4fvSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4fvSGIS( GLenum target, GLfloat * v )
{
    struct qemu_glMultiTexCoord4fvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4FVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4fvSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4fvSGIS *c = (struct qemu_glMultiTexCoord4fvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4fvSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4hNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4hNV( GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q )
{
    struct qemu_glMultiTexCoord4hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4HNV);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4hNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4hNV *c = (struct qemu_glMultiTexCoord4hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4hNV( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4hvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4hvNV( GLenum target, const GLhalfNV *v )
{
    struct qemu_glMultiTexCoord4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4HVNV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4hvNV(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4hvNV *c = (struct qemu_glMultiTexCoord4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4hvNV( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4i
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4i( GLenum target, GLint s, GLint t, GLint r, GLint q )
{
    struct qemu_glMultiTexCoord4i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4I);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4i(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4i *c = (struct qemu_glMultiTexCoord4i *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4i( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4iARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4iARB( GLenum target, GLint s, GLint t, GLint r, GLint q )
{
    struct qemu_glMultiTexCoord4iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4IARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4iARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4iARB *c = (struct qemu_glMultiTexCoord4iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4iARB( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4iSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4iSGIS( GLenum target, GLint s, GLint t, GLint r, GLint q )
{
    struct qemu_glMultiTexCoord4iSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4ISGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4iSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4iSGIS *c = (struct qemu_glMultiTexCoord4iSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4iSGIS( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4iv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4iv( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord4iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4IV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4iv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4iv *c = (struct qemu_glMultiTexCoord4iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4iv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4ivARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4ivARB( GLenum target, const GLint *v )
{
    struct qemu_glMultiTexCoord4ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4IVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4ivARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4ivARB *c = (struct qemu_glMultiTexCoord4ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4ivARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4ivSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4ivSGIS( GLenum target, GLint * v )
{
    struct qemu_glMultiTexCoord4ivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4IVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4ivSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4ivSGIS *c = (struct qemu_glMultiTexCoord4ivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4ivSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4s
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4s( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q )
{
    struct qemu_glMultiTexCoord4s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4S);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4s(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4s *c = (struct qemu_glMultiTexCoord4s *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4s( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4sARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4sARB( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q )
{
    struct qemu_glMultiTexCoord4sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4SARB);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4sARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4sARB *c = (struct qemu_glMultiTexCoord4sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4sARB( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4sSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4sSGIS( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q )
{
    struct qemu_glMultiTexCoord4sSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4SSGIS);
    call.target = target;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4sSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4sSGIS *c = (struct qemu_glMultiTexCoord4sSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4sSGIS( c->target, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4sv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4sv( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord4sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4SV);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4sv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4sv *c = (struct qemu_glMultiTexCoord4sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4sv( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4svARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4svARB( GLenum target, const GLshort *v )
{
    struct qemu_glMultiTexCoord4svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4SVARB);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4svARB(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4svARB *c = (struct qemu_glMultiTexCoord4svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4svARB( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4svSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4svSGIS( GLenum target, GLshort * v )
{
    struct qemu_glMultiTexCoord4svSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4SVSGIS);
    call.target = target;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4svSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4svSGIS *c = (struct qemu_glMultiTexCoord4svSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4svSGIS( c->target, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMultiTexCoord4xOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4xOES( GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q )
{
    struct qemu_glMultiTexCoord4xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4XOES);
    call.texture = texture;
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4xOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4xOES *c = (struct qemu_glMultiTexCoord4xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4xOES( c->texture, c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glMultiTexCoord4xvOES
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoord4xvOES( GLenum texture, const GLfixed *coords )
{
    struct qemu_glMultiTexCoord4xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORD4XVOES);
    call.texture = texture;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoord4xvOES(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoord4xvOES *c = (struct qemu_glMultiTexCoord4xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoord4xvOES( c->texture, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoordP1ui
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP1ui( GLenum texture, GLenum type, GLuint coords )
{
    struct qemu_glMultiTexCoordP1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP1UI);
    call.texture = texture;
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP1ui(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP1ui *c = (struct qemu_glMultiTexCoordP1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP1ui( c->texture, c->type, c->coords ));
}

#endif

struct qemu_glMultiTexCoordP1uiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP1uiv( GLenum texture, GLenum type, const GLuint *coords )
{
    struct qemu_glMultiTexCoordP1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP1UIV);
    call.texture = texture;
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP1uiv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP1uiv *c = (struct qemu_glMultiTexCoordP1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP1uiv( c->texture, c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoordP2ui
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP2ui( GLenum texture, GLenum type, GLuint coords )
{
    struct qemu_glMultiTexCoordP2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP2UI);
    call.texture = texture;
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP2ui(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP2ui *c = (struct qemu_glMultiTexCoordP2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP2ui( c->texture, c->type, c->coords ));
}

#endif

struct qemu_glMultiTexCoordP2uiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP2uiv( GLenum texture, GLenum type, const GLuint *coords )
{
    struct qemu_glMultiTexCoordP2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP2UIV);
    call.texture = texture;
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP2uiv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP2uiv *c = (struct qemu_glMultiTexCoordP2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP2uiv( c->texture, c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoordP3ui
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP3ui( GLenum texture, GLenum type, GLuint coords )
{
    struct qemu_glMultiTexCoordP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP3UI);
    call.texture = texture;
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP3ui(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP3ui *c = (struct qemu_glMultiTexCoordP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP3ui( c->texture, c->type, c->coords ));
}

#endif

struct qemu_glMultiTexCoordP3uiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP3uiv( GLenum texture, GLenum type, const GLuint *coords )
{
    struct qemu_glMultiTexCoordP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP3UIV);
    call.texture = texture;
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP3uiv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP3uiv *c = (struct qemu_glMultiTexCoordP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP3uiv( c->texture, c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoordP4ui
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP4ui( GLenum texture, GLenum type, GLuint coords )
{
    struct qemu_glMultiTexCoordP4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP4UI);
    call.texture = texture;
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP4ui(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP4ui *c = (struct qemu_glMultiTexCoordP4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP4ui( c->texture, c->type, c->coords ));
}

#endif

struct qemu_glMultiTexCoordP4uiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordP4uiv( GLenum texture, GLenum type, const GLuint *coords )
{
    struct qemu_glMultiTexCoordP4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDP4UIV);
    call.texture = texture;
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordP4uiv(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordP4uiv *c = (struct qemu_glMultiTexCoordP4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordP4uiv( c->texture, c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glMultiTexCoordPointerEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordPointerEXT( GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glMultiTexCoordPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDPOINTEREXT);
    call.texunit = texunit;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordPointerEXT *c = (struct qemu_glMultiTexCoordPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordPointerEXT( c->texunit, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glMultiTexCoordPointerSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexCoordPointerSGIS( GLenum target, GLint size, GLenum type, GLsizei stride, GLvoid * pointer )
{
    struct qemu_glMultiTexCoordPointerSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXCOORDPOINTERSGIS);
    call.target = target;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexCoordPointerSGIS(struct qemu_syscall *call)
{
    struct qemu_glMultiTexCoordPointerSGIS *c = (struct qemu_glMultiTexCoordPointerSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexCoordPointerSGIS( c->target, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glMultiTexEnvfEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexEnvfEXT( GLenum texunit, GLenum target, GLenum pname, GLfloat param )
{
    struct qemu_glMultiTexEnvfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXENVFEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexEnvfEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexEnvfEXT *c = (struct qemu_glMultiTexEnvfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexEnvfEXT( c->texunit, c->target, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexEnvfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexEnvfvEXT( GLenum texunit, GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glMultiTexEnvfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXENVFVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexEnvfvEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexEnvfvEXT *c = (struct qemu_glMultiTexEnvfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexEnvfvEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexEnviEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexEnviEXT( GLenum texunit, GLenum target, GLenum pname, GLint param )
{
    struct qemu_glMultiTexEnviEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXENVIEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexEnviEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexEnviEXT *c = (struct qemu_glMultiTexEnviEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexEnviEXT( c->texunit, c->target, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexEnvivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexEnvivEXT( GLenum texunit, GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glMultiTexEnvivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXENVIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexEnvivEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexEnvivEXT *c = (struct qemu_glMultiTexEnvivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexEnvivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexGendEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGendEXT( GLenum texunit, GLenum coord, GLenum pname, GLdouble param )
{
    struct qemu_glMultiTexGendEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENDEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGendEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGendEXT *c = (struct qemu_glMultiTexGendEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGendEXT( c->texunit, c->coord, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexGendvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGendvEXT( GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params )
{
    struct qemu_glMultiTexGendvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENDVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGendvEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGendvEXT *c = (struct qemu_glMultiTexGendvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGendvEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexGenfEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGenfEXT( GLenum texunit, GLenum coord, GLenum pname, GLfloat param )
{
    struct qemu_glMultiTexGenfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENFEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGenfEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGenfEXT *c = (struct qemu_glMultiTexGenfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGenfEXT( c->texunit, c->coord, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexGenfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGenfvEXT( GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params )
{
    struct qemu_glMultiTexGenfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENFVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGenfvEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGenfvEXT *c = (struct qemu_glMultiTexGenfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGenfvEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexGeniEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGeniEXT( GLenum texunit, GLenum coord, GLenum pname, GLint param )
{
    struct qemu_glMultiTexGeniEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENIEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGeniEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGeniEXT *c = (struct qemu_glMultiTexGeniEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGeniEXT( c->texunit, c->coord, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexGenivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexGenivEXT( GLenum texunit, GLenum coord, GLenum pname, const GLint *params )
{
    struct qemu_glMultiTexGenivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXGENIVEXT);
    call.texunit = texunit;
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexGenivEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexGenivEXT *c = (struct qemu_glMultiTexGenivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexGenivEXT( c->texunit, c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexImage1DEXT( GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexImage1DEXT *c = (struct qemu_glMultiTexImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexImage1DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMultiTexImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexImage2DEXT( GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexImage2DEXT *c = (struct qemu_glMultiTexImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexImage2DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->height, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMultiTexImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexImage3DEXT( GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXIMAGE3DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexImage3DEXT *c = (struct qemu_glMultiTexImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexImage3DEXT( c->texunit, c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMultiTexParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameterIivEXT( GLenum texunit, GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glMultiTexParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERIIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameterIivEXT *c = (struct qemu_glMultiTexParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameterIivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameterIuivEXT( GLenum texunit, GLenum target, GLenum pname, const GLuint *params )
{
    struct qemu_glMultiTexParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERIUIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameterIuivEXT *c = (struct qemu_glMultiTexParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameterIuivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexParameterfEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameterfEXT( GLenum texunit, GLenum target, GLenum pname, GLfloat param )
{
    struct qemu_glMultiTexParameterfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERFEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameterfEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameterfEXT *c = (struct qemu_glMultiTexParameterfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameterfEXT( c->texunit, c->target, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameterfvEXT( GLenum texunit, GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glMultiTexParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERFVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameterfvEXT *c = (struct qemu_glMultiTexParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameterfvEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexParameteriEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameteriEXT( GLenum texunit, GLenum target, GLenum pname, GLint param )
{
    struct qemu_glMultiTexParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERIEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameteriEXT *c = (struct qemu_glMultiTexParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameteriEXT( c->texunit, c->target, c->pname, c->param ));
}

#endif

struct qemu_glMultiTexParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexParameterivEXT( GLenum texunit, GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glMultiTexParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXPARAMETERIVEXT);
    call.texunit = texunit;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexParameterivEXT *c = (struct qemu_glMultiTexParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexParameterivEXT( c->texunit, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMultiTexRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexRenderbufferEXT( GLenum texunit, GLenum target, GLuint renderbuffer )
{
    struct qemu_glMultiTexRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXRENDERBUFFEREXT);
    call.texunit = texunit;
    call.target = target;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexRenderbufferEXT *c = (struct qemu_glMultiTexRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexRenderbufferEXT( c->texunit, c->target, c->renderbuffer ));
}

#endif

struct qemu_glMultiTexSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexSubImage1DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXSUBIMAGE1DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexSubImage1DEXT *c = (struct qemu_glMultiTexSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexSubImage1DEXT( c->texunit, c->target, c->level, c->xoffset, c->width, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMultiTexSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexSubImage2DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXSUBIMAGE2DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexSubImage2DEXT *c = (struct qemu_glMultiTexSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexSubImage2DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMultiTexSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texunit;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMultiTexSubImage3DEXT( GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glMultiTexSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTITEXSUBIMAGE3DEXT);
    call.texunit = texunit;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glMultiTexSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glMultiTexSubImage3DEXT *c = (struct qemu_glMultiTexSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glMultiTexSubImage3DEXT( c->texunit, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glMulticastBarrierNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastBarrierNV(void)
{
    struct qemu_glMulticastBarrierNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTBARRIERNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastBarrierNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastBarrierNV *c = (struct qemu_glMulticastBarrierNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastBarrierNV());
}

#endif

struct qemu_glMulticastBlitFramebufferNV
{
    struct qemu_syscall super;
    uint64_t srcGpu;
    uint64_t dstGpu;
    uint64_t srcX0;
    uint64_t srcY0;
    uint64_t srcX1;
    uint64_t srcY1;
    uint64_t dstX0;
    uint64_t dstY0;
    uint64_t dstX1;
    uint64_t dstY1;
    uint64_t mask;
    uint64_t filter;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastBlitFramebufferNV( GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter )
{
    struct qemu_glMulticastBlitFramebufferNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTBLITFRAMEBUFFERNV);
    call.srcGpu = srcGpu;
    call.dstGpu = dstGpu;
    call.srcX0 = srcX0;
    call.srcY0 = srcY0;
    call.srcX1 = srcX1;
    call.srcY1 = srcY1;
    call.dstX0 = dstX0;
    call.dstY0 = dstY0;
    call.dstX1 = dstX1;
    call.dstY1 = dstY1;
    call.mask = mask;
    call.filter = filter;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastBlitFramebufferNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastBlitFramebufferNV *c = (struct qemu_glMulticastBlitFramebufferNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastBlitFramebufferNV( c->srcGpu, c->dstGpu, c->srcX0, c->srcY0, c->srcX1, c->srcY1, c->dstX0, c->dstY0, c->dstX1, c->dstY1, c->mask, c->filter ));
}

#endif

struct qemu_glMulticastBufferSubDataNV
{
    struct qemu_syscall super;
    uint64_t gpuMask;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastBufferSubDataNV( GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data )
{
    struct qemu_glMulticastBufferSubDataNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTBUFFERSUBDATANV);
    call.gpuMask = gpuMask;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastBufferSubDataNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastBufferSubDataNV *c = (struct qemu_glMulticastBufferSubDataNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastBufferSubDataNV( c->gpuMask, c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glMulticastCopyBufferSubDataNV
{
    struct qemu_syscall super;
    uint64_t readGpu;
    uint64_t writeGpuMask;
    uint64_t readBuffer;
    uint64_t writeBuffer;
    uint64_t readOffset;
    uint64_t writeOffset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastCopyBufferSubDataNV( GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size )
{
    struct qemu_glMulticastCopyBufferSubDataNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTCOPYBUFFERSUBDATANV);
    call.readGpu = readGpu;
    call.writeGpuMask = writeGpuMask;
    call.readBuffer = readBuffer;
    call.writeBuffer = writeBuffer;
    call.readOffset = readOffset;
    call.writeOffset = writeOffset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastCopyBufferSubDataNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastCopyBufferSubDataNV *c = (struct qemu_glMulticastCopyBufferSubDataNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastCopyBufferSubDataNV( c->readGpu, c->writeGpuMask, c->readBuffer, c->writeBuffer, c->readOffset, c->writeOffset, c->size ));
}

#endif

struct qemu_glMulticastCopyImageSubDataNV
{
    struct qemu_syscall super;
    uint64_t srcGpu;
    uint64_t dstGpuMask;
    uint64_t srcName;
    uint64_t srcTarget;
    uint64_t srcLevel;
    uint64_t srcX;
    uint64_t srcY;
    uint64_t srcZ;
    uint64_t dstName;
    uint64_t dstTarget;
    uint64_t dstLevel;
    uint64_t dstX;
    uint64_t dstY;
    uint64_t dstZ;
    uint64_t srcWidth;
    uint64_t srcHeight;
    uint64_t srcDepth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastCopyImageSubDataNV( GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth )
{
    struct qemu_glMulticastCopyImageSubDataNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTCOPYIMAGESUBDATANV);
    call.srcGpu = srcGpu;
    call.dstGpuMask = dstGpuMask;
    call.srcName = srcName;
    call.srcTarget = srcTarget;
    call.srcLevel = srcLevel;
    call.srcX = srcX;
    call.srcY = srcY;
    call.srcZ = srcZ;
    call.dstName = dstName;
    call.dstTarget = dstTarget;
    call.dstLevel = dstLevel;
    call.dstX = dstX;
    call.dstY = dstY;
    call.dstZ = dstZ;
    call.srcWidth = srcWidth;
    call.srcHeight = srcHeight;
    call.srcDepth = srcDepth;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastCopyImageSubDataNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastCopyImageSubDataNV *c = (struct qemu_glMulticastCopyImageSubDataNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastCopyImageSubDataNV( c->srcGpu, c->dstGpuMask, c->srcName, c->srcTarget, c->srcLevel, c->srcX, c->srcY, c->srcZ, c->dstName, c->dstTarget, c->dstLevel, c->dstX, c->dstY, c->dstZ, c->srcWidth, c->srcHeight, c->srcDepth ));
}

#endif

struct qemu_glMulticastFramebufferSampleLocationsfvNV
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t framebuffer;
    uint64_t start;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastFramebufferSampleLocationsfvNV( GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v )
{
    struct qemu_glMulticastFramebufferSampleLocationsfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNV);
    call.gpu = gpu;
    call.framebuffer = framebuffer;
    call.start = start;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastFramebufferSampleLocationsfvNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastFramebufferSampleLocationsfvNV *c = (struct qemu_glMulticastFramebufferSampleLocationsfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastFramebufferSampleLocationsfvNV( c->gpu, c->framebuffer, c->start, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMulticastGetQueryObjecti64vNV
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastGetQueryObjecti64vNV( GLuint gpu, GLuint id, GLenum pname, GLint64 *params )
{
    struct qemu_glMulticastGetQueryObjecti64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTGETQUERYOBJECTI64VNV);
    call.gpu = gpu;
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastGetQueryObjecti64vNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastGetQueryObjecti64vNV *c = (struct qemu_glMulticastGetQueryObjecti64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastGetQueryObjecti64vNV( c->gpu, c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMulticastGetQueryObjectivNV
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastGetQueryObjectivNV( GLuint gpu, GLuint id, GLenum pname, GLint *params )
{
    struct qemu_glMulticastGetQueryObjectivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTGETQUERYOBJECTIVNV);
    call.gpu = gpu;
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastGetQueryObjectivNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastGetQueryObjectivNV *c = (struct qemu_glMulticastGetQueryObjectivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastGetQueryObjectivNV( c->gpu, c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMulticastGetQueryObjectui64vNV
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastGetQueryObjectui64vNV( GLuint gpu, GLuint id, GLenum pname, GLuint64 *params )
{
    struct qemu_glMulticastGetQueryObjectui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTGETQUERYOBJECTUI64VNV);
    call.gpu = gpu;
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastGetQueryObjectui64vNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastGetQueryObjectui64vNV *c = (struct qemu_glMulticastGetQueryObjectui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastGetQueryObjectui64vNV( c->gpu, c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMulticastGetQueryObjectuivNV
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t id;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastGetQueryObjectuivNV( GLuint gpu, GLuint id, GLenum pname, GLuint *params )
{
    struct qemu_glMulticastGetQueryObjectuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTGETQUERYOBJECTUIVNV);
    call.gpu = gpu;
    call.id = id;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastGetQueryObjectuivNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastGetQueryObjectuivNV *c = (struct qemu_glMulticastGetQueryObjectuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastGetQueryObjectuivNV( c->gpu, c->id, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glMulticastScissorArrayvNVX
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastScissorArrayvNVX( GLuint gpu, GLuint first, GLsizei count, const GLint *v )
{
    struct qemu_glMulticastScissorArrayvNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTSCISSORARRAYVNVX);
    call.gpu = gpu;
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastScissorArrayvNVX(struct qemu_syscall *call)
{
    struct qemu_glMulticastScissorArrayvNVX *c = (struct qemu_glMulticastScissorArrayvNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastScissorArrayvNVX( c->gpu, c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMulticastViewportArrayvNVX
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastViewportArrayvNVX( GLuint gpu, GLuint first, GLsizei count, const GLfloat *v )
{
    struct qemu_glMulticastViewportArrayvNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTVIEWPORTARRAYVNVX);
    call.gpu = gpu;
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastViewportArrayvNVX(struct qemu_syscall *call)
{
    struct qemu_glMulticastViewportArrayvNVX *c = (struct qemu_glMulticastViewportArrayvNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastViewportArrayvNVX( c->gpu, c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glMulticastViewportPositionWScaleNVX
{
    struct qemu_syscall super;
    uint64_t gpu;
    uint64_t index;
    double xcoeff;
    double ycoeff;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastViewportPositionWScaleNVX( GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff )
{
    struct qemu_glMulticastViewportPositionWScaleNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTVIEWPORTPOSITIONWSCALENVX);
    call.gpu = gpu;
    call.index = index;
    call.xcoeff = xcoeff;
    call.ycoeff = ycoeff;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastViewportPositionWScaleNVX(struct qemu_syscall *call)
{
    struct qemu_glMulticastViewportPositionWScaleNVX *c = (struct qemu_glMulticastViewportPositionWScaleNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastViewportPositionWScaleNVX( c->gpu, c->index, c->xcoeff, c->ycoeff ));
}

#endif

struct qemu_glMulticastWaitSyncNV
{
    struct qemu_syscall super;
    uint64_t signalGpu;
    uint64_t waitGpuMask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glMulticastWaitSyncNV( GLuint signalGpu, GLbitfield waitGpuMask )
{
    struct qemu_glMulticastWaitSyncNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLMULTICASTWAITSYNCNV);
    call.signalGpu = signalGpu;
    call.waitGpuMask = waitGpuMask;

    qemu_syscall(&call.super);
}

#else

void qemu_glMulticastWaitSyncNV(struct qemu_syscall *call)
{
    struct qemu_glMulticastWaitSyncNV *c = (struct qemu_glMulticastWaitSyncNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glMulticastWaitSyncNV( c->signalGpu, c->waitGpuMask ));
}

#endif

struct qemu_glNamedBufferAttachMemoryNV
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferAttachMemoryNV( GLuint buffer, GLuint memory, GLuint64 offset )
{
    struct qemu_glNamedBufferAttachMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERATTACHMEMORYNV);
    call.buffer = buffer;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferAttachMemoryNV(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferAttachMemoryNV *c = (struct qemu_glNamedBufferAttachMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferAttachMemoryNV( c->buffer, c->memory, c->offset ));
}

#endif

struct qemu_glNamedBufferData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t size;
    uint64_t data;
    uint64_t usage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferData( GLuint buffer, GLsizeiptr size, const void *data, GLenum usage )
{
    struct qemu_glNamedBufferData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERDATA);
    call.buffer = buffer;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.usage = usage;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferData(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferData *c = (struct qemu_glNamedBufferData *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferData( c->buffer, c->size, QEMU_G2H(c->data), c->usage ));
}

#endif

struct qemu_glNamedBufferDataEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t size;
    uint64_t data;
    uint64_t usage;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferDataEXT( GLuint buffer, GLsizeiptr size, const void *data, GLenum usage )
{
    struct qemu_glNamedBufferDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERDATAEXT);
    call.buffer = buffer;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.usage = usage;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferDataEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferDataEXT *c = (struct qemu_glNamedBufferDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferDataEXT( c->buffer, c->size, QEMU_G2H(c->data), c->usage ));
}

#endif

struct qemu_glNamedBufferPageCommitmentARB
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t commit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferPageCommitmentARB( GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit )
{
    struct qemu_glNamedBufferPageCommitmentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERPAGECOMMITMENTARB);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.commit = commit;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferPageCommitmentARB(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferPageCommitmentARB *c = (struct qemu_glNamedBufferPageCommitmentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferPageCommitmentARB( c->buffer, c->offset, c->size, c->commit ));
}

#endif

struct qemu_glNamedBufferPageCommitmentEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t commit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferPageCommitmentEXT( GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit )
{
    struct qemu_glNamedBufferPageCommitmentEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERPAGECOMMITMENTEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.commit = commit;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferPageCommitmentEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferPageCommitmentEXT *c = (struct qemu_glNamedBufferPageCommitmentEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferPageCommitmentEXT( c->buffer, c->offset, c->size, c->commit ));
}

#endif

struct qemu_glNamedBufferStorage
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t size;
    uint64_t data;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferStorage( GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags )
{
    struct qemu_glNamedBufferStorage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSTORAGE);
    call.buffer = buffer;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferStorage(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferStorage *c = (struct qemu_glNamedBufferStorage *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferStorage( c->buffer, c->size, QEMU_G2H(c->data), c->flags ));
}

#endif

struct qemu_glNamedBufferStorageEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t size;
    uint64_t data;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferStorageEXT( GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags )
{
    struct qemu_glNamedBufferStorageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSTORAGEEXT);
    call.buffer = buffer;
    call.size = size;
    call.data = (ULONG_PTR)data;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferStorageEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferStorageEXT *c = (struct qemu_glNamedBufferStorageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferStorageEXT( c->buffer, c->size, QEMU_G2H(c->data), c->flags ));
}

#endif

struct qemu_glNamedBufferStorageExternalEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t clientBuffer;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferStorageExternalEXT( GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags )
{
    struct qemu_glNamedBufferStorageExternalEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSTORAGEEXTERNALEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.clientBuffer = (ULONG_PTR)clientBuffer;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferStorageExternalEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferStorageExternalEXT *c = (struct qemu_glNamedBufferStorageExternalEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferStorageExternalEXT( c->buffer, c->offset, c->size, QEMU_G2H(c->clientBuffer), c->flags ));
}

#endif

struct qemu_glNamedBufferStorageMemEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t size;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferStorageMemEXT( GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset )
{
    struct qemu_glNamedBufferStorageMemEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSTORAGEMEMEXT);
    call.buffer = buffer;
    call.size = size;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferStorageMemEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferStorageMemEXT *c = (struct qemu_glNamedBufferStorageMemEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferStorageMemEXT( c->buffer, c->size, c->memory, c->offset ));
}

#endif

struct qemu_glNamedBufferSubData
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferSubData( GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data )
{
    struct qemu_glNamedBufferSubData call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSUBDATA);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferSubData(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferSubData *c = (struct qemu_glNamedBufferSubData *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferSubData( c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glNamedBufferSubDataEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedBufferSubDataEXT( GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data )
{
    struct qemu_glNamedBufferSubDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDBUFFERSUBDATAEXT);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedBufferSubDataEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedBufferSubDataEXT *c = (struct qemu_glNamedBufferSubDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedBufferSubDataEXT( c->buffer, c->offset, c->size, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glNamedCopyBufferSubDataEXT
{
    struct qemu_syscall super;
    uint64_t readBuffer;
    uint64_t writeBuffer;
    uint64_t readOffset;
    uint64_t writeOffset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedCopyBufferSubDataEXT( GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size )
{
    struct qemu_glNamedCopyBufferSubDataEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDCOPYBUFFERSUBDATAEXT);
    call.readBuffer = readBuffer;
    call.writeBuffer = writeBuffer;
    call.readOffset = readOffset;
    call.writeOffset = writeOffset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedCopyBufferSubDataEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedCopyBufferSubDataEXT *c = (struct qemu_glNamedCopyBufferSubDataEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedCopyBufferSubDataEXT( c->readBuffer, c->writeBuffer, c->readOffset, c->writeOffset, c->size ));
}

#endif

struct qemu_glNamedFramebufferDrawBuffer
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t buf;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferDrawBuffer( GLuint framebuffer, GLenum buf )
{
    struct qemu_glNamedFramebufferDrawBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERDRAWBUFFER);
    call.framebuffer = framebuffer;
    call.buf = buf;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferDrawBuffer(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferDrawBuffer *c = (struct qemu_glNamedFramebufferDrawBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferDrawBuffer( c->framebuffer, c->buf ));
}

#endif

struct qemu_glNamedFramebufferDrawBuffers
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t n;
    uint64_t bufs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferDrawBuffers( GLuint framebuffer, GLsizei n, const GLenum *bufs )
{
    struct qemu_glNamedFramebufferDrawBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERDRAWBUFFERS);
    call.framebuffer = framebuffer;
    call.n = n;
    call.bufs = (ULONG_PTR)bufs;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferDrawBuffers(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferDrawBuffers *c = (struct qemu_glNamedFramebufferDrawBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferDrawBuffers( c->framebuffer, c->n, QEMU_G2H(c->bufs) ));
}

#endif

struct qemu_glNamedFramebufferParameteri
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferParameteri( GLuint framebuffer, GLenum pname, GLint param )
{
    struct qemu_glNamedFramebufferParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERPARAMETERI);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferParameteri(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferParameteri *c = (struct qemu_glNamedFramebufferParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferParameteri( c->framebuffer, c->pname, c->param ));
}

#endif

struct qemu_glNamedFramebufferParameteriEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferParameteriEXT( GLuint framebuffer, GLenum pname, GLint param )
{
    struct qemu_glNamedFramebufferParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERPARAMETERIEXT);
    call.framebuffer = framebuffer;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferParameteriEXT *c = (struct qemu_glNamedFramebufferParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferParameteriEXT( c->framebuffer, c->pname, c->param ));
}

#endif

struct qemu_glNamedFramebufferReadBuffer
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t src;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferReadBuffer( GLuint framebuffer, GLenum src )
{
    struct qemu_glNamedFramebufferReadBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERREADBUFFER);
    call.framebuffer = framebuffer;
    call.src = src;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferReadBuffer(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferReadBuffer *c = (struct qemu_glNamedFramebufferReadBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferReadBuffer( c->framebuffer, c->src ));
}

#endif

struct qemu_glNamedFramebufferRenderbuffer
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t renderbuffertarget;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferRenderbuffer( GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer )
{
    struct qemu_glNamedFramebufferRenderbuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERRENDERBUFFER);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.renderbuffertarget = renderbuffertarget;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferRenderbuffer(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferRenderbuffer *c = (struct qemu_glNamedFramebufferRenderbuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferRenderbuffer( c->framebuffer, c->attachment, c->renderbuffertarget, c->renderbuffer ));
}

#endif

struct qemu_glNamedFramebufferRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t renderbuffertarget;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferRenderbufferEXT( GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer )
{
    struct qemu_glNamedFramebufferRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.renderbuffertarget = renderbuffertarget;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferRenderbufferEXT *c = (struct qemu_glNamedFramebufferRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferRenderbufferEXT( c->framebuffer, c->attachment, c->renderbuffertarget, c->renderbuffer ));
}

#endif

struct qemu_glNamedFramebufferSampleLocationsfvARB
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t start;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferSampleLocationsfvARB( GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v )
{
    struct qemu_glNamedFramebufferSampleLocationsfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARB);
    call.framebuffer = framebuffer;
    call.start = start;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferSampleLocationsfvARB(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferSampleLocationsfvARB *c = (struct qemu_glNamedFramebufferSampleLocationsfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferSampleLocationsfvARB( c->framebuffer, c->start, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glNamedFramebufferSampleLocationsfvNV
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t start;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferSampleLocationsfvNV( GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v )
{
    struct qemu_glNamedFramebufferSampleLocationsfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNV);
    call.framebuffer = framebuffer;
    call.start = start;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferSampleLocationsfvNV(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferSampleLocationsfvNV *c = (struct qemu_glNamedFramebufferSampleLocationsfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferSampleLocationsfvNV( c->framebuffer, c->start, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glNamedFramebufferSamplePositionsfvAMD
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t numsamples;
    uint64_t pixelindex;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferSamplePositionsfvAMD( GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values )
{
    struct qemu_glNamedFramebufferSamplePositionsfvAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMD);
    call.framebuffer = framebuffer;
    call.numsamples = numsamples;
    call.pixelindex = pixelindex;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferSamplePositionsfvAMD(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferSamplePositionsfvAMD *c = (struct qemu_glNamedFramebufferSamplePositionsfvAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferSamplePositionsfvAMD( c->framebuffer, c->numsamples, c->pixelindex, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glNamedFramebufferTexture
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTexture( GLuint framebuffer, GLenum attachment, GLuint texture, GLint level )
{
    struct qemu_glNamedFramebufferTexture call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURE);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTexture(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTexture *c = (struct qemu_glNamedFramebufferTexture *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTexture( c->framebuffer, c->attachment, c->texture, c->level ));
}

#endif

struct qemu_glNamedFramebufferTexture1DEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTexture1DEXT( GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glNamedFramebufferTexture1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURE1DEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTexture1DEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTexture1DEXT *c = (struct qemu_glNamedFramebufferTexture1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTexture1DEXT( c->framebuffer, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glNamedFramebufferTexture2DEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTexture2DEXT( GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
{
    struct qemu_glNamedFramebufferTexture2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURE2DEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTexture2DEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTexture2DEXT *c = (struct qemu_glNamedFramebufferTexture2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTexture2DEXT( c->framebuffer, c->attachment, c->textarget, c->texture, c->level ));
}

#endif

struct qemu_glNamedFramebufferTexture3DEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t textarget;
    uint64_t texture;
    uint64_t level;
    uint64_t zoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTexture3DEXT( GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset )
{
    struct qemu_glNamedFramebufferTexture3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURE3DEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.textarget = textarget;
    call.texture = texture;
    call.level = level;
    call.zoffset = zoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTexture3DEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTexture3DEXT *c = (struct qemu_glNamedFramebufferTexture3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTexture3DEXT( c->framebuffer, c->attachment, c->textarget, c->texture, c->level, c->zoffset ));
}

#endif

struct qemu_glNamedFramebufferTextureEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTextureEXT( GLuint framebuffer, GLenum attachment, GLuint texture, GLint level )
{
    struct qemu_glNamedFramebufferTextureEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTUREEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTextureEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTextureEXT *c = (struct qemu_glNamedFramebufferTextureEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTextureEXT( c->framebuffer, c->attachment, c->texture, c->level ));
}

#endif

struct qemu_glNamedFramebufferTextureFaceEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t face;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTextureFaceEXT( GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face )
{
    struct qemu_glNamedFramebufferTextureFaceEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.face = face;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTextureFaceEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTextureFaceEXT *c = (struct qemu_glNamedFramebufferTextureFaceEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTextureFaceEXT( c->framebuffer, c->attachment, c->texture, c->level, c->face ));
}

#endif

struct qemu_glNamedFramebufferTextureLayer
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t layer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTextureLayer( GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer )
{
    struct qemu_glNamedFramebufferTextureLayer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURELAYER);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.layer = layer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTextureLayer(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTextureLayer *c = (struct qemu_glNamedFramebufferTextureLayer *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTextureLayer( c->framebuffer, c->attachment, c->texture, c->level, c->layer ));
}

#endif

struct qemu_glNamedFramebufferTextureLayerEXT
{
    struct qemu_syscall super;
    uint64_t framebuffer;
    uint64_t attachment;
    uint64_t texture;
    uint64_t level;
    uint64_t layer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedFramebufferTextureLayerEXT( GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer )
{
    struct qemu_glNamedFramebufferTextureLayerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT);
    call.framebuffer = framebuffer;
    call.attachment = attachment;
    call.texture = texture;
    call.level = level;
    call.layer = layer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedFramebufferTextureLayerEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedFramebufferTextureLayerEXT *c = (struct qemu_glNamedFramebufferTextureLayerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedFramebufferTextureLayerEXT( c->framebuffer, c->attachment, c->texture, c->level, c->layer ));
}

#endif

struct qemu_glNamedProgramLocalParameter4dEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameter4dEXT( GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glNamedProgramLocalParameter4dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETER4DEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameter4dEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameter4dEXT *c = (struct qemu_glNamedProgramLocalParameter4dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameter4dEXT( c->program, c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glNamedProgramLocalParameter4dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameter4dvEXT( GLuint program, GLenum target, GLuint index, const GLdouble *params )
{
    struct qemu_glNamedProgramLocalParameter4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameter4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameter4dvEXT *c = (struct qemu_glNamedProgramLocalParameter4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameter4dvEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParameter4fEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameter4fEXT( GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glNamedProgramLocalParameter4fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETER4FEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameter4fEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameter4fEXT *c = (struct qemu_glNamedProgramLocalParameter4fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameter4fEXT( c->program, c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glNamedProgramLocalParameter4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameter4fvEXT( GLuint program, GLenum target, GLuint index, const GLfloat *params )
{
    struct qemu_glNamedProgramLocalParameter4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameter4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameter4fvEXT *c = (struct qemu_glNamedProgramLocalParameter4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameter4fvEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParameterI4iEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameterI4iEXT( GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glNamedProgramLocalParameterI4iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameterI4iEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameterI4iEXT *c = (struct qemu_glNamedProgramLocalParameterI4iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameterI4iEXT( c->program, c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glNamedProgramLocalParameterI4ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameterI4ivEXT( GLuint program, GLenum target, GLuint index, const GLint *params )
{
    struct qemu_glNamedProgramLocalParameterI4ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameterI4ivEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameterI4ivEXT *c = (struct qemu_glNamedProgramLocalParameterI4ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameterI4ivEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParameterI4uiEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameterI4uiEXT( GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
{
    struct qemu_glNamedProgramLocalParameterI4uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameterI4uiEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameterI4uiEXT *c = (struct qemu_glNamedProgramLocalParameterI4uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameterI4uiEXT( c->program, c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glNamedProgramLocalParameterI4uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameterI4uivEXT( GLuint program, GLenum target, GLuint index, const GLuint *params )
{
    struct qemu_glNamedProgramLocalParameterI4uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameterI4uivEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameterI4uivEXT *c = (struct qemu_glNamedProgramLocalParameterI4uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameterI4uivEXT( c->program, c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParameters4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParameters4fvEXT( GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params )
{
    struct qemu_glNamedProgramLocalParameters4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParameters4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParameters4fvEXT *c = (struct qemu_glNamedProgramLocalParameters4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParameters4fvEXT( c->program, c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParametersI4ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParametersI4ivEXT( GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params )
{
    struct qemu_glNamedProgramLocalParametersI4ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParametersI4ivEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParametersI4ivEXT *c = (struct qemu_glNamedProgramLocalParametersI4ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParametersI4ivEXT( c->program, c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramLocalParametersI4uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramLocalParametersI4uivEXT( GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params )
{
    struct qemu_glNamedProgramLocalParametersI4uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT);
    call.program = program;
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramLocalParametersI4uivEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramLocalParametersI4uivEXT *c = (struct qemu_glNamedProgramLocalParametersI4uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramLocalParametersI4uivEXT( c->program, c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glNamedProgramStringEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t target;
    uint64_t format;
    uint64_t len;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedProgramStringEXT( GLuint program, GLenum target, GLenum format, GLsizei len, const void *string )
{
    struct qemu_glNamedProgramStringEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDPROGRAMSTRINGEXT);
    call.program = program;
    call.target = target;
    call.format = format;
    call.len = len;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedProgramStringEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedProgramStringEXT *c = (struct qemu_glNamedProgramStringEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedProgramStringEXT( c->program, c->target, c->format, c->len, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glNamedRenderbufferStorage
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorage( GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGE);
    call.renderbuffer = renderbuffer;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorage(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorage *c = (struct qemu_glNamedRenderbufferStorage *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorage( c->renderbuffer, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedRenderbufferStorageEXT
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorageEXT( GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGEEXT);
    call.renderbuffer = renderbuffer;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorageEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorageEXT *c = (struct qemu_glNamedRenderbufferStorageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorageEXT( c->renderbuffer, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedRenderbufferStorageMultisample
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorageMultisample( GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorageMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLE);
    call.renderbuffer = renderbuffer;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorageMultisample(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorageMultisample *c = (struct qemu_glNamedRenderbufferStorageMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorageMultisample( c->renderbuffer, c->samples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedRenderbufferStorageMultisampleAdvancedAMD
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t samples;
    uint64_t storageSamples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorageMultisampleAdvancedAMD( GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorageMultisampleAdvancedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMD);
    call.renderbuffer = renderbuffer;
    call.samples = samples;
    call.storageSamples = storageSamples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorageMultisampleAdvancedAMD(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorageMultisampleAdvancedAMD *c = (struct qemu_glNamedRenderbufferStorageMultisampleAdvancedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorageMultisampleAdvancedAMD( c->renderbuffer, c->samples, c->storageSamples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedRenderbufferStorageMultisampleCoverageEXT
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorageMultisampleCoverageEXT( GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorageMultisampleCoverageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT);
    call.renderbuffer = renderbuffer;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorageMultisampleCoverageEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorageMultisampleCoverageEXT *c = (struct qemu_glNamedRenderbufferStorageMultisampleCoverageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorageMultisampleCoverageEXT( c->renderbuffer, c->coverageSamples, c->colorSamples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedRenderbufferStorageMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t renderbuffer;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedRenderbufferStorageMultisampleEXT( GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glNamedRenderbufferStorageMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT);
    call.renderbuffer = renderbuffer;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedRenderbufferStorageMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glNamedRenderbufferStorageMultisampleEXT *c = (struct qemu_glNamedRenderbufferStorageMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedRenderbufferStorageMultisampleEXT( c->renderbuffer, c->samples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glNamedStringARB
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t namelen;
    uint64_t name;
    uint64_t stringlen;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNamedStringARB( GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string )
{
    struct qemu_glNamedStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNAMEDSTRINGARB);
    call.type = type;
    call.namelen = namelen;
    call.name = (ULONG_PTR)name;
    call.stringlen = stringlen;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glNamedStringARB(struct qemu_syscall *call)
{
    struct qemu_glNamedStringARB *c = (struct qemu_glNamedStringARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glNamedStringARB( c->type, c->namelen, QEMU_G2H(c->name), c->stringlen, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glNewBufferRegion
{
    struct qemu_syscall super;
    uint64_t type;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glNewBufferRegion( GLenum type )
{
    struct qemu_glNewBufferRegion call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNEWBUFFERREGION);
    call.type = type;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glNewBufferRegion(struct qemu_syscall *call)
{
    struct qemu_glNewBufferRegion *c = (struct qemu_glNewBufferRegion *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glNewBufferRegion( c->type ));
}

#endif

struct qemu_glNewObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t pointer;
    uint64_t usage;
};

#ifdef QEMU_DLL_GUEST

GLuint WINAPI glNewObjectBufferATI( GLsizei size, const void *pointer, GLenum usage )
{
    struct qemu_glNewObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNEWOBJECTBUFFERATI);
    call.size = size;
    call.pointer = (ULONG_PTR)pointer;
    call.usage = usage;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glNewObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glNewObjectBufferATI *c = (struct qemu_glNewObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glNewObjectBufferATI( c->size, QEMU_G2H(c->pointer), c->usage ));
}

#endif

struct qemu_glNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3fVertex3fSUN( GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3FVERTEX3FSUN);
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glNormal3fVertex3fSUN *c = (struct qemu_glNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3fVertex3fSUN( c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3fVertex3fvSUN( const GLfloat *n, const GLfloat *v )
{
    struct qemu_glNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3FVERTEX3FVSUN);
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glNormal3fVertex3fvSUN *c = (struct qemu_glNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3fVertex3fvSUN( QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glNormal3hNV
{
    struct qemu_syscall super;
    uint64_t nx;
    uint64_t ny;
    uint64_t nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3hNV( GLhalfNV nx, GLhalfNV ny, GLhalfNV nz )
{
    struct qemu_glNormal3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3HNV);
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3hNV(struct qemu_syscall *call)
{
    struct qemu_glNormal3hNV *c = (struct qemu_glNormal3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3hNV( c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormal3hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3hvNV( const GLhalfNV *v )
{
    struct qemu_glNormal3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3hvNV(struct qemu_syscall *call)
{
    struct qemu_glNormal3hvNV *c = (struct qemu_glNormal3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glNormal3xOES
{
    struct qemu_syscall super;
    uint64_t nx;
    uint64_t ny;
    uint64_t nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3xOES( GLfixed nx, GLfixed ny, GLfixed nz )
{
    struct qemu_glNormal3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3XOES);
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3xOES(struct qemu_syscall *call)
{
    struct qemu_glNormal3xOES *c = (struct qemu_glNormal3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3xOES( c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormal3xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormal3xvOES( const GLfixed *coords )
{
    struct qemu_glNormal3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMAL3XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormal3xvOES(struct qemu_syscall *call)
{
    struct qemu_glNormal3xvOES *c = (struct qemu_glNormal3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormal3xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalFormatNV
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalFormatNV( GLenum type, GLsizei stride )
{
    struct qemu_glNormalFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALFORMATNV);
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalFormatNV(struct qemu_syscall *call)
{
    struct qemu_glNormalFormatNV *c = (struct qemu_glNormalFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalFormatNV( c->type, c->stride ));
}

#endif

struct qemu_glNormalP3ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalP3ui( GLenum type, GLuint coords )
{
    struct qemu_glNormalP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALP3UI);
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalP3ui(struct qemu_syscall *call)
{
    struct qemu_glNormalP3ui *c = (struct qemu_glNormalP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalP3ui( c->type, c->coords ));
}

#endif

struct qemu_glNormalP3uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalP3uiv( GLenum type, const GLuint *coords )
{
    struct qemu_glNormalP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALP3UIV);
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalP3uiv(struct qemu_syscall *call)
{
    struct qemu_glNormalP3uiv *c = (struct qemu_glNormalP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalP3uiv( c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalPointerEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalPointerEXT( GLenum type, GLsizei stride, GLsizei count, const void *pointer )
{
    struct qemu_glNormalPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALPOINTEREXT);
    call.type = type;
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glNormalPointerEXT *c = (struct qemu_glNormalPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalPointerEXT( c->type, c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glNormalPointerListIBM
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalPointerListIBM( GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glNormalPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALPOINTERLISTIBM);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glNormalPointerListIBM *c = (struct qemu_glNormalPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalPointerListIBM( c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glNormalPointervINTEL
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalPointervINTEL( GLenum type, const void **pointer )
{
    struct qemu_glNormalPointervINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALPOINTERVINTEL);
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalPointervINTEL(struct qemu_syscall *call)
{
    struct qemu_glNormalPointervINTEL *c = (struct qemu_glNormalPointervINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalPointervINTEL( c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glNormalStream3bATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t nx;
    uint64_t ny;
    uint64_t nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3bATI( GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz )
{
    struct qemu_glNormalStream3bATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3BATI);
    call.stream = stream;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3bATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3bATI *c = (struct qemu_glNormalStream3bATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3bATI( c->stream, c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormalStream3bvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3bvATI( GLenum stream, const GLbyte *coords )
{
    struct qemu_glNormalStream3bvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3BVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3bvATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3bvATI *c = (struct qemu_glNormalStream3bvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3bvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalStream3dATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double nx;
    double ny;
    double nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3dATI( GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz )
{
    struct qemu_glNormalStream3dATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3DATI);
    call.stream = stream;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3dATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3dATI *c = (struct qemu_glNormalStream3dATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3dATI( c->stream, c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormalStream3dvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3dvATI( GLenum stream, const GLdouble *coords )
{
    struct qemu_glNormalStream3dvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3DVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3dvATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3dvATI *c = (struct qemu_glNormalStream3dvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3dvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalStream3fATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double nx;
    double ny;
    double nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3fATI( GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz )
{
    struct qemu_glNormalStream3fATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3FATI);
    call.stream = stream;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3fATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3fATI *c = (struct qemu_glNormalStream3fATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3fATI( c->stream, c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormalStream3fvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3fvATI( GLenum stream, const GLfloat *coords )
{
    struct qemu_glNormalStream3fvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3FVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3fvATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3fvATI *c = (struct qemu_glNormalStream3fvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3fvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalStream3iATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t nx;
    uint64_t ny;
    uint64_t nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3iATI( GLenum stream, GLint nx, GLint ny, GLint nz )
{
    struct qemu_glNormalStream3iATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3IATI);
    call.stream = stream;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3iATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3iATI *c = (struct qemu_glNormalStream3iATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3iATI( c->stream, c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormalStream3ivATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3ivATI( GLenum stream, const GLint *coords )
{
    struct qemu_glNormalStream3ivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3IVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3ivATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3ivATI *c = (struct qemu_glNormalStream3ivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3ivATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glNormalStream3sATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t nx;
    uint64_t ny;
    uint64_t nz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3sATI( GLenum stream, GLshort nx, GLshort ny, GLshort nz )
{
    struct qemu_glNormalStream3sATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3SATI);
    call.stream = stream;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3sATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3sATI *c = (struct qemu_glNormalStream3sATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3sATI( c->stream, c->nx, c->ny, c->nz ));
}

#endif

struct qemu_glNormalStream3svATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glNormalStream3svATI( GLenum stream, const GLshort *coords )
{
    struct qemu_glNormalStream3svATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLNORMALSTREAM3SVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glNormalStream3svATI(struct qemu_syscall *call)
{
    struct qemu_glNormalStream3svATI *c = (struct qemu_glNormalStream3svATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glNormalStream3svATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glObjectLabel
{
    struct qemu_syscall super;
    uint64_t identifier;
    uint64_t name;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glObjectLabel( GLenum identifier, GLuint name, GLsizei length, const GLchar *label )
{
    struct qemu_glObjectLabel call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLOBJECTLABEL);
    call.identifier = identifier;
    call.name = name;
    call.length = length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glObjectLabel(struct qemu_syscall *call)
{
    struct qemu_glObjectLabel *c = (struct qemu_glObjectLabel *)call;
    WINE_FIXME("Unverified\n");
    (p_glObjectLabel( c->identifier, c->name, c->length, QEMU_G2H(c->label) ));
}

#endif

struct qemu_glObjectPtrLabel
{
    struct qemu_syscall super;
    uint64_t ptr;
    uint64_t length;
    uint64_t label;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glObjectPtrLabel( const void *ptr, GLsizei length, const GLchar *label )
{
    struct qemu_glObjectPtrLabel call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLOBJECTPTRLABEL);
    call.ptr = (ULONG_PTR)ptr;
    call.length = length;
    call.label = (ULONG_PTR)label;

    qemu_syscall(&call.super);
}

#else

void qemu_glObjectPtrLabel(struct qemu_syscall *call)
{
    struct qemu_glObjectPtrLabel *c = (struct qemu_glObjectPtrLabel *)call;
    WINE_FIXME("Unverified\n");
    (p_glObjectPtrLabel( QEMU_G2H(c->ptr), c->length, QEMU_G2H(c->label) ));
}

#endif

struct qemu_glObjectPurgeableAPPLE
{
    struct qemu_syscall super;
    uint64_t objectType;
    uint64_t name;
    uint64_t option;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glObjectPurgeableAPPLE( GLenum objectType, GLuint name, GLenum option )
{
    struct qemu_glObjectPurgeableAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLOBJECTPURGEABLEAPPLE);
    call.objectType = objectType;
    call.name = name;
    call.option = option;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glObjectPurgeableAPPLE(struct qemu_syscall *call)
{
    struct qemu_glObjectPurgeableAPPLE *c = (struct qemu_glObjectPurgeableAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glObjectPurgeableAPPLE( c->objectType, c->name, c->option ));
}

#endif

struct qemu_glObjectUnpurgeableAPPLE
{
    struct qemu_syscall super;
    uint64_t objectType;
    uint64_t name;
    uint64_t option;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glObjectUnpurgeableAPPLE( GLenum objectType, GLuint name, GLenum option )
{
    struct qemu_glObjectUnpurgeableAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLOBJECTUNPURGEABLEAPPLE);
    call.objectType = objectType;
    call.name = name;
    call.option = option;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glObjectUnpurgeableAPPLE(struct qemu_syscall *call)
{
    struct qemu_glObjectUnpurgeableAPPLE *c = (struct qemu_glObjectUnpurgeableAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glObjectUnpurgeableAPPLE( c->objectType, c->name, c->option ));
}

#endif

struct qemu_glOrthofOES
{
    struct qemu_syscall super;
    double l;
    double r;
    double b;
    double t;
    double n;
    double f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glOrthofOES( GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f )
{
    struct qemu_glOrthofOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLORTHOFOES);
    call.l = l;
    call.r = r;
    call.b = b;
    call.t = t;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glOrthofOES(struct qemu_syscall *call)
{
    struct qemu_glOrthofOES *c = (struct qemu_glOrthofOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glOrthofOES( c->l, c->r, c->b, c->t, c->n, c->f ));
}

#endif

struct qemu_glOrthoxOES
{
    struct qemu_syscall super;
    uint64_t l;
    uint64_t r;
    uint64_t b;
    uint64_t t;
    uint64_t n;
    uint64_t f;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glOrthoxOES( GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f )
{
    struct qemu_glOrthoxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLORTHOXOES);
    call.l = l;
    call.r = r;
    call.b = b;
    call.t = t;
    call.n = n;
    call.f = f;

    qemu_syscall(&call.super);
}

#else

void qemu_glOrthoxOES(struct qemu_syscall *call)
{
    struct qemu_glOrthoxOES *c = (struct qemu_glOrthoxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glOrthoxOES( c->l, c->r, c->b, c->t, c->n, c->f ));
}

#endif

struct qemu_glPNTrianglesfATI
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPNTrianglesfATI( GLenum pname, GLfloat param )
{
    struct qemu_glPNTrianglesfATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPNTRIANGLESFATI);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPNTrianglesfATI(struct qemu_syscall *call)
{
    struct qemu_glPNTrianglesfATI *c = (struct qemu_glPNTrianglesfATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glPNTrianglesfATI( c->pname, c->param ));
}

#endif

struct qemu_glPNTrianglesiATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPNTrianglesiATI( GLenum pname, GLint param )
{
    struct qemu_glPNTrianglesiATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPNTRIANGLESIATI);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPNTrianglesiATI(struct qemu_syscall *call)
{
    struct qemu_glPNTrianglesiATI *c = (struct qemu_glPNTrianglesiATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glPNTrianglesiATI( c->pname, c->param ));
}

#endif

struct qemu_glPassTexCoordATI
{
    struct qemu_syscall super;
    uint64_t dst;
    uint64_t coord;
    uint64_t swizzle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPassTexCoordATI( GLuint dst, GLuint coord, GLenum swizzle )
{
    struct qemu_glPassTexCoordATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPASSTEXCOORDATI);
    call.dst = dst;
    call.coord = coord;
    call.swizzle = swizzle;

    qemu_syscall(&call.super);
}

#else

void qemu_glPassTexCoordATI(struct qemu_syscall *call)
{
    struct qemu_glPassTexCoordATI *c = (struct qemu_glPassTexCoordATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glPassTexCoordATI( c->dst, c->coord, c->swizzle ));
}

#endif

struct qemu_glPassThroughxOES
{
    struct qemu_syscall super;
    uint64_t token;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPassThroughxOES( GLfixed token )
{
    struct qemu_glPassThroughxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPASSTHROUGHXOES);
    call.token = token;

    qemu_syscall(&call.super);
}

#else

void qemu_glPassThroughxOES(struct qemu_syscall *call)
{
    struct qemu_glPassThroughxOES *c = (struct qemu_glPassThroughxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPassThroughxOES( c->token ));
}

#endif

struct qemu_glPatchParameterfv
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPatchParameterfv( GLenum pname, const GLfloat *values )
{
    struct qemu_glPatchParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATCHPARAMETERFV);
    call.pname = pname;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glPatchParameterfv(struct qemu_syscall *call)
{
    struct qemu_glPatchParameterfv *c = (struct qemu_glPatchParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glPatchParameterfv( c->pname, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glPatchParameteri
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPatchParameteri( GLenum pname, GLint value )
{
    struct qemu_glPatchParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATCHPARAMETERI);
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glPatchParameteri(struct qemu_syscall *call)
{
    struct qemu_glPatchParameteri *c = (struct qemu_glPatchParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glPatchParameteri( c->pname, c->value ));
}

#endif

struct qemu_glPathColorGenNV
{
    struct qemu_syscall super;
    uint64_t color;
    uint64_t genMode;
    uint64_t colorFormat;
    uint64_t coeffs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathColorGenNV( GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs )
{
    struct qemu_glPathColorGenNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHCOLORGENNV);
    call.color = color;
    call.genMode = genMode;
    call.colorFormat = colorFormat;
    call.coeffs = (ULONG_PTR)coeffs;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathColorGenNV(struct qemu_syscall *call)
{
    struct qemu_glPathColorGenNV *c = (struct qemu_glPathColorGenNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathColorGenNV( c->color, c->genMode, c->colorFormat, QEMU_G2H(c->coeffs) ));
}

#endif

struct qemu_glPathCommandsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t numCommands;
    uint64_t commands;
    uint64_t numCoords;
    uint64_t coordType;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathCommandsNV( GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords )
{
    struct qemu_glPathCommandsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHCOMMANDSNV);
    call.path = path;
    call.numCommands = numCommands;
    call.commands = (ULONG_PTR)commands;
    call.numCoords = numCoords;
    call.coordType = coordType;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathCommandsNV(struct qemu_syscall *call)
{
    struct qemu_glPathCommandsNV *c = (struct qemu_glPathCommandsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathCommandsNV( c->path, c->numCommands, QEMU_G2H(c->commands), c->numCoords, c->coordType, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glPathCoordsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t numCoords;
    uint64_t coordType;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathCoordsNV( GLuint path, GLsizei numCoords, GLenum coordType, const void *coords )
{
    struct qemu_glPathCoordsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHCOORDSNV);
    call.path = path;
    call.numCoords = numCoords;
    call.coordType = coordType;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathCoordsNV(struct qemu_syscall *call)
{
    struct qemu_glPathCoordsNV *c = (struct qemu_glPathCoordsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathCoordsNV( c->path, c->numCoords, c->coordType, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glPathCoverDepthFuncNV
{
    struct qemu_syscall super;
    uint64_t func;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathCoverDepthFuncNV( GLenum func )
{
    struct qemu_glPathCoverDepthFuncNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHCOVERDEPTHFUNCNV);
    call.func = func;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathCoverDepthFuncNV(struct qemu_syscall *call)
{
    struct qemu_glPathCoverDepthFuncNV *c = (struct qemu_glPathCoverDepthFuncNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathCoverDepthFuncNV( c->func ));
}

#endif

struct qemu_glPathDashArrayNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t dashCount;
    uint64_t dashArray;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathDashArrayNV( GLuint path, GLsizei dashCount, const GLfloat *dashArray )
{
    struct qemu_glPathDashArrayNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHDASHARRAYNV);
    call.path = path;
    call.dashCount = dashCount;
    call.dashArray = (ULONG_PTR)dashArray;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathDashArrayNV(struct qemu_syscall *call)
{
    struct qemu_glPathDashArrayNV *c = (struct qemu_glPathDashArrayNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathDashArrayNV( c->path, c->dashCount, QEMU_G2H(c->dashArray) ));
}

#endif

struct qemu_glPathFogGenNV
{
    struct qemu_syscall super;
    uint64_t genMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathFogGenNV( GLenum genMode )
{
    struct qemu_glPathFogGenNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHFOGGENNV);
    call.genMode = genMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathFogGenNV(struct qemu_syscall *call)
{
    struct qemu_glPathFogGenNV *c = (struct qemu_glPathFogGenNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathFogGenNV( c->genMode ));
}

#endif

struct qemu_glPathGlyphIndexArrayNV
{
    struct qemu_syscall super;
    uint64_t firstPathName;
    uint64_t fontTarget;
    uint64_t fontName;
    uint64_t fontStyle;
    uint64_t firstGlyphIndex;
    uint64_t numGlyphs;
    uint64_t pathParameterTemplate;
    double emScale;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glPathGlyphIndexArrayNV( GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale )
{
    struct qemu_glPathGlyphIndexArrayNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHGLYPHINDEXARRAYNV);
    call.firstPathName = firstPathName;
    call.fontTarget = fontTarget;
    call.fontName = (ULONG_PTR)fontName;
    call.fontStyle = fontStyle;
    call.firstGlyphIndex = firstGlyphIndex;
    call.numGlyphs = numGlyphs;
    call.pathParameterTemplate = pathParameterTemplate;
    call.emScale = emScale;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPathGlyphIndexArrayNV(struct qemu_syscall *call)
{
    struct qemu_glPathGlyphIndexArrayNV *c = (struct qemu_glPathGlyphIndexArrayNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPathGlyphIndexArrayNV( c->firstPathName, c->fontTarget, QEMU_G2H(c->fontName), c->fontStyle, c->firstGlyphIndex, c->numGlyphs, c->pathParameterTemplate, c->emScale ));
}

#endif

struct qemu_glPathGlyphIndexRangeNV
{
    struct qemu_syscall super;
    uint64_t fontTarget;
    uint64_t fontName;
    uint64_t fontStyle;
    uint64_t pathParameterTemplate;
    double emScale;
    uint64_t baseAndCount;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glPathGlyphIndexRangeNV( GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2] )
{
    struct qemu_glPathGlyphIndexRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHGLYPHINDEXRANGENV);
    call.fontTarget = fontTarget;
    call.fontName = (ULONG_PTR)fontName;
    call.fontStyle = fontStyle;
    call.pathParameterTemplate = pathParameterTemplate;
    call.emScale = emScale;
    call.baseAndCount = baseAndCount;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPathGlyphIndexRangeNV(struct qemu_syscall *call)
{
    struct qemu_glPathGlyphIndexRangeNV *c = (struct qemu_glPathGlyphIndexRangeNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPathGlyphIndexRangeNV( c->fontTarget, QEMU_G2H(c->fontName), c->fontStyle, c->pathParameterTemplate, c->emScale, c->baseAndCount ));
}

#endif

struct qemu_glPathGlyphRangeNV
{
    struct qemu_syscall super;
    uint64_t firstPathName;
    uint64_t fontTarget;
    uint64_t fontName;
    uint64_t fontStyle;
    uint64_t firstGlyph;
    uint64_t numGlyphs;
    uint64_t handleMissingGlyphs;
    uint64_t pathParameterTemplate;
    double emScale;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathGlyphRangeNV( GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale )
{
    struct qemu_glPathGlyphRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHGLYPHRANGENV);
    call.firstPathName = firstPathName;
    call.fontTarget = fontTarget;
    call.fontName = (ULONG_PTR)fontName;
    call.fontStyle = fontStyle;
    call.firstGlyph = firstGlyph;
    call.numGlyphs = numGlyphs;
    call.handleMissingGlyphs = handleMissingGlyphs;
    call.pathParameterTemplate = pathParameterTemplate;
    call.emScale = emScale;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathGlyphRangeNV(struct qemu_syscall *call)
{
    struct qemu_glPathGlyphRangeNV *c = (struct qemu_glPathGlyphRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathGlyphRangeNV( c->firstPathName, c->fontTarget, QEMU_G2H(c->fontName), c->fontStyle, c->firstGlyph, c->numGlyphs, c->handleMissingGlyphs, c->pathParameterTemplate, c->emScale ));
}

#endif

struct qemu_glPathGlyphsNV
{
    struct qemu_syscall super;
    uint64_t firstPathName;
    uint64_t fontTarget;
    uint64_t fontName;
    uint64_t fontStyle;
    uint64_t numGlyphs;
    uint64_t type;
    uint64_t charcodes;
    uint64_t handleMissingGlyphs;
    uint64_t pathParameterTemplate;
    double emScale;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathGlyphsNV( GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale )
{
    struct qemu_glPathGlyphsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHGLYPHSNV);
    call.firstPathName = firstPathName;
    call.fontTarget = fontTarget;
    call.fontName = (ULONG_PTR)fontName;
    call.fontStyle = fontStyle;
    call.numGlyphs = numGlyphs;
    call.type = type;
    call.charcodes = (ULONG_PTR)charcodes;
    call.handleMissingGlyphs = handleMissingGlyphs;
    call.pathParameterTemplate = pathParameterTemplate;
    call.emScale = emScale;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathGlyphsNV(struct qemu_syscall *call)
{
    struct qemu_glPathGlyphsNV *c = (struct qemu_glPathGlyphsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathGlyphsNV( c->firstPathName, c->fontTarget, QEMU_G2H(c->fontName), c->fontStyle, c->numGlyphs, c->type, QEMU_G2H(c->charcodes), c->handleMissingGlyphs, c->pathParameterTemplate, c->emScale ));
}

#endif

struct qemu_glPathMemoryGlyphIndexArrayNV
{
    struct qemu_syscall super;
    uint64_t firstPathName;
    uint64_t fontTarget;
    uint64_t fontSize;
    uint64_t fontData;
    uint64_t faceIndex;
    uint64_t firstGlyphIndex;
    uint64_t numGlyphs;
    uint64_t pathParameterTemplate;
    double emScale;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glPathMemoryGlyphIndexArrayNV( GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale )
{
    struct qemu_glPathMemoryGlyphIndexArrayNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHMEMORYGLYPHINDEXARRAYNV);
    call.firstPathName = firstPathName;
    call.fontTarget = fontTarget;
    call.fontSize = fontSize;
    call.fontData = (ULONG_PTR)fontData;
    call.faceIndex = faceIndex;
    call.firstGlyphIndex = firstGlyphIndex;
    call.numGlyphs = numGlyphs;
    call.pathParameterTemplate = pathParameterTemplate;
    call.emScale = emScale;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPathMemoryGlyphIndexArrayNV(struct qemu_syscall *call)
{
    struct qemu_glPathMemoryGlyphIndexArrayNV *c = (struct qemu_glPathMemoryGlyphIndexArrayNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPathMemoryGlyphIndexArrayNV( c->firstPathName, c->fontTarget, c->fontSize, QEMU_G2H(c->fontData), c->faceIndex, c->firstGlyphIndex, c->numGlyphs, c->pathParameterTemplate, c->emScale ));
}

#endif

struct qemu_glPathParameterfNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    double value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathParameterfNV( GLuint path, GLenum pname, GLfloat value )
{
    struct qemu_glPathParameterfNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHPARAMETERFNV);
    call.path = path;
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathParameterfNV(struct qemu_syscall *call)
{
    struct qemu_glPathParameterfNV *c = (struct qemu_glPathParameterfNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathParameterfNV( c->path, c->pname, c->value ));
}

#endif

struct qemu_glPathParameterfvNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathParameterfvNV( GLuint path, GLenum pname, const GLfloat *value )
{
    struct qemu_glPathParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHPARAMETERFVNV);
    call.path = path;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glPathParameterfvNV *c = (struct qemu_glPathParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathParameterfvNV( c->path, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glPathParameteriNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathParameteriNV( GLuint path, GLenum pname, GLint value )
{
    struct qemu_glPathParameteriNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHPARAMETERINV);
    call.path = path;
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathParameteriNV(struct qemu_syscall *call)
{
    struct qemu_glPathParameteriNV *c = (struct qemu_glPathParameteriNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathParameteriNV( c->path, c->pname, c->value ));
}

#endif

struct qemu_glPathParameterivNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathParameterivNV( GLuint path, GLenum pname, const GLint *value )
{
    struct qemu_glPathParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHPARAMETERIVNV);
    call.path = path;
    call.pname = pname;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glPathParameterivNV *c = (struct qemu_glPathParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathParameterivNV( c->path, c->pname, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glPathStencilDepthOffsetNV
{
    struct qemu_syscall super;
    double factor;
    double units;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathStencilDepthOffsetNV( GLfloat factor, GLfloat units )
{
    struct qemu_glPathStencilDepthOffsetNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHSTENCILDEPTHOFFSETNV);
    call.factor = factor;
    call.units = units;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathStencilDepthOffsetNV(struct qemu_syscall *call)
{
    struct qemu_glPathStencilDepthOffsetNV *c = (struct qemu_glPathStencilDepthOffsetNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathStencilDepthOffsetNV( c->factor, c->units ));
}

#endif

struct qemu_glPathStencilFuncNV
{
    struct qemu_syscall super;
    uint64_t func;
    uint64_t ref;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathStencilFuncNV( GLenum func, GLint ref, GLuint mask )
{
    struct qemu_glPathStencilFuncNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHSTENCILFUNCNV);
    call.func = func;
    call.ref = ref;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathStencilFuncNV(struct qemu_syscall *call)
{
    struct qemu_glPathStencilFuncNV *c = (struct qemu_glPathStencilFuncNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathStencilFuncNV( c->func, c->ref, c->mask ));
}

#endif

struct qemu_glPathStringNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t format;
    uint64_t length;
    uint64_t pathString;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathStringNV( GLuint path, GLenum format, GLsizei length, const void *pathString )
{
    struct qemu_glPathStringNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHSTRINGNV);
    call.path = path;
    call.format = format;
    call.length = length;
    call.pathString = (ULONG_PTR)pathString;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathStringNV(struct qemu_syscall *call)
{
    struct qemu_glPathStringNV *c = (struct qemu_glPathStringNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathStringNV( c->path, c->format, c->length, QEMU_G2H(c->pathString) ));
}

#endif

struct qemu_glPathSubCommandsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t commandStart;
    uint64_t commandsToDelete;
    uint64_t numCommands;
    uint64_t commands;
    uint64_t numCoords;
    uint64_t coordType;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathSubCommandsNV( GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords )
{
    struct qemu_glPathSubCommandsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHSUBCOMMANDSNV);
    call.path = path;
    call.commandStart = commandStart;
    call.commandsToDelete = commandsToDelete;
    call.numCommands = numCommands;
    call.commands = (ULONG_PTR)commands;
    call.numCoords = numCoords;
    call.coordType = coordType;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathSubCommandsNV(struct qemu_syscall *call)
{
    struct qemu_glPathSubCommandsNV *c = (struct qemu_glPathSubCommandsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathSubCommandsNV( c->path, c->commandStart, c->commandsToDelete, c->numCommands, QEMU_G2H(c->commands), c->numCoords, c->coordType, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glPathSubCoordsNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t coordStart;
    uint64_t numCoords;
    uint64_t coordType;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathSubCoordsNV( GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords )
{
    struct qemu_glPathSubCoordsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHSUBCOORDSNV);
    call.path = path;
    call.coordStart = coordStart;
    call.numCoords = numCoords;
    call.coordType = coordType;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathSubCoordsNV(struct qemu_syscall *call)
{
    struct qemu_glPathSubCoordsNV *c = (struct qemu_glPathSubCoordsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathSubCoordsNV( c->path, c->coordStart, c->numCoords, c->coordType, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glPathTexGenNV
{
    struct qemu_syscall super;
    uint64_t texCoordSet;
    uint64_t genMode;
    uint64_t components;
    uint64_t coeffs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPathTexGenNV( GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs )
{
    struct qemu_glPathTexGenNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPATHTEXGENNV);
    call.texCoordSet = texCoordSet;
    call.genMode = genMode;
    call.components = components;
    call.coeffs = (ULONG_PTR)coeffs;

    qemu_syscall(&call.super);
}

#else

void qemu_glPathTexGenNV(struct qemu_syscall *call)
{
    struct qemu_glPathTexGenNV *c = (struct qemu_glPathTexGenNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPathTexGenNV( c->texCoordSet, c->genMode, c->components, QEMU_G2H(c->coeffs) ));
}

#endif

struct qemu_glPauseTransformFeedback
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPauseTransformFeedback(void)
{
    struct qemu_glPauseTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPAUSETRANSFORMFEEDBACK);

    qemu_syscall(&call.super);
}

#else

void qemu_glPauseTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glPauseTransformFeedback *c = (struct qemu_glPauseTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glPauseTransformFeedback());
}

#endif

struct qemu_glPauseTransformFeedbackNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPauseTransformFeedbackNV(void)
{
    struct qemu_glPauseTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPAUSETRANSFORMFEEDBACKNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glPauseTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glPauseTransformFeedbackNV *c = (struct qemu_glPauseTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPauseTransformFeedbackNV());
}

#endif

struct qemu_glPixelDataRangeNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t length;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelDataRangeNV( GLenum target, GLsizei length, const void *pointer )
{
    struct qemu_glPixelDataRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELDATARANGENV);
    call.target = target;
    call.length = length;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelDataRangeNV(struct qemu_syscall *call)
{
    struct qemu_glPixelDataRangeNV *c = (struct qemu_glPixelDataRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelDataRangeNV( c->target, c->length, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glPixelMapx
{
    struct qemu_syscall super;
    uint64_t map;
    uint64_t size;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelMapx( GLenum map, GLint size, const GLfixed *values )
{
    struct qemu_glPixelMapx call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELMAPX);
    call.map = map;
    call.size = size;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelMapx(struct qemu_syscall *call)
{
    struct qemu_glPixelMapx *c = (struct qemu_glPixelMapx *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelMapx( c->map, c->size, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glPixelStorex
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelStorex( GLenum pname, GLfixed param )
{
    struct qemu_glPixelStorex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELSTOREX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelStorex(struct qemu_syscall *call)
{
    struct qemu_glPixelStorex *c = (struct qemu_glPixelStorex *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelStorex( c->pname, c->param ));
}

#endif

struct qemu_glPixelTexGenParameterfSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTexGenParameterfSGIS( GLenum pname, GLfloat param )
{
    struct qemu_glPixelTexGenParameterfSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTEXGENPARAMETERFSGIS);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTexGenParameterfSGIS(struct qemu_syscall *call)
{
    struct qemu_glPixelTexGenParameterfSGIS *c = (struct qemu_glPixelTexGenParameterfSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTexGenParameterfSGIS( c->pname, c->param ));
}

#endif

struct qemu_glPixelTexGenParameterfvSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTexGenParameterfvSGIS( GLenum pname, const GLfloat *params )
{
    struct qemu_glPixelTexGenParameterfvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTEXGENPARAMETERFVSGIS);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTexGenParameterfvSGIS(struct qemu_syscall *call)
{
    struct qemu_glPixelTexGenParameterfvSGIS *c = (struct qemu_glPixelTexGenParameterfvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTexGenParameterfvSGIS( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPixelTexGenParameteriSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTexGenParameteriSGIS( GLenum pname, GLint param )
{
    struct qemu_glPixelTexGenParameteriSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTEXGENPARAMETERISGIS);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTexGenParameteriSGIS(struct qemu_syscall *call)
{
    struct qemu_glPixelTexGenParameteriSGIS *c = (struct qemu_glPixelTexGenParameteriSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTexGenParameteriSGIS( c->pname, c->param ));
}

#endif

struct qemu_glPixelTexGenParameterivSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTexGenParameterivSGIS( GLenum pname, const GLint *params )
{
    struct qemu_glPixelTexGenParameterivSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTEXGENPARAMETERIVSGIS);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTexGenParameterivSGIS(struct qemu_syscall *call)
{
    struct qemu_glPixelTexGenParameterivSGIS *c = (struct qemu_glPixelTexGenParameterivSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTexGenParameterivSGIS( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPixelTexGenSGIX
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTexGenSGIX( GLenum mode )
{
    struct qemu_glPixelTexGenSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTEXGENSGIX);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTexGenSGIX(struct qemu_syscall *call)
{
    struct qemu_glPixelTexGenSGIX *c = (struct qemu_glPixelTexGenSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTexGenSGIX( c->mode ));
}

#endif

struct qemu_glPixelTransferxOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTransferxOES( GLenum pname, GLfixed param )
{
    struct qemu_glPixelTransferxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTRANSFERXOES);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTransferxOES(struct qemu_syscall *call)
{
    struct qemu_glPixelTransferxOES *c = (struct qemu_glPixelTransferxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTransferxOES( c->pname, c->param ));
}

#endif

struct qemu_glPixelTransformParameterfEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTransformParameterfEXT( GLenum target, GLenum pname, GLfloat param )
{
    struct qemu_glPixelTransformParameterfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTRANSFORMPARAMETERFEXT);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTransformParameterfEXT(struct qemu_syscall *call)
{
    struct qemu_glPixelTransformParameterfEXT *c = (struct qemu_glPixelTransformParameterfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTransformParameterfEXT( c->target, c->pname, c->param ));
}

#endif

struct qemu_glPixelTransformParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTransformParameterfvEXT( GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glPixelTransformParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTRANSFORMPARAMETERFVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTransformParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glPixelTransformParameterfvEXT *c = (struct qemu_glPixelTransformParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTransformParameterfvEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPixelTransformParameteriEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTransformParameteriEXT( GLenum target, GLenum pname, GLint param )
{
    struct qemu_glPixelTransformParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTRANSFORMPARAMETERIEXT);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTransformParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glPixelTransformParameteriEXT *c = (struct qemu_glPixelTransformParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTransformParameteriEXT( c->target, c->pname, c->param ));
}

#endif

struct qemu_glPixelTransformParameterivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelTransformParameterivEXT( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glPixelTransformParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELTRANSFORMPARAMETERIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelTransformParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glPixelTransformParameterivEXT *c = (struct qemu_glPixelTransformParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelTransformParameterivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPixelZoomxOES
{
    struct qemu_syscall super;
    uint64_t xfactor;
    uint64_t yfactor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPixelZoomxOES( GLfixed xfactor, GLfixed yfactor )
{
    struct qemu_glPixelZoomxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPIXELZOOMXOES);
    call.xfactor = xfactor;
    call.yfactor = yfactor;

    qemu_syscall(&call.super);
}

#else

void qemu_glPixelZoomxOES(struct qemu_syscall *call)
{
    struct qemu_glPixelZoomxOES *c = (struct qemu_glPixelZoomxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPixelZoomxOES( c->xfactor, c->yfactor ));
}

#endif

struct qemu_glPointAlongPathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t startSegment;
    uint64_t numSegments;
    double distance;
    uint64_t x;
    uint64_t y;
    uint64_t tangentX;
    uint64_t tangentY;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glPointAlongPathNV( GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY )
{
    struct qemu_glPointAlongPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTALONGPATHNV);
    call.path = path;
    call.startSegment = startSegment;
    call.numSegments = numSegments;
    call.distance = distance;
    call.x = (ULONG_PTR)x;
    call.y = (ULONG_PTR)y;
    call.tangentX = (ULONG_PTR)tangentX;
    call.tangentY = (ULONG_PTR)tangentY;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPointAlongPathNV(struct qemu_syscall *call)
{
    struct qemu_glPointAlongPathNV *c = (struct qemu_glPointAlongPathNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPointAlongPathNV( c->path, c->startSegment, c->numSegments, c->distance, QEMU_G2H(c->x), QEMU_G2H(c->y), QEMU_G2H(c->tangentX), QEMU_G2H(c->tangentY) ));
}

#endif

struct qemu_glPointParameterf
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterf( GLenum pname, GLfloat param )
{
    struct qemu_glPointParameterf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERF);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterf(struct qemu_syscall *call)
{
    struct qemu_glPointParameterf *c = (struct qemu_glPointParameterf *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterf( c->pname, c->param ));
}

#endif

struct qemu_glPointParameterfARB
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfARB( GLenum pname, GLfloat param )
{
    struct qemu_glPointParameterfARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFARB);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfARB(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfARB *c = (struct qemu_glPointParameterfARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfARB( c->pname, c->param ));
}

#endif

struct qemu_glPointParameterfEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfEXT( GLenum pname, GLfloat param )
{
    struct qemu_glPointParameterfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFEXT);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfEXT(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfEXT *c = (struct qemu_glPointParameterfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfEXT( c->pname, c->param ));
}

#endif

struct qemu_glPointParameterfSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfSGIS( GLenum pname, GLfloat param )
{
    struct qemu_glPointParameterfSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFSGIS);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfSGIS(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfSGIS *c = (struct qemu_glPointParameterfSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfSGIS( c->pname, c->param ));
}

#endif

struct qemu_glPointParameterfv
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfv( GLenum pname, const GLfloat *params )
{
    struct qemu_glPointParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFV);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfv(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfv *c = (struct qemu_glPointParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfv( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameterfvARB
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfvARB( GLenum pname, const GLfloat *params )
{
    struct qemu_glPointParameterfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFVARB);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfvARB(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfvARB *c = (struct qemu_glPointParameterfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfvARB( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfvEXT( GLenum pname, const GLfloat *params )
{
    struct qemu_glPointParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFVEXT);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfvEXT *c = (struct qemu_glPointParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfvEXT( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameterfvSGIS
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterfvSGIS( GLenum pname, const GLfloat *params )
{
    struct qemu_glPointParameterfvSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERFVSGIS);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterfvSGIS(struct qemu_syscall *call)
{
    struct qemu_glPointParameterfvSGIS *c = (struct qemu_glPointParameterfvSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterfvSGIS( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameteri
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameteri( GLenum pname, GLint param )
{
    struct qemu_glPointParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERI);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameteri(struct qemu_syscall *call)
{
    struct qemu_glPointParameteri *c = (struct qemu_glPointParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameteri( c->pname, c->param ));
}

#endif

struct qemu_glPointParameteriNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameteriNV( GLenum pname, GLint param )
{
    struct qemu_glPointParameteriNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERINV);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameteriNV(struct qemu_syscall *call)
{
    struct qemu_glPointParameteriNV *c = (struct qemu_glPointParameteriNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameteriNV( c->pname, c->param ));
}

#endif

struct qemu_glPointParameteriv
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameteriv( GLenum pname, const GLint *params )
{
    struct qemu_glPointParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERIV);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameteriv(struct qemu_syscall *call)
{
    struct qemu_glPointParameteriv *c = (struct qemu_glPointParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameteriv( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameterivNV
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterivNV( GLenum pname, const GLint *params )
{
    struct qemu_glPointParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERIVNV);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glPointParameterivNV *c = (struct qemu_glPointParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterivNV( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointParameterxvOES
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointParameterxvOES( GLenum pname, const GLfixed *params )
{
    struct qemu_glPointParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTPARAMETERXVOES);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glPointParameterxvOES *c = (struct qemu_glPointParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointParameterxvOES( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glPointSizexOES
{
    struct qemu_syscall super;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPointSizexOES( GLfixed size )
{
    struct qemu_glPointSizexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOINTSIZEXOES);
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glPointSizexOES(struct qemu_syscall *call)
{
    struct qemu_glPointSizexOES *c = (struct qemu_glPointSizexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPointSizexOES( c->size ));
}

#endif

struct qemu_glPollAsyncSGIX
{
    struct qemu_syscall super;
    uint64_t markerp;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glPollAsyncSGIX( GLuint *markerp )
{
    struct qemu_glPollAsyncSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLLASYNCSGIX);
    call.markerp = (ULONG_PTR)markerp;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPollAsyncSGIX(struct qemu_syscall *call)
{
    struct qemu_glPollAsyncSGIX *c = (struct qemu_glPollAsyncSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPollAsyncSGIX( QEMU_G2H(c->markerp) ));
}

#endif

struct qemu_glPollInstrumentsSGIX
{
    struct qemu_syscall super;
    uint64_t marker_p;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glPollInstrumentsSGIX( GLint *marker_p )
{
    struct qemu_glPollInstrumentsSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLLINSTRUMENTSSGIX);
    call.marker_p = (ULONG_PTR)marker_p;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glPollInstrumentsSGIX(struct qemu_syscall *call)
{
    struct qemu_glPollInstrumentsSGIX *c = (struct qemu_glPollInstrumentsSGIX *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glPollInstrumentsSGIX( QEMU_G2H(c->marker_p) ));
}

#endif

struct qemu_glPolygonOffsetClamp
{
    struct qemu_syscall super;
    double factor;
    double units;
    double clamp;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPolygonOffsetClamp( GLfloat factor, GLfloat units, GLfloat clamp )
{
    struct qemu_glPolygonOffsetClamp call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLYGONOFFSETCLAMP);
    call.factor = factor;
    call.units = units;
    call.clamp = clamp;

    qemu_syscall(&call.super);
}

#else

void qemu_glPolygonOffsetClamp(struct qemu_syscall *call)
{
    struct qemu_glPolygonOffsetClamp *c = (struct qemu_glPolygonOffsetClamp *)call;
    WINE_FIXME("Unverified\n");
    (p_glPolygonOffsetClamp( c->factor, c->units, c->clamp ));
}

#endif

struct qemu_glPolygonOffsetClampEXT
{
    struct qemu_syscall super;
    double factor;
    double units;
    double clamp;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPolygonOffsetClampEXT( GLfloat factor, GLfloat units, GLfloat clamp )
{
    struct qemu_glPolygonOffsetClampEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLYGONOFFSETCLAMPEXT);
    call.factor = factor;
    call.units = units;
    call.clamp = clamp;

    qemu_syscall(&call.super);
}

#else

void qemu_glPolygonOffsetClampEXT(struct qemu_syscall *call)
{
    struct qemu_glPolygonOffsetClampEXT *c = (struct qemu_glPolygonOffsetClampEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPolygonOffsetClampEXT( c->factor, c->units, c->clamp ));
}

#endif

struct qemu_glPolygonOffsetEXT
{
    struct qemu_syscall super;
    double factor;
    double bias;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPolygonOffsetEXT( GLfloat factor, GLfloat bias )
{
    struct qemu_glPolygonOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLYGONOFFSETEXT);
    call.factor = factor;
    call.bias = bias;

    qemu_syscall(&call.super);
}

#else

void qemu_glPolygonOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glPolygonOffsetEXT *c = (struct qemu_glPolygonOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPolygonOffsetEXT( c->factor, c->bias ));
}

#endif

struct qemu_glPolygonOffsetxOES
{
    struct qemu_syscall super;
    uint64_t factor;
    uint64_t units;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPolygonOffsetxOES( GLfixed factor, GLfixed units )
{
    struct qemu_glPolygonOffsetxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOLYGONOFFSETXOES);
    call.factor = factor;
    call.units = units;

    qemu_syscall(&call.super);
}

#else

void qemu_glPolygonOffsetxOES(struct qemu_syscall *call)
{
    struct qemu_glPolygonOffsetxOES *c = (struct qemu_glPolygonOffsetxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPolygonOffsetxOES( c->factor, c->units ));
}

#endif

struct qemu_glPopDebugGroup
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPopDebugGroup(void)
{
    struct qemu_glPopDebugGroup call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOPDEBUGGROUP);

    qemu_syscall(&call.super);
}

#else

void qemu_glPopDebugGroup(struct qemu_syscall *call)
{
    struct qemu_glPopDebugGroup *c = (struct qemu_glPopDebugGroup *)call;
    WINE_FIXME("Unverified\n");
    (p_glPopDebugGroup());
}

#endif

struct qemu_glPopGroupMarkerEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPopGroupMarkerEXT(void)
{
    struct qemu_glPopGroupMarkerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPOPGROUPMARKEREXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glPopGroupMarkerEXT(struct qemu_syscall *call)
{
    struct qemu_glPopGroupMarkerEXT *c = (struct qemu_glPopGroupMarkerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPopGroupMarkerEXT());
}

#endif

struct qemu_glPresentFrameDualFillNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t minPresentTime;
    uint64_t beginPresentTimeId;
    uint64_t presentDurationId;
    uint64_t type;
    uint64_t target0;
    uint64_t fill0;
    uint64_t target1;
    uint64_t fill1;
    uint64_t target2;
    uint64_t fill2;
    uint64_t target3;
    uint64_t fill3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPresentFrameDualFillNV( GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3 )
{
    struct qemu_glPresentFrameDualFillNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRESENTFRAMEDUALFILLNV);
    call.video_slot = video_slot;
    call.minPresentTime = minPresentTime;
    call.beginPresentTimeId = beginPresentTimeId;
    call.presentDurationId = presentDurationId;
    call.type = type;
    call.target0 = target0;
    call.fill0 = fill0;
    call.target1 = target1;
    call.fill1 = fill1;
    call.target2 = target2;
    call.fill2 = fill2;
    call.target3 = target3;
    call.fill3 = fill3;

    qemu_syscall(&call.super);
}

#else

void qemu_glPresentFrameDualFillNV(struct qemu_syscall *call)
{
    struct qemu_glPresentFrameDualFillNV *c = (struct qemu_glPresentFrameDualFillNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPresentFrameDualFillNV( c->video_slot, c->minPresentTime, c->beginPresentTimeId, c->presentDurationId, c->type, c->target0, c->fill0, c->target1, c->fill1, c->target2, c->fill2, c->target3, c->fill3 ));
}

#endif

struct qemu_glPresentFrameKeyedNV
{
    struct qemu_syscall super;
    uint64_t video_slot;
    uint64_t minPresentTime;
    uint64_t beginPresentTimeId;
    uint64_t presentDurationId;
    uint64_t type;
    uint64_t target0;
    uint64_t fill0;
    uint64_t key0;
    uint64_t target1;
    uint64_t fill1;
    uint64_t key1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPresentFrameKeyedNV( GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1 )
{
    struct qemu_glPresentFrameKeyedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRESENTFRAMEKEYEDNV);
    call.video_slot = video_slot;
    call.minPresentTime = minPresentTime;
    call.beginPresentTimeId = beginPresentTimeId;
    call.presentDurationId = presentDurationId;
    call.type = type;
    call.target0 = target0;
    call.fill0 = fill0;
    call.key0 = key0;
    call.target1 = target1;
    call.fill1 = fill1;
    call.key1 = key1;

    qemu_syscall(&call.super);
}

#else

void qemu_glPresentFrameKeyedNV(struct qemu_syscall *call)
{
    struct qemu_glPresentFrameKeyedNV *c = (struct qemu_glPresentFrameKeyedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPresentFrameKeyedNV( c->video_slot, c->minPresentTime, c->beginPresentTimeId, c->presentDurationId, c->type, c->target0, c->fill0, c->key0, c->target1, c->fill1, c->key1 ));
}

#endif

struct qemu_glPrimitiveBoundingBoxARB
{
    struct qemu_syscall super;
    double minX;
    double minY;
    double minZ;
    double minW;
    double maxX;
    double maxY;
    double maxZ;
    double maxW;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrimitiveBoundingBoxARB( GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW )
{
    struct qemu_glPrimitiveBoundingBoxARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIMITIVEBOUNDINGBOXARB);
    call.minX = minX;
    call.minY = minY;
    call.minZ = minZ;
    call.minW = minW;
    call.maxX = maxX;
    call.maxY = maxY;
    call.maxZ = maxZ;
    call.maxW = maxW;

    qemu_syscall(&call.super);
}

#else

void qemu_glPrimitiveBoundingBoxARB(struct qemu_syscall *call)
{
    struct qemu_glPrimitiveBoundingBoxARB *c = (struct qemu_glPrimitiveBoundingBoxARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrimitiveBoundingBoxARB( c->minX, c->minY, c->minZ, c->minW, c->maxX, c->maxY, c->maxZ, c->maxW ));
}

#endif

struct qemu_glPrimitiveRestartIndex
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrimitiveRestartIndex( GLuint index )
{
    struct qemu_glPrimitiveRestartIndex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIMITIVERESTARTINDEX);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glPrimitiveRestartIndex(struct qemu_syscall *call)
{
    struct qemu_glPrimitiveRestartIndex *c = (struct qemu_glPrimitiveRestartIndex *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrimitiveRestartIndex( c->index ));
}

#endif

struct qemu_glPrimitiveRestartIndexNV
{
    struct qemu_syscall super;
    uint64_t index;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrimitiveRestartIndexNV( GLuint index )
{
    struct qemu_glPrimitiveRestartIndexNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIMITIVERESTARTINDEXNV);
    call.index = index;

    qemu_syscall(&call.super);
}

#else

void qemu_glPrimitiveRestartIndexNV(struct qemu_syscall *call)
{
    struct qemu_glPrimitiveRestartIndexNV *c = (struct qemu_glPrimitiveRestartIndexNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrimitiveRestartIndexNV( c->index ));
}

#endif

struct qemu_glPrimitiveRestartNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrimitiveRestartNV(void)
{
    struct qemu_glPrimitiveRestartNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIMITIVERESTARTNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glPrimitiveRestartNV(struct qemu_syscall *call)
{
    struct qemu_glPrimitiveRestartNV *c = (struct qemu_glPrimitiveRestartNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrimitiveRestartNV());
}

#endif

struct qemu_glPrioritizeTexturesEXT
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t textures;
    uint64_t priorities;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrioritizeTexturesEXT( GLsizei n, const GLuint *textures, const GLclampf *priorities )
{
    struct qemu_glPrioritizeTexturesEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIORITIZETEXTURESEXT);
    call.n = n;
    call.textures = (ULONG_PTR)textures;
    call.priorities = (ULONG_PTR)priorities;

    qemu_syscall(&call.super);
}

#else

void qemu_glPrioritizeTexturesEXT(struct qemu_syscall *call)
{
    struct qemu_glPrioritizeTexturesEXT *c = (struct qemu_glPrioritizeTexturesEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrioritizeTexturesEXT( c->n, QEMU_G2H(c->textures), QEMU_G2H(c->priorities) ));
}

#endif

struct qemu_glPrioritizeTexturesxOES
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t textures;
    uint64_t priorities;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPrioritizeTexturesxOES( GLsizei n, const GLuint *textures, const GLfixed *priorities )
{
    struct qemu_glPrioritizeTexturesxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPRIORITIZETEXTURESXOES);
    call.n = n;
    call.textures = (ULONG_PTR)textures;
    call.priorities = (ULONG_PTR)priorities;

    qemu_syscall(&call.super);
}

#else

void qemu_glPrioritizeTexturesxOES(struct qemu_syscall *call)
{
    struct qemu_glPrioritizeTexturesxOES *c = (struct qemu_glPrioritizeTexturesxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glPrioritizeTexturesxOES( c->n, QEMU_G2H(c->textures), QEMU_G2H(c->priorities) ));
}

#endif

struct qemu_glProgramBinary
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t binaryFormat;
    uint64_t binary;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramBinary( GLuint program, GLenum binaryFormat, const void *binary, GLsizei length )
{
    struct qemu_glProgramBinary call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMBINARY);
    call.program = program;
    call.binaryFormat = binaryFormat;
    call.binary = (ULONG_PTR)binary;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramBinary(struct qemu_syscall *call)
{
    struct qemu_glProgramBinary *c = (struct qemu_glProgramBinary *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramBinary( c->program, c->binaryFormat, QEMU_G2H(c->binary), c->length ));
}

#endif

struct qemu_glProgramBufferParametersIivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t bindingIndex;
    uint64_t wordIndex;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramBufferParametersIivNV( GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params )
{
    struct qemu_glProgramBufferParametersIivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMBUFFERPARAMETERSIIVNV);
    call.target = target;
    call.bindingIndex = bindingIndex;
    call.wordIndex = wordIndex;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramBufferParametersIivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramBufferParametersIivNV *c = (struct qemu_glProgramBufferParametersIivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramBufferParametersIivNV( c->target, c->bindingIndex, c->wordIndex, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramBufferParametersIuivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t bindingIndex;
    uint64_t wordIndex;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramBufferParametersIuivNV( GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params )
{
    struct qemu_glProgramBufferParametersIuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMBUFFERPARAMETERSIUIVNV);
    call.target = target;
    call.bindingIndex = bindingIndex;
    call.wordIndex = wordIndex;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramBufferParametersIuivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramBufferParametersIuivNV *c = (struct qemu_glProgramBufferParametersIuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramBufferParametersIuivNV( c->target, c->bindingIndex, c->wordIndex, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramBufferParametersfvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t bindingIndex;
    uint64_t wordIndex;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramBufferParametersfvNV( GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params )
{
    struct qemu_glProgramBufferParametersfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMBUFFERPARAMETERSFVNV);
    call.target = target;
    call.bindingIndex = bindingIndex;
    call.wordIndex = wordIndex;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramBufferParametersfvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramBufferParametersfvNV *c = (struct qemu_glProgramBufferParametersfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramBufferParametersfvNV( c->target, c->bindingIndex, c->wordIndex, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParameter4dARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glProgramEnvParameter4dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETER4DARB);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameter4dARB(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameter4dARB *c = (struct qemu_glProgramEnvParameter4dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameter4dARB( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramEnvParameter4dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameter4dvARB( GLenum target, GLuint index, const GLdouble *params )
{
    struct qemu_glProgramEnvParameter4dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETER4DVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameter4dvARB(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameter4dvARB *c = (struct qemu_glProgramEnvParameter4dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameter4dvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParameter4fARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glProgramEnvParameter4fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETER4FARB);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameter4fARB(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameter4fARB *c = (struct qemu_glProgramEnvParameter4fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameter4fARB( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramEnvParameter4fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameter4fvARB( GLenum target, GLuint index, const GLfloat *params )
{
    struct qemu_glProgramEnvParameter4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETER4FVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameter4fvARB(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameter4fvARB *c = (struct qemu_glProgramEnvParameter4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameter4fvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParameterI4iNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameterI4iNV( GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glProgramEnvParameterI4iNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERI4INV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameterI4iNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameterI4iNV *c = (struct qemu_glProgramEnvParameterI4iNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameterI4iNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramEnvParameterI4ivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameterI4ivNV( GLenum target, GLuint index, const GLint *params )
{
    struct qemu_glProgramEnvParameterI4ivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERI4IVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameterI4ivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameterI4ivNV *c = (struct qemu_glProgramEnvParameterI4ivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameterI4ivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParameterI4uiNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameterI4uiNV( GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
{
    struct qemu_glProgramEnvParameterI4uiNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERI4UINV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameterI4uiNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameterI4uiNV *c = (struct qemu_glProgramEnvParameterI4uiNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameterI4uiNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramEnvParameterI4uivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameterI4uivNV( GLenum target, GLuint index, const GLuint *params )
{
    struct qemu_glProgramEnvParameterI4uivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERI4UIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameterI4uivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameterI4uivNV *c = (struct qemu_glProgramEnvParameterI4uivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameterI4uivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParameters4fvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParameters4fvEXT( GLenum target, GLuint index, GLsizei count, const GLfloat *params )
{
    struct qemu_glProgramEnvParameters4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERS4FVEXT);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParameters4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParameters4fvEXT *c = (struct qemu_glProgramEnvParameters4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParameters4fvEXT( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParametersI4ivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParametersI4ivNV( GLenum target, GLuint index, GLsizei count, const GLint *params )
{
    struct qemu_glProgramEnvParametersI4ivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERSI4IVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParametersI4ivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParametersI4ivNV *c = (struct qemu_glProgramEnvParametersI4ivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParametersI4ivNV( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramEnvParametersI4uivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramEnvParametersI4uivNV( GLenum target, GLuint index, GLsizei count, const GLuint *params )
{
    struct qemu_glProgramEnvParametersI4uivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMENVPARAMETERSI4UIVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramEnvParametersI4uivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramEnvParametersI4uivNV *c = (struct qemu_glProgramEnvParametersI4uivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramEnvParametersI4uivNV( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParameter4dARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glProgramLocalParameter4dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETER4DARB);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameter4dARB(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameter4dARB *c = (struct qemu_glProgramLocalParameter4dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameter4dARB( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramLocalParameter4dvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameter4dvARB( GLenum target, GLuint index, const GLdouble *params )
{
    struct qemu_glProgramLocalParameter4dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETER4DVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameter4dvARB(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameter4dvARB *c = (struct qemu_glProgramLocalParameter4dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameter4dvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParameter4fARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glProgramLocalParameter4fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETER4FARB);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameter4fARB(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameter4fARB *c = (struct qemu_glProgramLocalParameter4fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameter4fARB( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramLocalParameter4fvARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameter4fvARB( GLenum target, GLuint index, const GLfloat *params )
{
    struct qemu_glProgramLocalParameter4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETER4FVARB);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameter4fvARB(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameter4fvARB *c = (struct qemu_glProgramLocalParameter4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameter4fvARB( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParameterI4iNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameterI4iNV( GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glProgramLocalParameterI4iNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERI4INV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameterI4iNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameterI4iNV *c = (struct qemu_glProgramLocalParameterI4iNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameterI4iNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramLocalParameterI4ivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameterI4ivNV( GLenum target, GLuint index, const GLint *params )
{
    struct qemu_glProgramLocalParameterI4ivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERI4IVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameterI4ivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameterI4ivNV *c = (struct qemu_glProgramLocalParameterI4ivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameterI4ivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParameterI4uiNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameterI4uiNV( GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
{
    struct qemu_glProgramLocalParameterI4uiNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERI4UINV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameterI4uiNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameterI4uiNV *c = (struct qemu_glProgramLocalParameterI4uiNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameterI4uiNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramLocalParameterI4uivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameterI4uivNV( GLenum target, GLuint index, const GLuint *params )
{
    struct qemu_glProgramLocalParameterI4uivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERI4UIVNV);
    call.target = target;
    call.index = index;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameterI4uivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameterI4uivNV *c = (struct qemu_glProgramLocalParameterI4uivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameterI4uivNV( c->target, c->index, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParameters4fvEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParameters4fvEXT( GLenum target, GLuint index, GLsizei count, const GLfloat *params )
{
    struct qemu_glProgramLocalParameters4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERS4FVEXT);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParameters4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParameters4fvEXT *c = (struct qemu_glProgramLocalParameters4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParameters4fvEXT( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParametersI4ivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParametersI4ivNV( GLenum target, GLuint index, GLsizei count, const GLint *params )
{
    struct qemu_glProgramLocalParametersI4ivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERSI4IVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParametersI4ivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParametersI4ivNV *c = (struct qemu_glProgramLocalParametersI4ivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParametersI4ivNV( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramLocalParametersI4uivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramLocalParametersI4uivNV( GLenum target, GLuint index, GLsizei count, const GLuint *params )
{
    struct qemu_glProgramLocalParametersI4uivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMLOCALPARAMETERSI4UIVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramLocalParametersI4uivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramLocalParametersI4uivNV *c = (struct qemu_glProgramLocalParametersI4uivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramLocalParametersI4uivNV( c->target, c->index, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramNamedParameter4dNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramNamedParameter4dNV( GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glProgramNamedParameter4dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMNAMEDPARAMETER4DNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramNamedParameter4dNV(struct qemu_syscall *call)
{
    struct qemu_glProgramNamedParameter4dNV *c = (struct qemu_glProgramNamedParameter4dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramNamedParameter4dNV( c->id, c->len, QEMU_G2H(c->name), c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramNamedParameter4dvNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramNamedParameter4dvNV( GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v )
{
    struct qemu_glProgramNamedParameter4dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMNAMEDPARAMETER4DVNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramNamedParameter4dvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramNamedParameter4dvNV *c = (struct qemu_glProgramNamedParameter4dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramNamedParameter4dvNV( c->id, c->len, QEMU_G2H(c->name), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramNamedParameter4fNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramNamedParameter4fNV( GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glProgramNamedParameter4fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMNAMEDPARAMETER4FNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramNamedParameter4fNV(struct qemu_syscall *call)
{
    struct qemu_glProgramNamedParameter4fNV *c = (struct qemu_glProgramNamedParameter4fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramNamedParameter4fNV( c->id, c->len, QEMU_G2H(c->name), c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramNamedParameter4fvNV
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t len;
    uint64_t name;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramNamedParameter4fvNV( GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v )
{
    struct qemu_glProgramNamedParameter4fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMNAMEDPARAMETER4FVNV);
    call.id = id;
    call.len = len;
    call.name = (ULONG_PTR)name;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramNamedParameter4fvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramNamedParameter4fvNV *c = (struct qemu_glProgramNamedParameter4fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramNamedParameter4fvNV( c->id, c->len, QEMU_G2H(c->name), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramParameter4dNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameter4dNV( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glProgramParameter4dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETER4DNV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameter4dNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameter4dNV *c = (struct qemu_glProgramParameter4dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameter4dNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramParameter4dvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameter4dvNV( GLenum target, GLuint index, const GLdouble *v )
{
    struct qemu_glProgramParameter4dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETER4DVNV);
    call.target = target;
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameter4dvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameter4dvNV *c = (struct qemu_glProgramParameter4dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameter4dvNV( c->target, c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramParameter4fNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameter4fNV( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glProgramParameter4fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETER4FNV);
    call.target = target;
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameter4fNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameter4fNV *c = (struct qemu_glProgramParameter4fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameter4fNV( c->target, c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramParameter4fvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameter4fvNV( GLenum target, GLuint index, const GLfloat *v )
{
    struct qemu_glProgramParameter4fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETER4FVNV);
    call.target = target;
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameter4fvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameter4fvNV *c = (struct qemu_glProgramParameter4fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameter4fvNV( c->target, c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramParameteri
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameteri( GLuint program, GLenum pname, GLint value )
{
    struct qemu_glProgramParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETERI);
    call.program = program;
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameteri(struct qemu_syscall *call)
{
    struct qemu_glProgramParameteri *c = (struct qemu_glProgramParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameteri( c->program, c->pname, c->value ));
}

#endif

struct qemu_glProgramParameteriARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameteriARB( GLuint program, GLenum pname, GLint value )
{
    struct qemu_glProgramParameteriARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETERIARB);
    call.program = program;
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameteriARB(struct qemu_syscall *call)
{
    struct qemu_glProgramParameteriARB *c = (struct qemu_glProgramParameteriARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameteriARB( c->program, c->pname, c->value ));
}

#endif

struct qemu_glProgramParameteriEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t pname;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameteriEXT( GLuint program, GLenum pname, GLint value )
{
    struct qemu_glProgramParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETERIEXT);
    call.program = program;
    call.pname = pname;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramParameteriEXT *c = (struct qemu_glProgramParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameteriEXT( c->program, c->pname, c->value ));
}

#endif

struct qemu_glProgramParameters4dvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameters4dvNV( GLenum target, GLuint index, GLsizei count, const GLdouble *v )
{
    struct qemu_glProgramParameters4dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETERS4DVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameters4dvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameters4dvNV *c = (struct qemu_glProgramParameters4dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameters4dvNV( c->target, c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramParameters4fvNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramParameters4fvNV( GLenum target, GLuint index, GLsizei count, const GLfloat *v )
{
    struct qemu_glProgramParameters4fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPARAMETERS4FVNV);
    call.target = target;
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramParameters4fvNV(struct qemu_syscall *call)
{
    struct qemu_glProgramParameters4fvNV *c = (struct qemu_glProgramParameters4fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramParameters4fvNV( c->target, c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glProgramPathFragmentInputGenNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t genMode;
    uint64_t components;
    uint64_t coeffs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramPathFragmentInputGenNV( GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs )
{
    struct qemu_glProgramPathFragmentInputGenNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMPATHFRAGMENTINPUTGENNV);
    call.program = program;
    call.location = location;
    call.genMode = genMode;
    call.components = components;
    call.coeffs = (ULONG_PTR)coeffs;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramPathFragmentInputGenNV(struct qemu_syscall *call)
{
    struct qemu_glProgramPathFragmentInputGenNV *c = (struct qemu_glProgramPathFragmentInputGenNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramPathFragmentInputGenNV( c->program, c->location, c->genMode, c->components, QEMU_G2H(c->coeffs) ));
}

#endif

struct qemu_glProgramStringARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t format;
    uint64_t len;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramStringARB( GLenum target, GLenum format, GLsizei len, const void *string )
{
    struct qemu_glProgramStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMSTRINGARB);
    call.target = target;
    call.format = format;
    call.len = len;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramStringARB(struct qemu_syscall *call)
{
    struct qemu_glProgramStringARB *c = (struct qemu_glProgramStringARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramStringARB( c->target, c->format, c->len, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glProgramSubroutineParametersuivNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t count;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramSubroutineParametersuivNV( GLenum target, GLsizei count, const GLuint *params )
{
    struct qemu_glProgramSubroutineParametersuivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMSUBROUTINEPARAMETERSUIVNV);
    call.target = target;
    call.count = count;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramSubroutineParametersuivNV(struct qemu_syscall *call)
{
    struct qemu_glProgramSubroutineParametersuivNV *c = (struct qemu_glProgramSubroutineParametersuivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramSubroutineParametersuivNV( c->target, c->count, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glProgramUniform1d
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1d( GLuint program, GLint location, GLdouble v0 )
{
    struct qemu_glProgramUniform1d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1D);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1d(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1d *c = (struct qemu_glProgramUniform1d *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1d( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1dEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1dEXT( GLuint program, GLint location, GLdouble x )
{
    struct qemu_glProgramUniform1dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1DEXT);
    call.program = program;
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1dEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1dEXT *c = (struct qemu_glProgramUniform1dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1dEXT( c->program, c->location, c->x ));
}

#endif

struct qemu_glProgramUniform1dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1dv( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform1dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1dv *c = (struct qemu_glProgramUniform1dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1dv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1dvEXT( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform1dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1dvEXT *c = (struct qemu_glProgramUniform1dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1dvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1f
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1f( GLuint program, GLint location, GLfloat v0 )
{
    struct qemu_glProgramUniform1f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1F);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1f(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1f *c = (struct qemu_glProgramUniform1f *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1f( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1fEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1fEXT( GLuint program, GLint location, GLfloat v0 )
{
    struct qemu_glProgramUniform1fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1FEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1fEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1fEXT *c = (struct qemu_glProgramUniform1fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1fEXT( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1fv( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform1fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1fv *c = (struct qemu_glProgramUniform1fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1fv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1fvEXT( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform1fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1fvEXT *c = (struct qemu_glProgramUniform1fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1fvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1i
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1i( GLuint program, GLint location, GLint v0 )
{
    struct qemu_glProgramUniform1i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1I);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1i(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1i *c = (struct qemu_glProgramUniform1i *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1i( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1i64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1i64ARB( GLuint program, GLint location, GLint64 x )
{
    struct qemu_glProgramUniform1i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1I64ARB);
    call.program = program;
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1i64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1i64ARB *c = (struct qemu_glProgramUniform1i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1i64ARB( c->program, c->location, c->x ));
}

#endif

struct qemu_glProgramUniform1i64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1i64NV( GLuint program, GLint location, GLint64EXT x )
{
    struct qemu_glProgramUniform1i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1I64NV);
    call.program = program;
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1i64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1i64NV *c = (struct qemu_glProgramUniform1i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1i64NV( c->program, c->location, c->x ));
}

#endif

struct qemu_glProgramUniform1i64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1i64vARB( GLuint program, GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glProgramUniform1i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1I64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1i64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1i64vARB *c = (struct qemu_glProgramUniform1i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1i64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1i64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1i64vNV( GLuint program, GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glProgramUniform1i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1I64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1i64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1i64vNV *c = (struct qemu_glProgramUniform1i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1i64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1iEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1iEXT( GLuint program, GLint location, GLint v0 )
{
    struct qemu_glProgramUniform1iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1IEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1iEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1iEXT *c = (struct qemu_glProgramUniform1iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1iEXT( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1iv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1iv( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform1iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1IV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1iv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1iv *c = (struct qemu_glProgramUniform1iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1iv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ivEXT( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform1ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1IVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ivEXT *c = (struct qemu_glProgramUniform1ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1ui
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ui( GLuint program, GLint location, GLuint v0 )
{
    struct qemu_glProgramUniform1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UI);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ui(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ui *c = (struct qemu_glProgramUniform1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ui( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1ui64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ui64ARB( GLuint program, GLint location, GLuint64 x )
{
    struct qemu_glProgramUniform1ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UI64ARB);
    call.program = program;
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ui64ARB *c = (struct qemu_glProgramUniform1ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ui64ARB( c->program, c->location, c->x ));
}

#endif

struct qemu_glProgramUniform1ui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ui64NV( GLuint program, GLint location, GLuint64EXT x )
{
    struct qemu_glProgramUniform1ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UI64NV);
    call.program = program;
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ui64NV *c = (struct qemu_glProgramUniform1ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ui64NV( c->program, c->location, c->x ));
}

#endif

struct qemu_glProgramUniform1ui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ui64vARB( GLuint program, GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glProgramUniform1ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UI64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ui64vARB *c = (struct qemu_glProgramUniform1ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ui64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1ui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1ui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glProgramUniform1ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1ui64vNV *c = (struct qemu_glProgramUniform1ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1ui64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1uiEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1uiEXT( GLuint program, GLint location, GLuint v0 )
{
    struct qemu_glProgramUniform1uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UIEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1uiEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1uiEXT *c = (struct qemu_glProgramUniform1uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1uiEXT( c->program, c->location, c->v0 ));
}

#endif

struct qemu_glProgramUniform1uiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1uiv( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UIV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1uiv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1uiv *c = (struct qemu_glProgramUniform1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1uiv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform1uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform1uivEXT( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform1uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM1UIVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform1uivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform1uivEXT *c = (struct qemu_glProgramUniform1uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform1uivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2d
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2d( GLuint program, GLint location, GLdouble v0, GLdouble v1 )
{
    struct qemu_glProgramUniform2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2D);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2d(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2d *c = (struct qemu_glProgramUniform2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2d( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2dEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2dEXT( GLuint program, GLint location, GLdouble x, GLdouble y )
{
    struct qemu_glProgramUniform2dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2DEXT);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2dEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2dEXT *c = (struct qemu_glProgramUniform2dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2dEXT( c->program, c->location, c->x, c->y ));
}

#endif

struct qemu_glProgramUniform2dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2dv( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2dv *c = (struct qemu_glProgramUniform2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2dv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2dvEXT( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform2dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2dvEXT *c = (struct qemu_glProgramUniform2dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2dvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2f
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2f( GLuint program, GLint location, GLfloat v0, GLfloat v1 )
{
    struct qemu_glProgramUniform2f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2F);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2f(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2f *c = (struct qemu_glProgramUniform2f *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2f( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2fEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2fEXT( GLuint program, GLint location, GLfloat v0, GLfloat v1 )
{
    struct qemu_glProgramUniform2fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2FEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2fEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2fEXT *c = (struct qemu_glProgramUniform2fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2fEXT( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2fv( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2fv *c = (struct qemu_glProgramUniform2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2fv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2fvEXT( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform2fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2fvEXT *c = (struct qemu_glProgramUniform2fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2fvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2i
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2i( GLuint program, GLint location, GLint v0, GLint v1 )
{
    struct qemu_glProgramUniform2i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2I);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2i(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2i *c = (struct qemu_glProgramUniform2i *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2i( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2i64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2i64ARB( GLuint program, GLint location, GLint64 x, GLint64 y )
{
    struct qemu_glProgramUniform2i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2I64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2i64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2i64ARB *c = (struct qemu_glProgramUniform2i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2i64ARB( c->program, c->location, c->x, c->y ));
}

#endif

struct qemu_glProgramUniform2i64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2i64NV( GLuint program, GLint location, GLint64EXT x, GLint64EXT y )
{
    struct qemu_glProgramUniform2i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2I64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2i64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2i64NV *c = (struct qemu_glProgramUniform2i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2i64NV( c->program, c->location, c->x, c->y ));
}

#endif

struct qemu_glProgramUniform2i64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2i64vARB( GLuint program, GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glProgramUniform2i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2I64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2i64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2i64vARB *c = (struct qemu_glProgramUniform2i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2i64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2i64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2i64vNV( GLuint program, GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glProgramUniform2i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2I64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2i64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2i64vNV *c = (struct qemu_glProgramUniform2i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2i64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2iEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2iEXT( GLuint program, GLint location, GLint v0, GLint v1 )
{
    struct qemu_glProgramUniform2iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2IEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2iEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2iEXT *c = (struct qemu_glProgramUniform2iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2iEXT( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2iv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2iv( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform2iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2IV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2iv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2iv *c = (struct qemu_glProgramUniform2iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2iv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ivEXT( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform2ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2IVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ivEXT *c = (struct qemu_glProgramUniform2ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2ui
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ui( GLuint program, GLint location, GLuint v0, GLuint v1 )
{
    struct qemu_glProgramUniform2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UI);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ui(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ui *c = (struct qemu_glProgramUniform2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ui( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2ui64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ui64ARB( GLuint program, GLint location, GLuint64 x, GLuint64 y )
{
    struct qemu_glProgramUniform2ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UI64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ui64ARB *c = (struct qemu_glProgramUniform2ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ui64ARB( c->program, c->location, c->x, c->y ));
}

#endif

struct qemu_glProgramUniform2ui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ui64NV( GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y )
{
    struct qemu_glProgramUniform2ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UI64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ui64NV *c = (struct qemu_glProgramUniform2ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ui64NV( c->program, c->location, c->x, c->y ));
}

#endif

struct qemu_glProgramUniform2ui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ui64vARB( GLuint program, GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glProgramUniform2ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UI64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ui64vARB *c = (struct qemu_glProgramUniform2ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ui64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2ui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2ui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glProgramUniform2ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2ui64vNV *c = (struct qemu_glProgramUniform2ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2ui64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2uiEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2uiEXT( GLuint program, GLint location, GLuint v0, GLuint v1 )
{
    struct qemu_glProgramUniform2uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UIEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2uiEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2uiEXT *c = (struct qemu_glProgramUniform2uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2uiEXT( c->program, c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glProgramUniform2uiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2uiv( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UIV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2uiv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2uiv *c = (struct qemu_glProgramUniform2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2uiv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform2uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform2uivEXT( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform2uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM2UIVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform2uivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform2uivEXT *c = (struct qemu_glProgramUniform2uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform2uivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3d
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3d( GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2 )
{
    struct qemu_glProgramUniform3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3D);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3d(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3d *c = (struct qemu_glProgramUniform3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3d( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3dEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3dEXT( GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glProgramUniform3dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3DEXT);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3dEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3dEXT *c = (struct qemu_glProgramUniform3dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3dEXT( c->program, c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glProgramUniform3dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3dv( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3dv *c = (struct qemu_glProgramUniform3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3dv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3dvEXT( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3dvEXT *c = (struct qemu_glProgramUniform3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3dvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3f
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3f( GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2 )
{
    struct qemu_glProgramUniform3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3F);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3f(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3f *c = (struct qemu_glProgramUniform3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3f( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3fEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3fEXT( GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2 )
{
    struct qemu_glProgramUniform3fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3FEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3fEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3fEXT *c = (struct qemu_glProgramUniform3fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3fEXT( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3fv( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3fv *c = (struct qemu_glProgramUniform3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3fv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3fvEXT( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3fvEXT *c = (struct qemu_glProgramUniform3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3fvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3i
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3i( GLuint program, GLint location, GLint v0, GLint v1, GLint v2 )
{
    struct qemu_glProgramUniform3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3I);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3i(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3i *c = (struct qemu_glProgramUniform3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3i( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3i64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3i64ARB( GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z )
{
    struct qemu_glProgramUniform3i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3I64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3i64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3i64ARB *c = (struct qemu_glProgramUniform3i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3i64ARB( c->program, c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glProgramUniform3i64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3i64NV( GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z )
{
    struct qemu_glProgramUniform3i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3I64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3i64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3i64NV *c = (struct qemu_glProgramUniform3i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3i64NV( c->program, c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glProgramUniform3i64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3i64vARB( GLuint program, GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glProgramUniform3i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3I64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3i64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3i64vARB *c = (struct qemu_glProgramUniform3i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3i64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3i64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3i64vNV( GLuint program, GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glProgramUniform3i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3I64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3i64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3i64vNV *c = (struct qemu_glProgramUniform3i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3i64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3iEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3iEXT( GLuint program, GLint location, GLint v0, GLint v1, GLint v2 )
{
    struct qemu_glProgramUniform3iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3IEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3iEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3iEXT *c = (struct qemu_glProgramUniform3iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3iEXT( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3iv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3iv( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3IV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3iv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3iv *c = (struct qemu_glProgramUniform3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3iv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ivEXT( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform3ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3IVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ivEXT *c = (struct qemu_glProgramUniform3ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3ui
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ui( GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2 )
{
    struct qemu_glProgramUniform3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UI);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ui(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ui *c = (struct qemu_glProgramUniform3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ui( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3ui64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ui64ARB( GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z )
{
    struct qemu_glProgramUniform3ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UI64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ui64ARB *c = (struct qemu_glProgramUniform3ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ui64ARB( c->program, c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glProgramUniform3ui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ui64NV( GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z )
{
    struct qemu_glProgramUniform3ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UI64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ui64NV *c = (struct qemu_glProgramUniform3ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ui64NV( c->program, c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glProgramUniform3ui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ui64vARB( GLuint program, GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glProgramUniform3ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UI64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ui64vARB *c = (struct qemu_glProgramUniform3ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ui64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3ui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3ui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glProgramUniform3ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3ui64vNV *c = (struct qemu_glProgramUniform3ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3ui64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3uiEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3uiEXT( GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2 )
{
    struct qemu_glProgramUniform3uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UIEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3uiEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3uiEXT *c = (struct qemu_glProgramUniform3uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3uiEXT( c->program, c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glProgramUniform3uiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3uiv( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UIV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3uiv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3uiv *c = (struct qemu_glProgramUniform3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3uiv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform3uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform3uivEXT( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform3uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM3UIVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform3uivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform3uivEXT *c = (struct qemu_glProgramUniform3uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform3uivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4d
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
    double v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4d( GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3 )
{
    struct qemu_glProgramUniform4d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4D);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4d(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4d *c = (struct qemu_glProgramUniform4d *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4d( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4dEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4dEXT( GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glProgramUniform4dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4DEXT);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4dEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4dEXT *c = (struct qemu_glProgramUniform4dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4dEXT( c->program, c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramUniform4dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4dv( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4dv *c = (struct qemu_glProgramUniform4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4dv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4dvEXT( GLuint program, GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glProgramUniform4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4dvEXT *c = (struct qemu_glProgramUniform4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4dvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4f
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
    double v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4f( GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 )
{
    struct qemu_glProgramUniform4f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4F);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4f(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4f *c = (struct qemu_glProgramUniform4f *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4f( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4fEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    double v0;
    double v1;
    double v2;
    double v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4fEXT( GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 )
{
    struct qemu_glProgramUniform4fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4FEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4fEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4fEXT *c = (struct qemu_glProgramUniform4fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4fEXT( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4fv( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4fv *c = (struct qemu_glProgramUniform4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4fv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4fvEXT( GLuint program, GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glProgramUniform4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4fvEXT *c = (struct qemu_glProgramUniform4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4fvEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4i
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4i( GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3 )
{
    struct qemu_glProgramUniform4i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4I);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4i(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4i *c = (struct qemu_glProgramUniform4i *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4i( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4i64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4i64ARB( GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w )
{
    struct qemu_glProgramUniform4i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4I64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4i64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4i64ARB *c = (struct qemu_glProgramUniform4i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4i64ARB( c->program, c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramUniform4i64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4i64NV( GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w )
{
    struct qemu_glProgramUniform4i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4I64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4i64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4i64NV *c = (struct qemu_glProgramUniform4i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4i64NV( c->program, c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramUniform4i64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4i64vARB( GLuint program, GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glProgramUniform4i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4I64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4i64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4i64vARB *c = (struct qemu_glProgramUniform4i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4i64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4i64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4i64vNV( GLuint program, GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glProgramUniform4i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4I64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4i64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4i64vNV *c = (struct qemu_glProgramUniform4i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4i64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4iEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4iEXT( GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3 )
{
    struct qemu_glProgramUniform4iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4IEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4iEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4iEXT *c = (struct qemu_glProgramUniform4iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4iEXT( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4iv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4iv( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform4iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4IV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4iv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4iv *c = (struct qemu_glProgramUniform4iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4iv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4ivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ivEXT( GLuint program, GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glProgramUniform4ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4IVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ivEXT *c = (struct qemu_glProgramUniform4ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4ui
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ui( GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 )
{
    struct qemu_glProgramUniform4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UI);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ui(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ui *c = (struct qemu_glProgramUniform4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ui( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4ui64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ui64ARB( GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w )
{
    struct qemu_glProgramUniform4ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UI64ARB);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ui64ARB *c = (struct qemu_glProgramUniform4ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ui64ARB( c->program, c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramUniform4ui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ui64NV( GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w )
{
    struct qemu_glProgramUniform4ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UI64NV);
    call.program = program;
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ui64NV *c = (struct qemu_glProgramUniform4ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ui64NV( c->program, c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glProgramUniform4ui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ui64vARB( GLuint program, GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glProgramUniform4ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UI64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ui64vARB *c = (struct qemu_glProgramUniform4ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ui64vARB( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4ui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4ui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glProgramUniform4ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4ui64vNV *c = (struct qemu_glProgramUniform4ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4ui64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4uiEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4uiEXT( GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 )
{
    struct qemu_glProgramUniform4uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UIEXT);
    call.program = program;
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4uiEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4uiEXT *c = (struct qemu_glProgramUniform4uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4uiEXT( c->program, c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glProgramUniform4uiv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4uiv( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UIV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4uiv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4uiv *c = (struct qemu_glProgramUniform4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4uiv( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniform4uivEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniform4uivEXT( GLuint program, GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glProgramUniform4uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORM4UIVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniform4uivEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniform4uivEXT *c = (struct qemu_glProgramUniform4uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniform4uivEXT( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformHandleui64ARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformHandleui64ARB( GLuint program, GLint location, GLuint64 value )
{
    struct qemu_glProgramUniformHandleui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMHANDLEUI64ARB);
    call.program = program;
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformHandleui64ARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformHandleui64ARB *c = (struct qemu_glProgramUniformHandleui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformHandleui64ARB( c->program, c->location, c->value ));
}

#endif

struct qemu_glProgramUniformHandleui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformHandleui64NV( GLuint program, GLint location, GLuint64 value )
{
    struct qemu_glProgramUniformHandleui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMHANDLEUI64NV);
    call.program = program;
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformHandleui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformHandleui64NV *c = (struct qemu_glProgramUniformHandleui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformHandleui64NV( c->program, c->location, c->value ));
}

#endif

struct qemu_glProgramUniformHandleui64vARB
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformHandleui64vARB( GLuint program, GLint location, GLsizei count, const GLuint64 *values )
{
    struct qemu_glProgramUniformHandleui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMHANDLEUI64VARB);
    call.program = program;
    call.location = location;
    call.count = count;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformHandleui64vARB(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformHandleui64vARB *c = (struct qemu_glProgramUniformHandleui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformHandleui64vARB( c->program, c->location, c->count, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glProgramUniformHandleui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformHandleui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64 *values )
{
    struct qemu_glProgramUniformHandleui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMHANDLEUI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformHandleui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformHandleui64vNV *c = (struct qemu_glProgramUniformHandleui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformHandleui64vNV( c->program, c->location, c->count, QEMU_G2H(c->values) ));
}

#endif

struct qemu_glProgramUniformMatrix2dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2dv *c = (struct qemu_glProgramUniformMatrix2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2dvEXT *c = (struct qemu_glProgramUniformMatrix2dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2fv *c = (struct qemu_glProgramUniformMatrix2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2fvEXT *c = (struct qemu_glProgramUniformMatrix2fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x3dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x3dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2x3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X3DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x3dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x3dv *c = (struct qemu_glProgramUniformMatrix2x3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x3dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x3dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x3dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2x3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X3DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x3dvEXT *c = (struct qemu_glProgramUniformMatrix2x3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x3dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x3fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x3fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2x3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X3FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x3fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x3fv *c = (struct qemu_glProgramUniformMatrix2x3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x3fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x3fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x3fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2x3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X3FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x3fvEXT *c = (struct qemu_glProgramUniformMatrix2x3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x3fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x4dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x4dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2x4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X4DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x4dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x4dv *c = (struct qemu_glProgramUniformMatrix2x4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x4dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x4dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x4dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix2x4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X4DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x4dvEXT *c = (struct qemu_glProgramUniformMatrix2x4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x4dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x4fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x4fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2x4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X4FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x4fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x4fv *c = (struct qemu_glProgramUniformMatrix2x4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x4fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix2x4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix2x4fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix2x4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX2X4FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix2x4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix2x4fvEXT *c = (struct qemu_glProgramUniformMatrix2x4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix2x4fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3dv *c = (struct qemu_glProgramUniformMatrix3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3dvEXT *c = (struct qemu_glProgramUniformMatrix3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3fv *c = (struct qemu_glProgramUniformMatrix3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3fvEXT *c = (struct qemu_glProgramUniformMatrix3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x2dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x2dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3x2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X2DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x2dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x2dv *c = (struct qemu_glProgramUniformMatrix3x2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x2dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x2dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x2dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3x2dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X2DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x2dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x2dvEXT *c = (struct qemu_glProgramUniformMatrix3x2dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x2dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x2fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x2fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3x2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X2FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x2fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x2fv *c = (struct qemu_glProgramUniformMatrix3x2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x2fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x2fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x2fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3x2fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X2FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x2fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x2fvEXT *c = (struct qemu_glProgramUniformMatrix3x2fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x2fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x4dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x4dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3x4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X4DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x4dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x4dv *c = (struct qemu_glProgramUniformMatrix3x4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x4dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x4dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x4dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix3x4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X4DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x4dvEXT *c = (struct qemu_glProgramUniformMatrix3x4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x4dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x4fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x4fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3x4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X4FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x4fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x4fv *c = (struct qemu_glProgramUniformMatrix3x4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x4fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix3x4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix3x4fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix3x4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX3X4FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix3x4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix3x4fvEXT *c = (struct qemu_glProgramUniformMatrix3x4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix3x4fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4dv *c = (struct qemu_glProgramUniformMatrix4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4dvEXT *c = (struct qemu_glProgramUniformMatrix4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4fv *c = (struct qemu_glProgramUniformMatrix4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4fvEXT *c = (struct qemu_glProgramUniformMatrix4fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x2dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x2dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4x2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X2DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x2dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x2dv *c = (struct qemu_glProgramUniformMatrix4x2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x2dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x2dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x2dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4x2dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X2DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x2dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x2dvEXT *c = (struct qemu_glProgramUniformMatrix4x2dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x2dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x2fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x2fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4x2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X2FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x2fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x2fv *c = (struct qemu_glProgramUniformMatrix4x2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x2fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x2fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x2fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4x2fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X2FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x2fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x2fvEXT *c = (struct qemu_glProgramUniformMatrix4x2fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x2fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x3dv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x3dv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4x3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X3DV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x3dv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x3dv *c = (struct qemu_glProgramUniformMatrix4x3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x3dv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x3dvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x3dvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glProgramUniformMatrix4x3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X3DVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x3dvEXT *c = (struct qemu_glProgramUniformMatrix4x3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x3dvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x3fv
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x3fv( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4x3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X3FV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x3fv(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x3fv *c = (struct qemu_glProgramUniformMatrix4x3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x3fv( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformMatrix4x3fvEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformMatrix4x3fvEXT( GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glProgramUniformMatrix4x3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMMATRIX4X3FVEXT);
    call.program = program;
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformMatrix4x3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformMatrix4x3fvEXT *c = (struct qemu_glProgramUniformMatrix4x3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformMatrix4x3fvEXT( c->program, c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramUniformui64NV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformui64NV( GLuint program, GLint location, GLuint64EXT value )
{
    struct qemu_glProgramUniformui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMUI64NV);
    call.program = program;
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformui64NV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformui64NV *c = (struct qemu_glProgramUniformui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformui64NV( c->program, c->location, c->value ));
}

#endif

struct qemu_glProgramUniformui64vNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramUniformui64vNV( GLuint program, GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glProgramUniformui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMUNIFORMUI64VNV);
    call.program = program;
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramUniformui64vNV(struct qemu_syscall *call)
{
    struct qemu_glProgramUniformui64vNV *c = (struct qemu_glProgramUniformui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramUniformui64vNV( c->program, c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glProgramVertexLimitNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t limit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProgramVertexLimitNV( GLenum target, GLint limit )
{
    struct qemu_glProgramVertexLimitNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROGRAMVERTEXLIMITNV);
    call.target = target;
    call.limit = limit;

    qemu_syscall(&call.super);
}

#else

void qemu_glProgramVertexLimitNV(struct qemu_syscall *call)
{
    struct qemu_glProgramVertexLimitNV *c = (struct qemu_glProgramVertexLimitNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glProgramVertexLimitNV( c->target, c->limit ));
}

#endif

struct qemu_glProvokingVertex
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProvokingVertex( GLenum mode )
{
    struct qemu_glProvokingVertex call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROVOKINGVERTEX);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glProvokingVertex(struct qemu_syscall *call)
{
    struct qemu_glProvokingVertex *c = (struct qemu_glProvokingVertex *)call;
    WINE_FIXME("Unverified\n");
    (p_glProvokingVertex( c->mode ));
}

#endif

struct qemu_glProvokingVertexEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glProvokingVertexEXT( GLenum mode )
{
    struct qemu_glProvokingVertexEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPROVOKINGVERTEXEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glProvokingVertexEXT(struct qemu_syscall *call)
{
    struct qemu_glProvokingVertexEXT *c = (struct qemu_glProvokingVertexEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glProvokingVertexEXT( c->mode ));
}

#endif

struct qemu_glPushClientAttribDefaultEXT
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPushClientAttribDefaultEXT( GLbitfield mask )
{
    struct qemu_glPushClientAttribDefaultEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPUSHCLIENTATTRIBDEFAULTEXT);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glPushClientAttribDefaultEXT(struct qemu_syscall *call)
{
    struct qemu_glPushClientAttribDefaultEXT *c = (struct qemu_glPushClientAttribDefaultEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPushClientAttribDefaultEXT( c->mask ));
}

#endif

struct qemu_glPushDebugGroup
{
    struct qemu_syscall super;
    uint64_t source;
    uint64_t id;
    uint64_t length;
    uint64_t message;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPushDebugGroup( GLenum source, GLuint id, GLsizei length, const GLchar *message )
{
    struct qemu_glPushDebugGroup call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPUSHDEBUGGROUP);
    call.source = source;
    call.id = id;
    call.length = length;
    call.message = (ULONG_PTR)message;

    qemu_syscall(&call.super);
}

#else

void qemu_glPushDebugGroup(struct qemu_syscall *call)
{
    struct qemu_glPushDebugGroup *c = (struct qemu_glPushDebugGroup *)call;
    WINE_FIXME("Unverified\n");
    (p_glPushDebugGroup( c->source, c->id, c->length, QEMU_G2H(c->message) ));
}

#endif

struct qemu_glPushGroupMarkerEXT
{
    struct qemu_syscall super;
    uint64_t length;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glPushGroupMarkerEXT( GLsizei length, const GLchar *marker )
{
    struct qemu_glPushGroupMarkerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLPUSHGROUPMARKEREXT);
    call.length = length;
    call.marker = (ULONG_PTR)marker;

    qemu_syscall(&call.super);
}

#else

void qemu_glPushGroupMarkerEXT(struct qemu_syscall *call)
{
    struct qemu_glPushGroupMarkerEXT *c = (struct qemu_glPushGroupMarkerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glPushGroupMarkerEXT( c->length, QEMU_G2H(c->marker) ));
}

#endif

struct qemu_glQueryCounter
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glQueryCounter( GLuint id, GLenum target )
{
    struct qemu_glQueryCounter call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLQUERYCOUNTER);
    call.id = id;
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glQueryCounter(struct qemu_syscall *call)
{
    struct qemu_glQueryCounter *c = (struct qemu_glQueryCounter *)call;
    WINE_FIXME("Unverified\n");
    (p_glQueryCounter( c->id, c->target ));
}

#endif

struct qemu_glQueryMatrixxOES
{
    struct qemu_syscall super;
    uint64_t mantissa;
    uint64_t exponent;
};

#ifdef QEMU_DLL_GUEST

GLbitfield WINAPI glQueryMatrixxOES( GLfixed *mantissa, GLint *exponent )
{
    struct qemu_glQueryMatrixxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLQUERYMATRIXXOES);
    call.mantissa = (ULONG_PTR)mantissa;
    call.exponent = (ULONG_PTR)exponent;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glQueryMatrixxOES(struct qemu_syscall *call)
{
    struct qemu_glQueryMatrixxOES *c = (struct qemu_glQueryMatrixxOES *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glQueryMatrixxOES( QEMU_G2H(c->mantissa), QEMU_G2H(c->exponent) ));
}

#endif

struct qemu_glQueryObjectParameteruiAMD
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t id;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glQueryObjectParameteruiAMD( GLenum target, GLuint id, GLenum pname, GLuint param )
{
    struct qemu_glQueryObjectParameteruiAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLQUERYOBJECTPARAMETERUIAMD);
    call.target = target;
    call.id = id;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glQueryObjectParameteruiAMD(struct qemu_syscall *call)
{
    struct qemu_glQueryObjectParameteruiAMD *c = (struct qemu_glQueryObjectParameteruiAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glQueryObjectParameteruiAMD( c->target, c->id, c->pname, c->param ));
}

#endif

struct qemu_glQueryResourceNV
{
    struct qemu_syscall super;
    uint64_t queryType;
    uint64_t tagId;
    uint64_t count;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLint WINAPI glQueryResourceNV( GLenum queryType, GLint tagId, GLuint count, GLint *buffer )
{
    struct qemu_glQueryResourceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLQUERYRESOURCENV);
    call.queryType = queryType;
    call.tagId = tagId;
    call.count = count;
    call.buffer = (ULONG_PTR)buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glQueryResourceNV(struct qemu_syscall *call)
{
    struct qemu_glQueryResourceNV *c = (struct qemu_glQueryResourceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glQueryResourceNV( c->queryType, c->tagId, c->count, QEMU_G2H(c->buffer) ));
}

#endif

struct qemu_glQueryResourceTagNV
{
    struct qemu_syscall super;
    uint64_t tagId;
    uint64_t tagString;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glQueryResourceTagNV( GLint tagId, const GLchar *tagString )
{
    struct qemu_glQueryResourceTagNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLQUERYRESOURCETAGNV);
    call.tagId = tagId;
    call.tagString = (ULONG_PTR)tagString;

    qemu_syscall(&call.super);
}

#else

void qemu_glQueryResourceTagNV(struct qemu_syscall *call)
{
    struct qemu_glQueryResourceTagNV *c = (struct qemu_glQueryResourceTagNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glQueryResourceTagNV( c->tagId, QEMU_G2H(c->tagString) ));
}

#endif

struct qemu_glRasterPos2xOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos2xOES( GLfixed x, GLfixed y )
{
    struct qemu_glRasterPos2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS2XOES);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos2xOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos2xOES *c = (struct qemu_glRasterPos2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos2xOES( c->x, c->y ));
}

#endif

struct qemu_glRasterPos2xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos2xvOES( const GLfixed *coords )
{
    struct qemu_glRasterPos2xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS2XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos2xvOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos2xvOES *c = (struct qemu_glRasterPos2xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos2xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glRasterPos3xOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos3xOES( GLfixed x, GLfixed y, GLfixed z )
{
    struct qemu_glRasterPos3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS3XOES);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos3xOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos3xOES *c = (struct qemu_glRasterPos3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos3xOES( c->x, c->y, c->z ));
}

#endif

struct qemu_glRasterPos3xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos3xvOES( const GLfixed *coords )
{
    struct qemu_glRasterPos3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS3XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos3xvOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos3xvOES *c = (struct qemu_glRasterPos3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos3xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glRasterPos4xOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos4xOES( GLfixed x, GLfixed y, GLfixed z, GLfixed w )
{
    struct qemu_glRasterPos4xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS4XOES);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos4xOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos4xOES *c = (struct qemu_glRasterPos4xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos4xOES( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glRasterPos4xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterPos4xvOES( const GLfixed *coords )
{
    struct qemu_glRasterPos4xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERPOS4XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterPos4xvOES(struct qemu_syscall *call)
{
    struct qemu_glRasterPos4xvOES *c = (struct qemu_glRasterPos4xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterPos4xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glRasterSamplesEXT
{
    struct qemu_syscall super;
    uint64_t samples;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRasterSamplesEXT( GLuint samples, GLboolean fixedsamplelocations )
{
    struct qemu_glRasterSamplesEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRASTERSAMPLESEXT);
    call.samples = samples;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glRasterSamplesEXT(struct qemu_syscall *call)
{
    struct qemu_glRasterSamplesEXT *c = (struct qemu_glRasterSamplesEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glRasterSamplesEXT( c->samples, c->fixedsamplelocations ));
}

#endif

struct qemu_glReadBufferRegion
{
    struct qemu_syscall super;
    uint64_t region;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReadBufferRegion( GLenum region, GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glReadBufferRegion call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREADBUFFERREGION);
    call.region = region;
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glReadBufferRegion(struct qemu_syscall *call)
{
    struct qemu_glReadBufferRegion *c = (struct qemu_glReadBufferRegion *)call;
    WINE_FIXME("Unverified\n");
    (p_glReadBufferRegion( c->region, c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glReadInstrumentsSGIX
{
    struct qemu_syscall super;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReadInstrumentsSGIX( GLint marker )
{
    struct qemu_glReadInstrumentsSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREADINSTRUMENTSSGIX);
    call.marker = marker;

    qemu_syscall(&call.super);
}

#else

void qemu_glReadInstrumentsSGIX(struct qemu_syscall *call)
{
    struct qemu_glReadInstrumentsSGIX *c = (struct qemu_glReadInstrumentsSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glReadInstrumentsSGIX( c->marker ));
}

#endif

struct qemu_glReadnPixels
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReadnPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data )
{
    struct qemu_glReadnPixels call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREADNPIXELS);
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glReadnPixels(struct qemu_syscall *call)
{
    struct qemu_glReadnPixels *c = (struct qemu_glReadnPixels *)call;
    WINE_FIXME("Unverified\n");
    (p_glReadnPixels( c->x, c->y, c->width, c->height, c->format, c->type, c->bufSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glReadnPixelsARB
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t bufSize;
    uint64_t data;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReadnPixelsARB( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data )
{
    struct qemu_glReadnPixelsARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREADNPIXELSARB);
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.bufSize = bufSize;
    call.data = (ULONG_PTR)data;

    qemu_syscall(&call.super);
}

#else

void qemu_glReadnPixelsARB(struct qemu_syscall *call)
{
    struct qemu_glReadnPixelsARB *c = (struct qemu_glReadnPixelsARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glReadnPixelsARB( c->x, c->y, c->width, c->height, c->format, c->type, c->bufSize, QEMU_G2H(c->data) ));
}

#endif

struct qemu_glRectxOES
{
    struct qemu_syscall super;
    uint64_t x1;
    uint64_t y1;
    uint64_t x2;
    uint64_t y2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRectxOES( GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2 )
{
    struct qemu_glRectxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRECTXOES);
    call.x1 = x1;
    call.y1 = y1;
    call.x2 = x2;
    call.y2 = y2;

    qemu_syscall(&call.super);
}

#else

void qemu_glRectxOES(struct qemu_syscall *call)
{
    struct qemu_glRectxOES *c = (struct qemu_glRectxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRectxOES( c->x1, c->y1, c->x2, c->y2 ));
}

#endif

struct qemu_glRectxvOES
{
    struct qemu_syscall super;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRectxvOES( const GLfixed *v1, const GLfixed *v2 )
{
    struct qemu_glRectxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRECTXVOES);
    call.v1 = (ULONG_PTR)v1;
    call.v2 = (ULONG_PTR)v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glRectxvOES(struct qemu_syscall *call)
{
    struct qemu_glRectxvOES *c = (struct qemu_glRectxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRectxvOES( QEMU_G2H(c->v1), QEMU_G2H(c->v2) ));
}

#endif

struct qemu_glReferencePlaneSGIX
{
    struct qemu_syscall super;
    uint64_t equation;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReferencePlaneSGIX( const GLdouble *equation )
{
    struct qemu_glReferencePlaneSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREFERENCEPLANESGIX);
    call.equation = (ULONG_PTR)equation;

    qemu_syscall(&call.super);
}

#else

void qemu_glReferencePlaneSGIX(struct qemu_syscall *call)
{
    struct qemu_glReferencePlaneSGIX *c = (struct qemu_glReferencePlaneSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glReferencePlaneSGIX( QEMU_G2H(c->equation) ));
}

#endif

struct qemu_glReleaseKeyedMutexWin32EXT
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t key;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glReleaseKeyedMutexWin32EXT( GLuint memory, GLuint64 key )
{
    struct qemu_glReleaseKeyedMutexWin32EXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRELEASEKEYEDMUTEXWIN32EXT);
    call.memory = memory;
    call.key = key;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glReleaseKeyedMutexWin32EXT(struct qemu_syscall *call)
{
    struct qemu_glReleaseKeyedMutexWin32EXT *c = (struct qemu_glReleaseKeyedMutexWin32EXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glReleaseKeyedMutexWin32EXT( c->memory, c->key ));
}

#endif

struct qemu_glReleaseShaderCompiler
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReleaseShaderCompiler(void)
{
    struct qemu_glReleaseShaderCompiler call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRELEASESHADERCOMPILER);

    qemu_syscall(&call.super);
}

#else

void qemu_glReleaseShaderCompiler(struct qemu_syscall *call)
{
    struct qemu_glReleaseShaderCompiler *c = (struct qemu_glReleaseShaderCompiler *)call;
    WINE_FIXME("Unverified\n");
    (p_glReleaseShaderCompiler());
}

#endif

struct qemu_glRenderGpuMaskNV
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderGpuMaskNV( GLbitfield mask )
{
    struct qemu_glRenderGpuMaskNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERGPUMASKNV);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderGpuMaskNV(struct qemu_syscall *call)
{
    struct qemu_glRenderGpuMaskNV *c = (struct qemu_glRenderGpuMaskNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderGpuMaskNV( c->mask ));
}

#endif

struct qemu_glRenderbufferStorage
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorage( GLenum target, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGE);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorage(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorage *c = (struct qemu_glRenderbufferStorage *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorage( c->target, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glRenderbufferStorageEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorageEXT( GLenum target, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorageEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGEEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorageEXT(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorageEXT *c = (struct qemu_glRenderbufferStorageEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorageEXT( c->target, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glRenderbufferStorageMultisample
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorageMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorageMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGEMULTISAMPLE);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorageMultisample(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorageMultisample *c = (struct qemu_glRenderbufferStorageMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorageMultisample( c->target, c->samples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glRenderbufferStorageMultisampleAdvancedAMD
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t storageSamples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorageMultisampleAdvancedAMD( GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorageMultisampleAdvancedAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMD);
    call.target = target;
    call.samples = samples;
    call.storageSamples = storageSamples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorageMultisampleAdvancedAMD(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorageMultisampleAdvancedAMD *c = (struct qemu_glRenderbufferStorageMultisampleAdvancedAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorageMultisampleAdvancedAMD( c->target, c->samples, c->storageSamples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glRenderbufferStorageMultisampleCoverageNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorageMultisampleCoverageNV( GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorageMultisampleCoverageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV);
    call.target = target;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorageMultisampleCoverageNV(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorageMultisampleCoverageNV *c = (struct qemu_glRenderbufferStorageMultisampleCoverageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorageMultisampleCoverageNV( c->target, c->coverageSamples, c->colorSamples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glRenderbufferStorageMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRenderbufferStorageMultisampleEXT( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glRenderbufferStorageMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glRenderbufferStorageMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glRenderbufferStorageMultisampleEXT *c = (struct qemu_glRenderbufferStorageMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glRenderbufferStorageMultisampleEXT( c->target, c->samples, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glReplacementCodePointerSUN
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodePointerSUN( GLenum type, GLsizei stride, const void **pointer )
{
    struct qemu_glReplacementCodePointerSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEPOINTERSUN);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodePointerSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodePointerSUN *c = (struct qemu_glReplacementCodePointerSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodePointerSUN( c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glReplacementCodeubSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeubSUN( GLubyte code )
{
    struct qemu_glReplacementCodeubSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUBSUN);
    call.code = code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeubSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeubSUN *c = (struct qemu_glReplacementCodeubSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeubSUN( c->code ));
}

#endif

struct qemu_glReplacementCodeubvSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeubvSUN( const GLubyte *code )
{
    struct qemu_glReplacementCodeubvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUBVSUN);
    call.code = (ULONG_PTR)code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeubvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeubvSUN *c = (struct qemu_glReplacementCodeubvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeubvSUN( QEMU_G2H(c->code) ));
}

#endif

struct qemu_glReplacementCodeuiColor3fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double r;
    double g;
    double b;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor3fVertex3fSUN( GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiColor3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN);
    call.rc = rc;
    call.r = r;
    call.g = g;
    call.b = b;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor3fVertex3fSUN *c = (struct qemu_glReplacementCodeuiColor3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor3fVertex3fSUN( c->rc, c->r, c->g, c->b, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiColor3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor3fVertex3fvSUN( const GLuint *rc, const GLfloat *c, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiColor3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor3fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiColor3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor3fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double r;
    double g;
    double b;
    double a;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor4fNormal3fVertex3fSUN( GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN);
    call.rc = rc;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor4fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fSUN *c = (struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor4fNormal3fVertex3fSUN( c->rc, c->r, c->g, c->b, c->a, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t c;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor4fNormal3fVertex3fvSUN( const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.c = (ULONG_PTR)c;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor4fNormal3fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->c), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiColor4ubVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor4ubVertex3fSUN( GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiColor4ubVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN);
    call.rc = rc;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor4ubVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor4ubVertex3fSUN *c = (struct qemu_glReplacementCodeuiColor4ubVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor4ubVertex3fSUN( c->rc, c->r, c->g, c->b, c->a, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiColor4ubVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiColor4ubVertex3fvSUN( const GLuint *rc, const GLubyte *c, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiColor4ubVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiColor4ubVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiColor4ubVertex3fvSUN *c = (struct qemu_glReplacementCodeuiColor4ubVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiColor4ubVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiNormal3fVertex3fSUN( GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN);
    call.rc = rc;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiNormal3fVertex3fSUN *c = (struct qemu_glReplacementCodeuiNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiNormal3fVertex3fSUN( c->rc, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiNormal3fVertex3fvSUN( const GLuint *rc, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiNormal3fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiNormal3fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiSUN( GLuint code )
{
    struct qemu_glReplacementCodeuiSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUISUN);
    call.code = code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiSUN *c = (struct qemu_glReplacementCodeuiSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiSUN( c->code ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double s;
    double t;
    double r;
    double g;
    double b;
    double a;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN( GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN);
    call.rc = rc;
    call.s = s;
    call.t = t;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN( c->rc, c->s, c->t, c->r, c->g, c->b, c->a, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t tc;
    uint64_t c;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN( const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.tc = (ULONG_PTR)tc;
    call.c = (ULONG_PTR)c;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->tc), QEMU_G2H(c->c), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double s;
    double t;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN( GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN);
    call.rc = rc;
    call.s = s;
    call.t = t;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN( c->rc, c->s, c->t, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t tc;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN( const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.tc = (ULONG_PTR)tc;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->tc), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double s;
    double t;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fVertex3fSUN( GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiTexCoord2fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN);
    call.rc = rc;
    call.s = s;
    call.t = t;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fVertex3fSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fVertex3fSUN( c->rc, c->s, c->t, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiTexCoord2fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t tc;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiTexCoord2fVertex3fvSUN( const GLuint *rc, const GLfloat *tc, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiTexCoord2fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.tc = (ULONG_PTR)tc;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiTexCoord2fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiTexCoord2fVertex3fvSUN *c = (struct qemu_glReplacementCodeuiTexCoord2fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiTexCoord2fVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->tc), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuiVertex3fSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiVertex3fSUN( GLuint rc, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glReplacementCodeuiVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUIVERTEX3FSUN);
    call.rc = rc;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiVertex3fSUN *c = (struct qemu_glReplacementCodeuiVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiVertex3fSUN( c->rc, c->x, c->y, c->z ));
}

#endif

struct qemu_glReplacementCodeuiVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t rc;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuiVertex3fvSUN( const GLuint *rc, const GLfloat *v )
{
    struct qemu_glReplacementCodeuiVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUIVERTEX3FVSUN);
    call.rc = (ULONG_PTR)rc;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuiVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuiVertex3fvSUN *c = (struct qemu_glReplacementCodeuiVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuiVertex3fvSUN( QEMU_G2H(c->rc), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glReplacementCodeuivSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeuivSUN( const GLuint *code )
{
    struct qemu_glReplacementCodeuivSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUIVSUN);
    call.code = (ULONG_PTR)code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeuivSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeuivSUN *c = (struct qemu_glReplacementCodeuivSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeuivSUN( QEMU_G2H(c->code) ));
}

#endif

struct qemu_glReplacementCodeusSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeusSUN( GLushort code )
{
    struct qemu_glReplacementCodeusSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUSSUN);
    call.code = code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeusSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeusSUN *c = (struct qemu_glReplacementCodeusSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeusSUN( c->code ));
}

#endif

struct qemu_glReplacementCodeusvSUN
{
    struct qemu_syscall super;
    uint64_t code;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glReplacementCodeusvSUN( const GLushort *code )
{
    struct qemu_glReplacementCodeusvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREPLACEMENTCODEUSVSUN);
    call.code = (ULONG_PTR)code;

    qemu_syscall(&call.super);
}

#else

void qemu_glReplacementCodeusvSUN(struct qemu_syscall *call)
{
    struct qemu_glReplacementCodeusvSUN *c = (struct qemu_glReplacementCodeusvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glReplacementCodeusvSUN( QEMU_G2H(c->code) ));
}

#endif

struct qemu_glRequestResidentProgramsNV
{
    struct qemu_syscall super;
    uint64_t n;
    uint64_t programs;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRequestResidentProgramsNV( GLsizei n, const GLuint *programs )
{
    struct qemu_glRequestResidentProgramsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLREQUESTRESIDENTPROGRAMSNV);
    call.n = n;
    call.programs = (ULONG_PTR)programs;

    qemu_syscall(&call.super);
}

#else

void qemu_glRequestResidentProgramsNV(struct qemu_syscall *call)
{
    struct qemu_glRequestResidentProgramsNV *c = (struct qemu_glRequestResidentProgramsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glRequestResidentProgramsNV( c->n, QEMU_G2H(c->programs) ));
}

#endif

struct qemu_glResetHistogram
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResetHistogram( GLenum target )
{
    struct qemu_glResetHistogram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESETHISTOGRAM);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glResetHistogram(struct qemu_syscall *call)
{
    struct qemu_glResetHistogram *c = (struct qemu_glResetHistogram *)call;
    WINE_FIXME("Unverified\n");
    (p_glResetHistogram( c->target ));
}

#endif

struct qemu_glResetHistogramEXT
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResetHistogramEXT( GLenum target )
{
    struct qemu_glResetHistogramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESETHISTOGRAMEXT);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glResetHistogramEXT(struct qemu_syscall *call)
{
    struct qemu_glResetHistogramEXT *c = (struct qemu_glResetHistogramEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glResetHistogramEXT( c->target ));
}

#endif

struct qemu_glResetMemoryObjectParameterNV
{
    struct qemu_syscall super;
    uint64_t memory;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResetMemoryObjectParameterNV( GLuint memory, GLenum pname )
{
    struct qemu_glResetMemoryObjectParameterNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESETMEMORYOBJECTPARAMETERNV);
    call.memory = memory;
    call.pname = pname;

    qemu_syscall(&call.super);
}

#else

void qemu_glResetMemoryObjectParameterNV(struct qemu_syscall *call)
{
    struct qemu_glResetMemoryObjectParameterNV *c = (struct qemu_glResetMemoryObjectParameterNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glResetMemoryObjectParameterNV( c->memory, c->pname ));
}

#endif

struct qemu_glResetMinmax
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResetMinmax( GLenum target )
{
    struct qemu_glResetMinmax call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESETMINMAX);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glResetMinmax(struct qemu_syscall *call)
{
    struct qemu_glResetMinmax *c = (struct qemu_glResetMinmax *)call;
    WINE_FIXME("Unverified\n");
    (p_glResetMinmax( c->target ));
}

#endif

struct qemu_glResetMinmaxEXT
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResetMinmaxEXT( GLenum target )
{
    struct qemu_glResetMinmaxEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESETMINMAXEXT);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glResetMinmaxEXT(struct qemu_syscall *call)
{
    struct qemu_glResetMinmaxEXT *c = (struct qemu_glResetMinmaxEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glResetMinmaxEXT( c->target ));
}

#endif

struct qemu_glResizeBuffersMESA
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResizeBuffersMESA(void)
{
    struct qemu_glResizeBuffersMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESIZEBUFFERSMESA);

    qemu_syscall(&call.super);
}

#else

void qemu_glResizeBuffersMESA(struct qemu_syscall *call)
{
    struct qemu_glResizeBuffersMESA *c = (struct qemu_glResizeBuffersMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glResizeBuffersMESA());
}

#endif

struct qemu_glResolveDepthValuesNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResolveDepthValuesNV(void)
{
    struct qemu_glResolveDepthValuesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESOLVEDEPTHVALUESNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glResolveDepthValuesNV(struct qemu_syscall *call)
{
    struct qemu_glResolveDepthValuesNV *c = (struct qemu_glResolveDepthValuesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glResolveDepthValuesNV());
}

#endif

struct qemu_glResumeTransformFeedback
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResumeTransformFeedback(void)
{
    struct qemu_glResumeTransformFeedback call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESUMETRANSFORMFEEDBACK);

    qemu_syscall(&call.super);
}

#else

void qemu_glResumeTransformFeedback(struct qemu_syscall *call)
{
    struct qemu_glResumeTransformFeedback *c = (struct qemu_glResumeTransformFeedback *)call;
    WINE_FIXME("Unverified\n");
    (p_glResumeTransformFeedback());
}

#endif

struct qemu_glResumeTransformFeedbackNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glResumeTransformFeedbackNV(void)
{
    struct qemu_glResumeTransformFeedbackNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLRESUMETRANSFORMFEEDBACKNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glResumeTransformFeedbackNV(struct qemu_syscall *call)
{
    struct qemu_glResumeTransformFeedbackNV *c = (struct qemu_glResumeTransformFeedbackNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glResumeTransformFeedbackNV());
}

#endif

struct qemu_glRotatexOES
{
    struct qemu_syscall super;
    uint64_t angle;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glRotatexOES( GLfixed angle, GLfixed x, GLfixed y, GLfixed z )
{
    struct qemu_glRotatexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLROTATEXOES);
    call.angle = angle;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glRotatexOES(struct qemu_syscall *call)
{
    struct qemu_glRotatexOES *c = (struct qemu_glRotatexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glRotatexOES( c->angle, c->x, c->y, c->z ));
}

#endif

struct qemu_glSampleCoverage
{
    struct qemu_syscall super;
    double value;
    uint64_t invert;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleCoverage( GLfloat value, GLboolean invert )
{
    struct qemu_glSampleCoverage call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLECOVERAGE);
    call.value = value;
    call.invert = invert;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleCoverage(struct qemu_syscall *call)
{
    struct qemu_glSampleCoverage *c = (struct qemu_glSampleCoverage *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleCoverage( c->value, c->invert ));
}

#endif

struct qemu_glSampleCoverageARB
{
    struct qemu_syscall super;
    double value;
    uint64_t invert;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleCoverageARB( GLfloat value, GLboolean invert )
{
    struct qemu_glSampleCoverageARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLECOVERAGEARB);
    call.value = value;
    call.invert = invert;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleCoverageARB(struct qemu_syscall *call)
{
    struct qemu_glSampleCoverageARB *c = (struct qemu_glSampleCoverageARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleCoverageARB( c->value, c->invert ));
}

#endif

struct qemu_glSampleMapATI
{
    struct qemu_syscall super;
    uint64_t dst;
    uint64_t interp;
    uint64_t swizzle;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleMapATI( GLuint dst, GLuint interp, GLenum swizzle )
{
    struct qemu_glSampleMapATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEMAPATI);
    call.dst = dst;
    call.interp = interp;
    call.swizzle = swizzle;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleMapATI(struct qemu_syscall *call)
{
    struct qemu_glSampleMapATI *c = (struct qemu_glSampleMapATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleMapATI( c->dst, c->interp, c->swizzle ));
}

#endif

struct qemu_glSampleMaskEXT
{
    struct qemu_syscall super;
    double value;
    uint64_t invert;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleMaskEXT( GLclampf value, GLboolean invert )
{
    struct qemu_glSampleMaskEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEMASKEXT);
    call.value = value;
    call.invert = invert;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleMaskEXT(struct qemu_syscall *call)
{
    struct qemu_glSampleMaskEXT *c = (struct qemu_glSampleMaskEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleMaskEXT( c->value, c->invert ));
}

#endif

struct qemu_glSampleMaskIndexedNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleMaskIndexedNV( GLuint index, GLbitfield mask )
{
    struct qemu_glSampleMaskIndexedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEMASKINDEXEDNV);
    call.index = index;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleMaskIndexedNV(struct qemu_syscall *call)
{
    struct qemu_glSampleMaskIndexedNV *c = (struct qemu_glSampleMaskIndexedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleMaskIndexedNV( c->index, c->mask ));
}

#endif

struct qemu_glSampleMaskSGIS
{
    struct qemu_syscall super;
    double value;
    uint64_t invert;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleMaskSGIS( GLclampf value, GLboolean invert )
{
    struct qemu_glSampleMaskSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEMASKSGIS);
    call.value = value;
    call.invert = invert;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleMaskSGIS(struct qemu_syscall *call)
{
    struct qemu_glSampleMaskSGIS *c = (struct qemu_glSampleMaskSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleMaskSGIS( c->value, c->invert ));
}

#endif

struct qemu_glSampleMaski
{
    struct qemu_syscall super;
    uint64_t maskNumber;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSampleMaski( GLuint maskNumber, GLbitfield mask )
{
    struct qemu_glSampleMaski call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEMASKI);
    call.maskNumber = maskNumber;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glSampleMaski(struct qemu_syscall *call)
{
    struct qemu_glSampleMaski *c = (struct qemu_glSampleMaski *)call;
    WINE_FIXME("Unverified\n");
    (p_glSampleMaski( c->maskNumber, c->mask ));
}

#endif

struct qemu_glSamplePatternEXT
{
    struct qemu_syscall super;
    uint64_t pattern;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplePatternEXT( GLenum pattern )
{
    struct qemu_glSamplePatternEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEPATTERNEXT);
    call.pattern = pattern;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplePatternEXT(struct qemu_syscall *call)
{
    struct qemu_glSamplePatternEXT *c = (struct qemu_glSamplePatternEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplePatternEXT( c->pattern ));
}

#endif

struct qemu_glSamplePatternSGIS
{
    struct qemu_syscall super;
    uint64_t pattern;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplePatternSGIS( GLenum pattern )
{
    struct qemu_glSamplePatternSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLEPATTERNSGIS);
    call.pattern = pattern;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplePatternSGIS(struct qemu_syscall *call)
{
    struct qemu_glSamplePatternSGIS *c = (struct qemu_glSamplePatternSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplePatternSGIS( c->pattern ));
}

#endif

struct qemu_glSamplerParameterIiv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameterIiv( GLuint sampler, GLenum pname, const GLint *param )
{
    struct qemu_glSamplerParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERIIV);
    call.sampler = sampler;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameterIiv *c = (struct qemu_glSamplerParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameterIiv( c->sampler, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glSamplerParameterIuiv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameterIuiv( GLuint sampler, GLenum pname, const GLuint *param )
{
    struct qemu_glSamplerParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERIUIV);
    call.sampler = sampler;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameterIuiv *c = (struct qemu_glSamplerParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameterIuiv( c->sampler, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glSamplerParameterf
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameterf( GLuint sampler, GLenum pname, GLfloat param )
{
    struct qemu_glSamplerParameterf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERF);
    call.sampler = sampler;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameterf(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameterf *c = (struct qemu_glSamplerParameterf *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameterf( c->sampler, c->pname, c->param ));
}

#endif

struct qemu_glSamplerParameterfv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameterfv( GLuint sampler, GLenum pname, const GLfloat *param )
{
    struct qemu_glSamplerParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERFV);
    call.sampler = sampler;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameterfv(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameterfv *c = (struct qemu_glSamplerParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameterfv( c->sampler, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glSamplerParameteri
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameteri( GLuint sampler, GLenum pname, GLint param )
{
    struct qemu_glSamplerParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERI);
    call.sampler = sampler;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameteri(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameteri *c = (struct qemu_glSamplerParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameteri( c->sampler, c->pname, c->param ));
}

#endif

struct qemu_glSamplerParameteriv
{
    struct qemu_syscall super;
    uint64_t sampler;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSamplerParameteriv( GLuint sampler, GLenum pname, const GLint *param )
{
    struct qemu_glSamplerParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSAMPLERPARAMETERIV);
    call.sampler = sampler;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSamplerParameteriv(struct qemu_syscall *call)
{
    struct qemu_glSamplerParameteriv *c = (struct qemu_glSamplerParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSamplerParameteriv( c->sampler, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glScalexOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScalexOES( GLfixed x, GLfixed y, GLfixed z )
{
    struct qemu_glScalexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCALEXOES);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glScalexOES(struct qemu_syscall *call)
{
    struct qemu_glScalexOES *c = (struct qemu_glScalexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glScalexOES( c->x, c->y, c->z ));
}

#endif

struct qemu_glScissorArrayv
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScissorArrayv( GLuint first, GLsizei count, const GLint *v )
{
    struct qemu_glScissorArrayv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCISSORARRAYV);
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glScissorArrayv(struct qemu_syscall *call)
{
    struct qemu_glScissorArrayv *c = (struct qemu_glScissorArrayv *)call;
    WINE_FIXME("Unverified\n");
    (p_glScissorArrayv( c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glScissorExclusiveArrayvNV
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScissorExclusiveArrayvNV( GLuint first, GLsizei count, const GLint *v )
{
    struct qemu_glScissorExclusiveArrayvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCISSOREXCLUSIVEARRAYVNV);
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glScissorExclusiveArrayvNV(struct qemu_syscall *call)
{
    struct qemu_glScissorExclusiveArrayvNV *c = (struct qemu_glScissorExclusiveArrayvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glScissorExclusiveArrayvNV( c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glScissorExclusiveNV
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScissorExclusiveNV( GLint x, GLint y, GLsizei width, GLsizei height )
{
    struct qemu_glScissorExclusiveNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCISSOREXCLUSIVENV);
    call.x = x;
    call.y = y;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glScissorExclusiveNV(struct qemu_syscall *call)
{
    struct qemu_glScissorExclusiveNV *c = (struct qemu_glScissorExclusiveNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glScissorExclusiveNV( c->x, c->y, c->width, c->height ));
}

#endif

struct qemu_glScissorIndexed
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t left;
    uint64_t bottom;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScissorIndexed( GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height )
{
    struct qemu_glScissorIndexed call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCISSORINDEXED);
    call.index = index;
    call.left = left;
    call.bottom = bottom;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glScissorIndexed(struct qemu_syscall *call)
{
    struct qemu_glScissorIndexed *c = (struct qemu_glScissorIndexed *)call;
    WINE_FIXME("Unverified\n");
    (p_glScissorIndexed( c->index, c->left, c->bottom, c->width, c->height ));
}

#endif

struct qemu_glScissorIndexedv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glScissorIndexedv( GLuint index, const GLint *v )
{
    struct qemu_glScissorIndexedv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSCISSORINDEXEDV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glScissorIndexedv(struct qemu_syscall *call)
{
    struct qemu_glScissorIndexedv *c = (struct qemu_glScissorIndexedv *)call;
    WINE_FIXME("Unverified\n");
    (p_glScissorIndexedv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3b
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3b( GLbyte red, GLbyte green, GLbyte blue )
{
    struct qemu_glSecondaryColor3b call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3B);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3b(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3b *c = (struct qemu_glSecondaryColor3b *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3b( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3bEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3bEXT( GLbyte red, GLbyte green, GLbyte blue )
{
    struct qemu_glSecondaryColor3bEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3BEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3bEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3bEXT *c = (struct qemu_glSecondaryColor3bEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3bEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3bv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3bv( const GLbyte *v )
{
    struct qemu_glSecondaryColor3bv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3BV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3bv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3bv *c = (struct qemu_glSecondaryColor3bv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3bv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3bvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3bvEXT( const GLbyte *v )
{
    struct qemu_glSecondaryColor3bvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3BVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3bvEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3bvEXT *c = (struct qemu_glSecondaryColor3bvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3bvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3d
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3d( GLdouble red, GLdouble green, GLdouble blue )
{
    struct qemu_glSecondaryColor3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3D);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3d(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3d *c = (struct qemu_glSecondaryColor3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3d( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3dEXT
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3dEXT( GLdouble red, GLdouble green, GLdouble blue )
{
    struct qemu_glSecondaryColor3dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3DEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3dEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3dEXT *c = (struct qemu_glSecondaryColor3dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3dEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3dv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3dv( const GLdouble *v )
{
    struct qemu_glSecondaryColor3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3DV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3dv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3dv *c = (struct qemu_glSecondaryColor3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3dv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3dvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3dvEXT( const GLdouble *v )
{
    struct qemu_glSecondaryColor3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3DVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3dvEXT *c = (struct qemu_glSecondaryColor3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3dvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3f
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3f( GLfloat red, GLfloat green, GLfloat blue )
{
    struct qemu_glSecondaryColor3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3F);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3f(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3f *c = (struct qemu_glSecondaryColor3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3f( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3fEXT
{
    struct qemu_syscall super;
    double red;
    double green;
    double blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3fEXT( GLfloat red, GLfloat green, GLfloat blue )
{
    struct qemu_glSecondaryColor3fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3FEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3fEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3fEXT *c = (struct qemu_glSecondaryColor3fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3fEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3fv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3fv( const GLfloat *v )
{
    struct qemu_glSecondaryColor3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3FV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3fv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3fv *c = (struct qemu_glSecondaryColor3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3fv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3fvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3fvEXT( const GLfloat *v )
{
    struct qemu_glSecondaryColor3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3FVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3fvEXT *c = (struct qemu_glSecondaryColor3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3fvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3hNV
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3hNV( GLhalfNV red, GLhalfNV green, GLhalfNV blue )
{
    struct qemu_glSecondaryColor3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3HNV);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3hNV(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3hNV *c = (struct qemu_glSecondaryColor3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3hNV( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3hvNV( const GLhalfNV *v )
{
    struct qemu_glSecondaryColor3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3hvNV(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3hvNV *c = (struct qemu_glSecondaryColor3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3i
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3i( GLint red, GLint green, GLint blue )
{
    struct qemu_glSecondaryColor3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3I);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3i(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3i *c = (struct qemu_glSecondaryColor3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3i( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3iEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3iEXT( GLint red, GLint green, GLint blue )
{
    struct qemu_glSecondaryColor3iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3IEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3iEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3iEXT *c = (struct qemu_glSecondaryColor3iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3iEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3iv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3iv( const GLint *v )
{
    struct qemu_glSecondaryColor3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3IV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3iv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3iv *c = (struct qemu_glSecondaryColor3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3iv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3ivEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ivEXT( const GLint *v )
{
    struct qemu_glSecondaryColor3ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3IVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ivEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ivEXT *c = (struct qemu_glSecondaryColor3ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ivEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3s
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3s( GLshort red, GLshort green, GLshort blue )
{
    struct qemu_glSecondaryColor3s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3S);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3s(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3s *c = (struct qemu_glSecondaryColor3s *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3s( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3sEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3sEXT( GLshort red, GLshort green, GLshort blue )
{
    struct qemu_glSecondaryColor3sEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3SEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3sEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3sEXT *c = (struct qemu_glSecondaryColor3sEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3sEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3sv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3sv( const GLshort *v )
{
    struct qemu_glSecondaryColor3sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3SV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3sv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3sv *c = (struct qemu_glSecondaryColor3sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3sv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3svEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3svEXT( const GLshort *v )
{
    struct qemu_glSecondaryColor3svEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3SVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3svEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3svEXT *c = (struct qemu_glSecondaryColor3svEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3svEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3ub
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ub( GLubyte red, GLubyte green, GLubyte blue )
{
    struct qemu_glSecondaryColor3ub call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UB);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ub(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ub *c = (struct qemu_glSecondaryColor3ub *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ub( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3ubEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ubEXT( GLubyte red, GLubyte green, GLubyte blue )
{
    struct qemu_glSecondaryColor3ubEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UBEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ubEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ubEXT *c = (struct qemu_glSecondaryColor3ubEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ubEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3ubv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ubv( const GLubyte *v )
{
    struct qemu_glSecondaryColor3ubv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UBV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ubv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ubv *c = (struct qemu_glSecondaryColor3ubv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ubv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3ubvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ubvEXT( const GLubyte *v )
{
    struct qemu_glSecondaryColor3ubvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UBVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ubvEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ubvEXT *c = (struct qemu_glSecondaryColor3ubvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ubvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3ui
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3ui( GLuint red, GLuint green, GLuint blue )
{
    struct qemu_glSecondaryColor3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UI);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3ui(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3ui *c = (struct qemu_glSecondaryColor3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3ui( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3uiEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3uiEXT( GLuint red, GLuint green, GLuint blue )
{
    struct qemu_glSecondaryColor3uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UIEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3uiEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3uiEXT *c = (struct qemu_glSecondaryColor3uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3uiEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3uiv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3uiv( const GLuint *v )
{
    struct qemu_glSecondaryColor3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UIV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3uiv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3uiv *c = (struct qemu_glSecondaryColor3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3uiv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3uivEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3uivEXT( const GLuint *v )
{
    struct qemu_glSecondaryColor3uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3UIVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3uivEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3uivEXT *c = (struct qemu_glSecondaryColor3uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3uivEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3us
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3us( GLushort red, GLushort green, GLushort blue )
{
    struct qemu_glSecondaryColor3us call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3US);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3us(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3us *c = (struct qemu_glSecondaryColor3us *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3us( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3usEXT
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3usEXT( GLushort red, GLushort green, GLushort blue )
{
    struct qemu_glSecondaryColor3usEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3USEXT);
    call.red = red;
    call.green = green;
    call.blue = blue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3usEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3usEXT *c = (struct qemu_glSecondaryColor3usEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3usEXT( c->red, c->green, c->blue ));
}

#endif

struct qemu_glSecondaryColor3usv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3usv( const GLushort *v )
{
    struct qemu_glSecondaryColor3usv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3USV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3usv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3usv *c = (struct qemu_glSecondaryColor3usv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3usv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColor3usvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColor3usvEXT( const GLushort *v )
{
    struct qemu_glSecondaryColor3usvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLOR3USVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColor3usvEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColor3usvEXT *c = (struct qemu_glSecondaryColor3usvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColor3usvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glSecondaryColorFormatNV
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorFormatNV( GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glSecondaryColorFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORFORMATNV);
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorFormatNV(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorFormatNV *c = (struct qemu_glSecondaryColorFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorFormatNV( c->size, c->type, c->stride ));
}

#endif

struct qemu_glSecondaryColorP3ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorP3ui( GLenum type, GLuint color )
{
    struct qemu_glSecondaryColorP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORP3UI);
    call.type = type;
    call.color = color;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorP3ui(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorP3ui *c = (struct qemu_glSecondaryColorP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorP3ui( c->type, c->color ));
}

#endif

struct qemu_glSecondaryColorP3uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t color;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorP3uiv( GLenum type, const GLuint *color )
{
    struct qemu_glSecondaryColorP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORP3UIV);
    call.type = type;
    call.color = (ULONG_PTR)color;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorP3uiv(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorP3uiv *c = (struct qemu_glSecondaryColorP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorP3uiv( c->type, QEMU_G2H(c->color) ));
}

#endif

struct qemu_glSecondaryColorPointer
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorPointer( GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glSecondaryColorPointer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORPOINTER);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorPointer(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorPointer *c = (struct qemu_glSecondaryColorPointer *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorPointer( c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glSecondaryColorPointerEXT
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorPointerEXT( GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glSecondaryColorPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORPOINTEREXT);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorPointerEXT *c = (struct qemu_glSecondaryColorPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorPointerEXT( c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glSecondaryColorPointerListIBM
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSecondaryColorPointerListIBM( GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glSecondaryColorPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSECONDARYCOLORPOINTERLISTIBM);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glSecondaryColorPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glSecondaryColorPointerListIBM *c = (struct qemu_glSecondaryColorPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glSecondaryColorPointerListIBM( c->size, c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glSelectPerfMonitorCountersAMD
{
    struct qemu_syscall super;
    uint64_t monitor;
    uint64_t enable;
    uint64_t group;
    uint64_t numCounters;
    uint64_t counterList;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSelectPerfMonitorCountersAMD( GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList )
{
    struct qemu_glSelectPerfMonitorCountersAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSELECTPERFMONITORCOUNTERSAMD);
    call.monitor = monitor;
    call.enable = enable;
    call.group = group;
    call.numCounters = numCounters;
    call.counterList = (ULONG_PTR)counterList;

    qemu_syscall(&call.super);
}

#else

void qemu_glSelectPerfMonitorCountersAMD(struct qemu_syscall *call)
{
    struct qemu_glSelectPerfMonitorCountersAMD *c = (struct qemu_glSelectPerfMonitorCountersAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glSelectPerfMonitorCountersAMD( c->monitor, c->enable, c->group, c->numCounters, QEMU_G2H(c->counterList) ));
}

#endif

struct qemu_glSelectTextureCoordSetSGIS
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSelectTextureCoordSetSGIS( GLenum target )
{
    struct qemu_glSelectTextureCoordSetSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSELECTTEXTURECOORDSETSGIS);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glSelectTextureCoordSetSGIS(struct qemu_syscall *call)
{
    struct qemu_glSelectTextureCoordSetSGIS *c = (struct qemu_glSelectTextureCoordSetSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glSelectTextureCoordSetSGIS( c->target ));
}

#endif

struct qemu_glSelectTextureSGIS
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSelectTextureSGIS( GLenum target )
{
    struct qemu_glSelectTextureSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSELECTTEXTURESGIS);
    call.target = target;

    qemu_syscall(&call.super);
}

#else

void qemu_glSelectTextureSGIS(struct qemu_syscall *call)
{
    struct qemu_glSelectTextureSGIS *c = (struct qemu_glSelectTextureSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glSelectTextureSGIS( c->target ));
}

#endif

struct qemu_glSemaphoreParameterui64vEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSemaphoreParameterui64vEXT( GLuint semaphore, GLenum pname, const GLuint64 *params )
{
    struct qemu_glSemaphoreParameterui64vEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSEMAPHOREPARAMETERUI64VEXT);
    call.semaphore = semaphore;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glSemaphoreParameterui64vEXT(struct qemu_syscall *call)
{
    struct qemu_glSemaphoreParameterui64vEXT *c = (struct qemu_glSemaphoreParameterui64vEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSemaphoreParameterui64vEXT( c->semaphore, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glSeparableFilter2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t row;
    uint64_t column;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSeparableFilter2D( GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column )
{
    struct qemu_glSeparableFilter2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSEPARABLEFILTER2D);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.row = (ULONG_PTR)row;
    call.column = (ULONG_PTR)column;

    qemu_syscall(&call.super);
}

#else

void qemu_glSeparableFilter2D(struct qemu_syscall *call)
{
    struct qemu_glSeparableFilter2D *c = (struct qemu_glSeparableFilter2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glSeparableFilter2D( c->target, c->internalformat, c->width, c->height, c->format, c->type, QEMU_G2H(c->row), QEMU_G2H(c->column) ));
}

#endif

struct qemu_glSeparableFilter2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t row;
    uint64_t column;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSeparableFilter2DEXT( GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column )
{
    struct qemu_glSeparableFilter2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSEPARABLEFILTER2DEXT);
    call.target = target;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.row = (ULONG_PTR)row;
    call.column = (ULONG_PTR)column;

    qemu_syscall(&call.super);
}

#else

void qemu_glSeparableFilter2DEXT(struct qemu_syscall *call)
{
    struct qemu_glSeparableFilter2DEXT *c = (struct qemu_glSeparableFilter2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSeparableFilter2DEXT( c->target, c->internalformat, c->width, c->height, c->format, c->type, QEMU_G2H(c->row), QEMU_G2H(c->column) ));
}

#endif

struct qemu_glSetFenceAPPLE
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetFenceAPPLE( GLuint fence )
{
    struct qemu_glSetFenceAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETFENCEAPPLE);
    call.fence = fence;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetFenceAPPLE(struct qemu_syscall *call)
{
    struct qemu_glSetFenceAPPLE *c = (struct qemu_glSetFenceAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetFenceAPPLE( c->fence ));
}

#endif

struct qemu_glSetFenceNV
{
    struct qemu_syscall super;
    uint64_t fence;
    uint64_t condition;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetFenceNV( GLuint fence, GLenum condition )
{
    struct qemu_glSetFenceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETFENCENV);
    call.fence = fence;
    call.condition = condition;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetFenceNV(struct qemu_syscall *call)
{
    struct qemu_glSetFenceNV *c = (struct qemu_glSetFenceNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetFenceNV( c->fence, c->condition ));
}

#endif

struct qemu_glSetFragmentShaderConstantATI
{
    struct qemu_syscall super;
    uint64_t dst;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetFragmentShaderConstantATI( GLuint dst, const GLfloat *value )
{
    struct qemu_glSetFragmentShaderConstantATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETFRAGMENTSHADERCONSTANTATI);
    call.dst = dst;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetFragmentShaderConstantATI(struct qemu_syscall *call)
{
    struct qemu_glSetFragmentShaderConstantATI *c = (struct qemu_glSetFragmentShaderConstantATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetFragmentShaderConstantATI( c->dst, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glSetInvariantEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t type;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetInvariantEXT( GLuint id, GLenum type, const void *addr )
{
    struct qemu_glSetInvariantEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETINVARIANTEXT);
    call.id = id;
    call.type = type;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetInvariantEXT(struct qemu_syscall *call)
{
    struct qemu_glSetInvariantEXT *c = (struct qemu_glSetInvariantEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetInvariantEXT( c->id, c->type, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glSetLocalConstantEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t type;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetLocalConstantEXT( GLuint id, GLenum type, const void *addr )
{
    struct qemu_glSetLocalConstantEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETLOCALCONSTANTEXT);
    call.id = id;
    call.type = type;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetLocalConstantEXT(struct qemu_syscall *call)
{
    struct qemu_glSetLocalConstantEXT *c = (struct qemu_glSetLocalConstantEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetLocalConstantEXT( c->id, c->type, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glSetMultisamplefvAMD
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t index;
    uint64_t val;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSetMultisamplefvAMD( GLenum pname, GLuint index, const GLfloat *val )
{
    struct qemu_glSetMultisamplefvAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSETMULTISAMPLEFVAMD);
    call.pname = pname;
    call.index = index;
    call.val = (ULONG_PTR)val;

    qemu_syscall(&call.super);
}

#else

void qemu_glSetMultisamplefvAMD(struct qemu_syscall *call)
{
    struct qemu_glSetMultisamplefvAMD *c = (struct qemu_glSetMultisamplefvAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glSetMultisamplefvAMD( c->pname, c->index, QEMU_G2H(c->val) ));
}

#endif

struct qemu_glShaderBinary
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t shaders;
    uint64_t binaryformat;
    uint64_t binary;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderBinary( GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length )
{
    struct qemu_glShaderBinary call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADERBINARY);
    call.count = count;
    call.shaders = (ULONG_PTR)shaders;
    call.binaryformat = binaryformat;
    call.binary = (ULONG_PTR)binary;
    call.length = length;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderBinary(struct qemu_syscall *call)
{
    struct qemu_glShaderBinary *c = (struct qemu_glShaderBinary *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderBinary( c->count, QEMU_G2H(c->shaders), c->binaryformat, QEMU_G2H(c->binary), c->length ));
}

#endif

struct qemu_glShaderOp1EXT
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t res;
    uint64_t arg1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderOp1EXT( GLenum op, GLuint res, GLuint arg1 )
{
    struct qemu_glShaderOp1EXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADEROP1EXT);
    call.op = op;
    call.res = res;
    call.arg1 = arg1;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderOp1EXT(struct qemu_syscall *call)
{
    struct qemu_glShaderOp1EXT *c = (struct qemu_glShaderOp1EXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderOp1EXT( c->op, c->res, c->arg1 ));
}

#endif

struct qemu_glShaderOp2EXT
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t res;
    uint64_t arg1;
    uint64_t arg2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderOp2EXT( GLenum op, GLuint res, GLuint arg1, GLuint arg2 )
{
    struct qemu_glShaderOp2EXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADEROP2EXT);
    call.op = op;
    call.res = res;
    call.arg1 = arg1;
    call.arg2 = arg2;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderOp2EXT(struct qemu_syscall *call)
{
    struct qemu_glShaderOp2EXT *c = (struct qemu_glShaderOp2EXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderOp2EXT( c->op, c->res, c->arg1, c->arg2 ));
}

#endif

struct qemu_glShaderOp3EXT
{
    struct qemu_syscall super;
    uint64_t op;
    uint64_t res;
    uint64_t arg1;
    uint64_t arg2;
    uint64_t arg3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderOp3EXT( GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3 )
{
    struct qemu_glShaderOp3EXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADEROP3EXT);
    call.op = op;
    call.res = res;
    call.arg1 = arg1;
    call.arg2 = arg2;
    call.arg3 = arg3;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderOp3EXT(struct qemu_syscall *call)
{
    struct qemu_glShaderOp3EXT *c = (struct qemu_glShaderOp3EXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderOp3EXT( c->op, c->res, c->arg1, c->arg2, c->arg3 ));
}

#endif

struct qemu_glShaderSource
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t count;
    uint64_t string;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderSource( GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length )
{
    struct qemu_glShaderSource call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADERSOURCE);
    call.shader = shader;
    call.count = count;
    call.string = (ULONG_PTR)string;
    call.length = (ULONG_PTR)length;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderSource(struct qemu_syscall *call)
{
    struct qemu_glShaderSource *c = (struct qemu_glShaderSource *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderSource( c->shader, c->count, QEMU_G2H(c->string), QEMU_G2H(c->length) ));
}

#endif

struct qemu_glShaderSourceARB
{
    struct qemu_syscall super;
    uint64_t shaderObj;
    uint64_t count;
    uint64_t string;
    uint64_t length;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderSourceARB( GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length )
{
    struct qemu_glShaderSourceARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADERSOURCEARB);
    call.shaderObj = shaderObj;
    call.count = count;
    call.string = (ULONG_PTR)string;
    call.length = (ULONG_PTR)length;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderSourceARB(struct qemu_syscall *call)
{
    struct qemu_glShaderSourceARB *c = (struct qemu_glShaderSourceARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderSourceARB( c->shaderObj, c->count, QEMU_G2H(c->string), QEMU_G2H(c->length) ));
}

#endif

struct qemu_glShaderStorageBlockBinding
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t storageBlockIndex;
    uint64_t storageBlockBinding;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShaderStorageBlockBinding( GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding )
{
    struct qemu_glShaderStorageBlockBinding call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADERSTORAGEBLOCKBINDING);
    call.program = program;
    call.storageBlockIndex = storageBlockIndex;
    call.storageBlockBinding = storageBlockBinding;

    qemu_syscall(&call.super);
}

#else

void qemu_glShaderStorageBlockBinding(struct qemu_syscall *call)
{
    struct qemu_glShaderStorageBlockBinding *c = (struct qemu_glShaderStorageBlockBinding *)call;
    WINE_FIXME("Unverified\n");
    (p_glShaderStorageBlockBinding( c->program, c->storageBlockIndex, c->storageBlockBinding ));
}

#endif

struct qemu_glShadingRateImageBarrierNV
{
    struct qemu_syscall super;
    uint64_t synchronize;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShadingRateImageBarrierNV( GLboolean synchronize )
{
    struct qemu_glShadingRateImageBarrierNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADINGRATEIMAGEBARRIERNV);
    call.synchronize = synchronize;

    qemu_syscall(&call.super);
}

#else

void qemu_glShadingRateImageBarrierNV(struct qemu_syscall *call)
{
    struct qemu_glShadingRateImageBarrierNV *c = (struct qemu_glShadingRateImageBarrierNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glShadingRateImageBarrierNV( c->synchronize ));
}

#endif

struct qemu_glShadingRateImagePaletteNV
{
    struct qemu_syscall super;
    uint64_t viewport;
    uint64_t first;
    uint64_t count;
    uint64_t rates;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShadingRateImagePaletteNV( GLuint viewport, GLuint first, GLsizei count, const GLenum *rates )
{
    struct qemu_glShadingRateImagePaletteNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADINGRATEIMAGEPALETTENV);
    call.viewport = viewport;
    call.first = first;
    call.count = count;
    call.rates = (ULONG_PTR)rates;

    qemu_syscall(&call.super);
}

#else

void qemu_glShadingRateImagePaletteNV(struct qemu_syscall *call)
{
    struct qemu_glShadingRateImagePaletteNV *c = (struct qemu_glShadingRateImagePaletteNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glShadingRateImagePaletteNV( c->viewport, c->first, c->count, QEMU_G2H(c->rates) ));
}

#endif

struct qemu_glShadingRateSampleOrderCustomNV
{
    struct qemu_syscall super;
    uint64_t rate;
    uint64_t samples;
    uint64_t locations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShadingRateSampleOrderCustomNV( GLenum rate, GLuint samples, const GLint *locations )
{
    struct qemu_glShadingRateSampleOrderCustomNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADINGRATESAMPLEORDERCUSTOMNV);
    call.rate = rate;
    call.samples = samples;
    call.locations = (ULONG_PTR)locations;

    qemu_syscall(&call.super);
}

#else

void qemu_glShadingRateSampleOrderCustomNV(struct qemu_syscall *call)
{
    struct qemu_glShadingRateSampleOrderCustomNV *c = (struct qemu_glShadingRateSampleOrderCustomNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glShadingRateSampleOrderCustomNV( c->rate, c->samples, QEMU_G2H(c->locations) ));
}

#endif

struct qemu_glShadingRateSampleOrderNV
{
    struct qemu_syscall super;
    uint64_t order;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glShadingRateSampleOrderNV( GLenum order )
{
    struct qemu_glShadingRateSampleOrderNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHADINGRATESAMPLEORDERNV);
    call.order = order;

    qemu_syscall(&call.super);
}

#else

void qemu_glShadingRateSampleOrderNV(struct qemu_syscall *call)
{
    struct qemu_glShadingRateSampleOrderNV *c = (struct qemu_glShadingRateSampleOrderNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glShadingRateSampleOrderNV( c->order ));
}

#endif

struct qemu_glSharpenTexFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t n;
    uint64_t points;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSharpenTexFuncSGIS( GLenum target, GLsizei n, const GLfloat *points )
{
    struct qemu_glSharpenTexFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSHARPENTEXFUNCSGIS);
    call.target = target;
    call.n = n;
    call.points = (ULONG_PTR)points;

    qemu_syscall(&call.super);
}

#else

void qemu_glSharpenTexFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glSharpenTexFuncSGIS *c = (struct qemu_glSharpenTexFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glSharpenTexFuncSGIS( c->target, c->n, QEMU_G2H(c->points) ));
}

#endif

struct qemu_glSignalSemaphoreEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t numBufferBarriers;
    uint64_t buffers;
    uint64_t numTextureBarriers;
    uint64_t textures;
    uint64_t dstLayouts;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSignalSemaphoreEXT( GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts )
{
    struct qemu_glSignalSemaphoreEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSIGNALSEMAPHOREEXT);
    call.semaphore = semaphore;
    call.numBufferBarriers = numBufferBarriers;
    call.buffers = (ULONG_PTR)buffers;
    call.numTextureBarriers = numTextureBarriers;
    call.textures = (ULONG_PTR)textures;
    call.dstLayouts = (ULONG_PTR)dstLayouts;

    qemu_syscall(&call.super);
}

#else

void qemu_glSignalSemaphoreEXT(struct qemu_syscall *call)
{
    struct qemu_glSignalSemaphoreEXT *c = (struct qemu_glSignalSemaphoreEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSignalSemaphoreEXT( c->semaphore, c->numBufferBarriers, QEMU_G2H(c->buffers), c->numTextureBarriers, QEMU_G2H(c->textures), QEMU_G2H(c->dstLayouts) ));
}

#endif

struct qemu_glSignalSemaphoreui64NVX
{
    struct qemu_syscall super;
    uint64_t signalGpu;
    uint64_t fenceObjectCount;
    uint64_t semaphoreArray;
    uint64_t fenceValueArray;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSignalSemaphoreui64NVX( GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray )
{
    struct qemu_glSignalSemaphoreui64NVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSIGNALSEMAPHOREUI64NVX);
    call.signalGpu = signalGpu;
    call.fenceObjectCount = fenceObjectCount;
    call.semaphoreArray = (ULONG_PTR)semaphoreArray;
    call.fenceValueArray = (ULONG_PTR)fenceValueArray;

    qemu_syscall(&call.super);
}

#else

void qemu_glSignalSemaphoreui64NVX(struct qemu_syscall *call)
{
    struct qemu_glSignalSemaphoreui64NVX *c = (struct qemu_glSignalSemaphoreui64NVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glSignalSemaphoreui64NVX( c->signalGpu, c->fenceObjectCount, QEMU_G2H(c->semaphoreArray), QEMU_G2H(c->fenceValueArray) ));
}

#endif

struct qemu_glSignalVkFenceNV
{
    struct qemu_syscall super;
    uint64_t vkFence;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSignalVkFenceNV( GLuint64 vkFence )
{
    struct qemu_glSignalVkFenceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSIGNALVKFENCENV);
    call.vkFence = vkFence;

    qemu_syscall(&call.super);
}

#else

void qemu_glSignalVkFenceNV(struct qemu_syscall *call)
{
    struct qemu_glSignalVkFenceNV *c = (struct qemu_glSignalVkFenceNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSignalVkFenceNV( c->vkFence ));
}

#endif

struct qemu_glSignalVkSemaphoreNV
{
    struct qemu_syscall super;
    uint64_t vkSemaphore;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSignalVkSemaphoreNV( GLuint64 vkSemaphore )
{
    struct qemu_glSignalVkSemaphoreNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSIGNALVKSEMAPHORENV);
    call.vkSemaphore = vkSemaphore;

    qemu_syscall(&call.super);
}

#else

void qemu_glSignalVkSemaphoreNV(struct qemu_syscall *call)
{
    struct qemu_glSignalVkSemaphoreNV *c = (struct qemu_glSignalVkSemaphoreNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSignalVkSemaphoreNV( c->vkSemaphore ));
}

#endif

struct qemu_glSpecializeShader
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t pEntryPoint;
    uint64_t numSpecializationConstants;
    uint64_t pConstantIndex;
    uint64_t pConstantValue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpecializeShader( GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue )
{
    struct qemu_glSpecializeShader call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPECIALIZESHADER);
    call.shader = shader;
    call.pEntryPoint = (ULONG_PTR)pEntryPoint;
    call.numSpecializationConstants = numSpecializationConstants;
    call.pConstantIndex = (ULONG_PTR)pConstantIndex;
    call.pConstantValue = (ULONG_PTR)pConstantValue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpecializeShader(struct qemu_syscall *call)
{
    struct qemu_glSpecializeShader *c = (struct qemu_glSpecializeShader *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpecializeShader( c->shader, QEMU_G2H(c->pEntryPoint), c->numSpecializationConstants, QEMU_G2H(c->pConstantIndex), QEMU_G2H(c->pConstantValue) ));
}

#endif

struct qemu_glSpecializeShaderARB
{
    struct qemu_syscall super;
    uint64_t shader;
    uint64_t pEntryPoint;
    uint64_t numSpecializationConstants;
    uint64_t pConstantIndex;
    uint64_t pConstantValue;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpecializeShaderARB( GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue )
{
    struct qemu_glSpecializeShaderARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPECIALIZESHADERARB);
    call.shader = shader;
    call.pEntryPoint = (ULONG_PTR)pEntryPoint;
    call.numSpecializationConstants = numSpecializationConstants;
    call.pConstantIndex = (ULONG_PTR)pConstantIndex;
    call.pConstantValue = (ULONG_PTR)pConstantValue;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpecializeShaderARB(struct qemu_syscall *call)
{
    struct qemu_glSpecializeShaderARB *c = (struct qemu_glSpecializeShaderARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpecializeShaderARB( c->shader, QEMU_G2H(c->pEntryPoint), c->numSpecializationConstants, QEMU_G2H(c->pConstantIndex), QEMU_G2H(c->pConstantValue) ));
}

#endif

struct qemu_glSpriteParameterfSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpriteParameterfSGIX( GLenum pname, GLfloat param )
{
    struct qemu_glSpriteParameterfSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPRITEPARAMETERFSGIX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpriteParameterfSGIX(struct qemu_syscall *call)
{
    struct qemu_glSpriteParameterfSGIX *c = (struct qemu_glSpriteParameterfSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpriteParameterfSGIX( c->pname, c->param ));
}

#endif

struct qemu_glSpriteParameterfvSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpriteParameterfvSGIX( GLenum pname, const GLfloat *params )
{
    struct qemu_glSpriteParameterfvSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPRITEPARAMETERFVSGIX);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpriteParameterfvSGIX(struct qemu_syscall *call)
{
    struct qemu_glSpriteParameterfvSGIX *c = (struct qemu_glSpriteParameterfvSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpriteParameterfvSGIX( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glSpriteParameteriSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpriteParameteriSGIX( GLenum pname, GLint param )
{
    struct qemu_glSpriteParameteriSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPRITEPARAMETERISGIX);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpriteParameteriSGIX(struct qemu_syscall *call)
{
    struct qemu_glSpriteParameteriSGIX *c = (struct qemu_glSpriteParameteriSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpriteParameteriSGIX( c->pname, c->param ));
}

#endif

struct qemu_glSpriteParameterivSGIX
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSpriteParameterivSGIX( GLenum pname, const GLint *params )
{
    struct qemu_glSpriteParameterivSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSPRITEPARAMETERIVSGIX);
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glSpriteParameterivSGIX(struct qemu_syscall *call)
{
    struct qemu_glSpriteParameterivSGIX *c = (struct qemu_glSpriteParameterivSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glSpriteParameterivSGIX( c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glStartInstrumentsSGIX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStartInstrumentsSGIX(void)
{
    struct qemu_glStartInstrumentsSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTARTINSTRUMENTSSGIX);

    qemu_syscall(&call.super);
}

#else

void qemu_glStartInstrumentsSGIX(struct qemu_syscall *call)
{
    struct qemu_glStartInstrumentsSGIX *c = (struct qemu_glStartInstrumentsSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glStartInstrumentsSGIX());
}

#endif

struct qemu_glStateCaptureNV
{
    struct qemu_syscall super;
    uint64_t state;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStateCaptureNV( GLuint state, GLenum mode )
{
    struct qemu_glStateCaptureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTATECAPTURENV);
    call.state = state;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glStateCaptureNV(struct qemu_syscall *call)
{
    struct qemu_glStateCaptureNV *c = (struct qemu_glStateCaptureNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStateCaptureNV( c->state, c->mode ));
}

#endif

struct qemu_glStencilClearTagEXT
{
    struct qemu_syscall super;
    uint64_t stencilTagBits;
    uint64_t stencilClearTag;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilClearTagEXT( GLsizei stencilTagBits, GLuint stencilClearTag )
{
    struct qemu_glStencilClearTagEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILCLEARTAGEXT);
    call.stencilTagBits = stencilTagBits;
    call.stencilClearTag = stencilClearTag;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilClearTagEXT(struct qemu_syscall *call)
{
    struct qemu_glStencilClearTagEXT *c = (struct qemu_glStencilClearTagEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilClearTagEXT( c->stencilTagBits, c->stencilClearTag ));
}

#endif

struct qemu_glStencilFillPathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t fillMode;
    uint64_t mask;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilFillPathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glStencilFillPathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILFILLPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.fillMode = fillMode;
    call.mask = mask;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilFillPathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glStencilFillPathInstancedNV *c = (struct qemu_glStencilFillPathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilFillPathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->fillMode, c->mask, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glStencilFillPathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t fillMode;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilFillPathNV( GLuint path, GLenum fillMode, GLuint mask )
{
    struct qemu_glStencilFillPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILFILLPATHNV);
    call.path = path;
    call.fillMode = fillMode;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilFillPathNV(struct qemu_syscall *call)
{
    struct qemu_glStencilFillPathNV *c = (struct qemu_glStencilFillPathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilFillPathNV( c->path, c->fillMode, c->mask ));
}

#endif

struct qemu_glStencilFuncSeparate
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t func;
    uint64_t ref;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilFuncSeparate( GLenum face, GLenum func, GLint ref, GLuint mask )
{
    struct qemu_glStencilFuncSeparate call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILFUNCSEPARATE);
    call.face = face;
    call.func = func;
    call.ref = ref;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilFuncSeparate(struct qemu_syscall *call)
{
    struct qemu_glStencilFuncSeparate *c = (struct qemu_glStencilFuncSeparate *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilFuncSeparate( c->face, c->func, c->ref, c->mask ));
}

#endif

struct qemu_glStencilFuncSeparateATI
{
    struct qemu_syscall super;
    uint64_t frontfunc;
    uint64_t backfunc;
    uint64_t ref;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilFuncSeparateATI( GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask )
{
    struct qemu_glStencilFuncSeparateATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILFUNCSEPARATEATI);
    call.frontfunc = frontfunc;
    call.backfunc = backfunc;
    call.ref = ref;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilFuncSeparateATI(struct qemu_syscall *call)
{
    struct qemu_glStencilFuncSeparateATI *c = (struct qemu_glStencilFuncSeparateATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilFuncSeparateATI( c->frontfunc, c->backfunc, c->ref, c->mask ));
}

#endif

struct qemu_glStencilMaskSeparate
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilMaskSeparate( GLenum face, GLuint mask )
{
    struct qemu_glStencilMaskSeparate call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILMASKSEPARATE);
    call.face = face;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilMaskSeparate(struct qemu_syscall *call)
{
    struct qemu_glStencilMaskSeparate *c = (struct qemu_glStencilMaskSeparate *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilMaskSeparate( c->face, c->mask ));
}

#endif

struct qemu_glStencilOpSeparate
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t sfail;
    uint64_t dpfail;
    uint64_t dppass;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilOpSeparate( GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass )
{
    struct qemu_glStencilOpSeparate call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILOPSEPARATE);
    call.face = face;
    call.sfail = sfail;
    call.dpfail = dpfail;
    call.dppass = dppass;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilOpSeparate(struct qemu_syscall *call)
{
    struct qemu_glStencilOpSeparate *c = (struct qemu_glStencilOpSeparate *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilOpSeparate( c->face, c->sfail, c->dpfail, c->dppass ));
}

#endif

struct qemu_glStencilOpSeparateATI
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t sfail;
    uint64_t dpfail;
    uint64_t dppass;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilOpSeparateATI( GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass )
{
    struct qemu_glStencilOpSeparateATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILOPSEPARATEATI);
    call.face = face;
    call.sfail = sfail;
    call.dpfail = dpfail;
    call.dppass = dppass;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilOpSeparateATI(struct qemu_syscall *call)
{
    struct qemu_glStencilOpSeparateATI *c = (struct qemu_glStencilOpSeparateATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilOpSeparateATI( c->face, c->sfail, c->dpfail, c->dppass ));
}

#endif

struct qemu_glStencilOpValueAMD
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilOpValueAMD( GLenum face, GLuint value )
{
    struct qemu_glStencilOpValueAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILOPVALUEAMD);
    call.face = face;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilOpValueAMD(struct qemu_syscall *call)
{
    struct qemu_glStencilOpValueAMD *c = (struct qemu_glStencilOpValueAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilOpValueAMD( c->face, c->value ));
}

#endif

struct qemu_glStencilStrokePathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t reference;
    uint64_t mask;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilStrokePathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glStencilStrokePathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILSTROKEPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.reference = reference;
    call.mask = mask;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilStrokePathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glStencilStrokePathInstancedNV *c = (struct qemu_glStencilStrokePathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilStrokePathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->reference, c->mask, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glStencilStrokePathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t reference;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilStrokePathNV( GLuint path, GLint reference, GLuint mask )
{
    struct qemu_glStencilStrokePathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILSTROKEPATHNV);
    call.path = path;
    call.reference = reference;
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilStrokePathNV(struct qemu_syscall *call)
{
    struct qemu_glStencilStrokePathNV *c = (struct qemu_glStencilStrokePathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilStrokePathNV( c->path, c->reference, c->mask ));
}

#endif

struct qemu_glStencilThenCoverFillPathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t fillMode;
    uint64_t mask;
    uint64_t coverMode;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilThenCoverFillPathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glStencilThenCoverFillPathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILTHENCOVERFILLPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.fillMode = fillMode;
    call.mask = mask;
    call.coverMode = coverMode;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilThenCoverFillPathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glStencilThenCoverFillPathInstancedNV *c = (struct qemu_glStencilThenCoverFillPathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilThenCoverFillPathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->fillMode, c->mask, c->coverMode, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glStencilThenCoverFillPathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t fillMode;
    uint64_t mask;
    uint64_t coverMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilThenCoverFillPathNV( GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode )
{
    struct qemu_glStencilThenCoverFillPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILTHENCOVERFILLPATHNV);
    call.path = path;
    call.fillMode = fillMode;
    call.mask = mask;
    call.coverMode = coverMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilThenCoverFillPathNV(struct qemu_syscall *call)
{
    struct qemu_glStencilThenCoverFillPathNV *c = (struct qemu_glStencilThenCoverFillPathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilThenCoverFillPathNV( c->path, c->fillMode, c->mask, c->coverMode ));
}

#endif

struct qemu_glStencilThenCoverStrokePathInstancedNV
{
    struct qemu_syscall super;
    uint64_t numPaths;
    uint64_t pathNameType;
    uint64_t paths;
    uint64_t pathBase;
    uint64_t reference;
    uint64_t mask;
    uint64_t coverMode;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilThenCoverStrokePathInstancedNV( GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glStencilThenCoverStrokePathInstancedNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILTHENCOVERSTROKEPATHINSTANCEDNV);
    call.numPaths = numPaths;
    call.pathNameType = pathNameType;
    call.paths = (ULONG_PTR)paths;
    call.pathBase = pathBase;
    call.reference = reference;
    call.mask = mask;
    call.coverMode = coverMode;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilThenCoverStrokePathInstancedNV(struct qemu_syscall *call)
{
    struct qemu_glStencilThenCoverStrokePathInstancedNV *c = (struct qemu_glStencilThenCoverStrokePathInstancedNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilThenCoverStrokePathInstancedNV( c->numPaths, c->pathNameType, QEMU_G2H(c->paths), c->pathBase, c->reference, c->mask, c->coverMode, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glStencilThenCoverStrokePathNV
{
    struct qemu_syscall super;
    uint64_t path;
    uint64_t reference;
    uint64_t mask;
    uint64_t coverMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStencilThenCoverStrokePathNV( GLuint path, GLint reference, GLuint mask, GLenum coverMode )
{
    struct qemu_glStencilThenCoverStrokePathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTENCILTHENCOVERSTROKEPATHNV);
    call.path = path;
    call.reference = reference;
    call.mask = mask;
    call.coverMode = coverMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glStencilThenCoverStrokePathNV(struct qemu_syscall *call)
{
    struct qemu_glStencilThenCoverStrokePathNV *c = (struct qemu_glStencilThenCoverStrokePathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glStencilThenCoverStrokePathNV( c->path, c->reference, c->mask, c->coverMode ));
}

#endif

struct qemu_glStopInstrumentsSGIX
{
    struct qemu_syscall super;
    uint64_t marker;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStopInstrumentsSGIX( GLint marker )
{
    struct qemu_glStopInstrumentsSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTOPINSTRUMENTSSGIX);
    call.marker = marker;

    qemu_syscall(&call.super);
}

#else

void qemu_glStopInstrumentsSGIX(struct qemu_syscall *call)
{
    struct qemu_glStopInstrumentsSGIX *c = (struct qemu_glStopInstrumentsSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glStopInstrumentsSGIX( c->marker ));
}

#endif

struct qemu_glStringMarkerGREMEDY
{
    struct qemu_syscall super;
    uint64_t len;
    uint64_t string;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glStringMarkerGREMEDY( GLsizei len, const void *string )
{
    struct qemu_glStringMarkerGREMEDY call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSTRINGMARKERGREMEDY);
    call.len = len;
    call.string = (ULONG_PTR)string;

    qemu_syscall(&call.super);
}

#else

void qemu_glStringMarkerGREMEDY(struct qemu_syscall *call)
{
    struct qemu_glStringMarkerGREMEDY *c = (struct qemu_glStringMarkerGREMEDY *)call;
    WINE_FIXME("Unverified\n");
    (p_glStringMarkerGREMEDY( c->len, QEMU_G2H(c->string) ));
}

#endif

struct qemu_glSubpixelPrecisionBiasNV
{
    struct qemu_syscall super;
    uint64_t xbits;
    uint64_t ybits;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSubpixelPrecisionBiasNV( GLuint xbits, GLuint ybits )
{
    struct qemu_glSubpixelPrecisionBiasNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSUBPIXELPRECISIONBIASNV);
    call.xbits = xbits;
    call.ybits = ybits;

    qemu_syscall(&call.super);
}

#else

void qemu_glSubpixelPrecisionBiasNV(struct qemu_syscall *call)
{
    struct qemu_glSubpixelPrecisionBiasNV *c = (struct qemu_glSubpixelPrecisionBiasNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glSubpixelPrecisionBiasNV( c->xbits, c->ybits ));
}

#endif

struct qemu_glSwizzleEXT
{
    struct qemu_syscall super;
    uint64_t res;
    uint64_t in;
    uint64_t outX;
    uint64_t outY;
    uint64_t outZ;
    uint64_t outW;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSwizzleEXT( GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW )
{
    struct qemu_glSwizzleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSWIZZLEEXT);
    call.res = res;
    call.in = in;
    call.outX = outX;
    call.outY = outY;
    call.outZ = outZ;
    call.outW = outW;

    qemu_syscall(&call.super);
}

#else

void qemu_glSwizzleEXT(struct qemu_syscall *call)
{
    struct qemu_glSwizzleEXT *c = (struct qemu_glSwizzleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glSwizzleEXT( c->res, c->in, c->outX, c->outY, c->outZ, c->outW ));
}

#endif

struct qemu_glSyncTextureINTEL
{
    struct qemu_syscall super;
    uint64_t texture;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glSyncTextureINTEL( GLuint texture )
{
    struct qemu_glSyncTextureINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLSYNCTEXTUREINTEL);
    call.texture = texture;

    qemu_syscall(&call.super);
}

#else

void qemu_glSyncTextureINTEL(struct qemu_syscall *call)
{
    struct qemu_glSyncTextureINTEL *c = (struct qemu_glSyncTextureINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glSyncTextureINTEL( c->texture ));
}

#endif

struct qemu_glTagSampleBufferSGIX
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTagSampleBufferSGIX(void)
{
    struct qemu_glTagSampleBufferSGIX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTAGSAMPLEBUFFERSGIX);

    qemu_syscall(&call.super);
}

#else

void qemu_glTagSampleBufferSGIX(struct qemu_syscall *call)
{
    struct qemu_glTagSampleBufferSGIX *c = (struct qemu_glTagSampleBufferSGIX *)call;
    WINE_FIXME("Unverified\n");
    (p_glTagSampleBufferSGIX());
}

#endif

struct qemu_glTangent3bEXT
{
    struct qemu_syscall super;
    uint64_t tx;
    uint64_t ty;
    uint64_t tz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3bEXT( GLbyte tx, GLbyte ty, GLbyte tz )
{
    struct qemu_glTangent3bEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3BEXT);
    call.tx = tx;
    call.ty = ty;
    call.tz = tz;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3bEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3bEXT *c = (struct qemu_glTangent3bEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3bEXT( c->tx, c->ty, c->tz ));
}

#endif

struct qemu_glTangent3bvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3bvEXT( const GLbyte *v )
{
    struct qemu_glTangent3bvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3BVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3bvEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3bvEXT *c = (struct qemu_glTangent3bvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3bvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTangent3dEXT
{
    struct qemu_syscall super;
    double tx;
    double ty;
    double tz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3dEXT( GLdouble tx, GLdouble ty, GLdouble tz )
{
    struct qemu_glTangent3dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3DEXT);
    call.tx = tx;
    call.ty = ty;
    call.tz = tz;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3dEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3dEXT *c = (struct qemu_glTangent3dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3dEXT( c->tx, c->ty, c->tz ));
}

#endif

struct qemu_glTangent3dvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3dvEXT( const GLdouble *v )
{
    struct qemu_glTangent3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3DVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3dvEXT *c = (struct qemu_glTangent3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3dvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTangent3fEXT
{
    struct qemu_syscall super;
    double tx;
    double ty;
    double tz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3fEXT( GLfloat tx, GLfloat ty, GLfloat tz )
{
    struct qemu_glTangent3fEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3FEXT);
    call.tx = tx;
    call.ty = ty;
    call.tz = tz;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3fEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3fEXT *c = (struct qemu_glTangent3fEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3fEXT( c->tx, c->ty, c->tz ));
}

#endif

struct qemu_glTangent3fvEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3fvEXT( const GLfloat *v )
{
    struct qemu_glTangent3fvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3FVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3fvEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3fvEXT *c = (struct qemu_glTangent3fvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3fvEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTangent3iEXT
{
    struct qemu_syscall super;
    uint64_t tx;
    uint64_t ty;
    uint64_t tz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3iEXT( GLint tx, GLint ty, GLint tz )
{
    struct qemu_glTangent3iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3IEXT);
    call.tx = tx;
    call.ty = ty;
    call.tz = tz;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3iEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3iEXT *c = (struct qemu_glTangent3iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3iEXT( c->tx, c->ty, c->tz ));
}

#endif

struct qemu_glTangent3ivEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3ivEXT( const GLint *v )
{
    struct qemu_glTangent3ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3IVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3ivEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3ivEXT *c = (struct qemu_glTangent3ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3ivEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTangent3sEXT
{
    struct qemu_syscall super;
    uint64_t tx;
    uint64_t ty;
    uint64_t tz;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3sEXT( GLshort tx, GLshort ty, GLshort tz )
{
    struct qemu_glTangent3sEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3SEXT);
    call.tx = tx;
    call.ty = ty;
    call.tz = tz;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3sEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3sEXT *c = (struct qemu_glTangent3sEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3sEXT( c->tx, c->ty, c->tz ));
}

#endif

struct qemu_glTangent3svEXT
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangent3svEXT( const GLshort *v )
{
    struct qemu_glTangent3svEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENT3SVEXT);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangent3svEXT(struct qemu_syscall *call)
{
    struct qemu_glTangent3svEXT *c = (struct qemu_glTangent3svEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangent3svEXT( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTangentPointerEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTangentPointerEXT( GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glTangentPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTANGENTPOINTEREXT);
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTangentPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glTangentPointerEXT *c = (struct qemu_glTangentPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTangentPointerEXT( c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glTbufferMask3DFX
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTbufferMask3DFX( GLuint mask )
{
    struct qemu_glTbufferMask3DFX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTBUFFERMASK3DFX);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glTbufferMask3DFX(struct qemu_syscall *call)
{
    struct qemu_glTbufferMask3DFX *c = (struct qemu_glTbufferMask3DFX *)call;
    WINE_FIXME("Unverified\n");
    (p_glTbufferMask3DFX( c->mask ));
}

#endif

struct qemu_glTessellationFactorAMD
{
    struct qemu_syscall super;
    double factor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTessellationFactorAMD( GLfloat factor )
{
    struct qemu_glTessellationFactorAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTESSELLATIONFACTORAMD);
    call.factor = factor;

    qemu_syscall(&call.super);
}

#else

void qemu_glTessellationFactorAMD(struct qemu_syscall *call)
{
    struct qemu_glTessellationFactorAMD *c = (struct qemu_glTessellationFactorAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glTessellationFactorAMD( c->factor ));
}

#endif

struct qemu_glTessellationModeAMD
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTessellationModeAMD( GLenum mode )
{
    struct qemu_glTessellationModeAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTESSELLATIONMODEAMD);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTessellationModeAMD(struct qemu_syscall *call)
{
    struct qemu_glTessellationModeAMD *c = (struct qemu_glTessellationModeAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glTessellationModeAMD( c->mode ));
}

#endif

struct qemu_glTestFenceAPPLE
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glTestFenceAPPLE( GLuint fence )
{
    struct qemu_glTestFenceAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTESTFENCEAPPLE);
    call.fence = fence;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glTestFenceAPPLE(struct qemu_syscall *call)
{
    struct qemu_glTestFenceAPPLE *c = (struct qemu_glTestFenceAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glTestFenceAPPLE( c->fence ));
}

#endif

struct qemu_glTestFenceNV
{
    struct qemu_syscall super;
    uint64_t fence;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glTestFenceNV( GLuint fence )
{
    struct qemu_glTestFenceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTESTFENCENV);
    call.fence = fence;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glTestFenceNV(struct qemu_syscall *call)
{
    struct qemu_glTestFenceNV *c = (struct qemu_glTestFenceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glTestFenceNV( c->fence ));
}

#endif

struct qemu_glTestObjectAPPLE
{
    struct qemu_syscall super;
    uint64_t object;
    uint64_t name;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glTestObjectAPPLE( GLenum object, GLuint name )
{
    struct qemu_glTestObjectAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTESTOBJECTAPPLE);
    call.object = object;
    call.name = name;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glTestObjectAPPLE(struct qemu_syscall *call)
{
    struct qemu_glTestObjectAPPLE *c = (struct qemu_glTestObjectAPPLE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glTestObjectAPPLE( c->object, c->name ));
}

#endif

struct qemu_glTexAttachMemoryNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexAttachMemoryNV( GLenum target, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexAttachMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXATTACHMEMORYNV);
    call.target = target;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexAttachMemoryNV(struct qemu_syscall *call)
{
    struct qemu_glTexAttachMemoryNV *c = (struct qemu_glTexAttachMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexAttachMemoryNV( c->target, c->memory, c->offset ));
}

#endif

struct qemu_glTexBuffer
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBuffer( GLenum target, GLenum internalformat, GLuint buffer )
{
    struct qemu_glTexBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUFFER);
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBuffer(struct qemu_syscall *call)
{
    struct qemu_glTexBuffer *c = (struct qemu_glTexBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBuffer( c->target, c->internalformat, c->buffer ));
}

#endif

struct qemu_glTexBufferARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBufferARB( GLenum target, GLenum internalformat, GLuint buffer )
{
    struct qemu_glTexBufferARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUFFERARB);
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBufferARB(struct qemu_syscall *call)
{
    struct qemu_glTexBufferARB *c = (struct qemu_glTexBufferARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBufferARB( c->target, c->internalformat, c->buffer ));
}

#endif

struct qemu_glTexBufferEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBufferEXT( GLenum target, GLenum internalformat, GLuint buffer )
{
    struct qemu_glTexBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUFFEREXT);
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glTexBufferEXT *c = (struct qemu_glTexBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBufferEXT( c->target, c->internalformat, c->buffer ));
}

#endif

struct qemu_glTexBufferRange
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBufferRange( GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glTexBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUFFERRANGE);
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBufferRange(struct qemu_syscall *call)
{
    struct qemu_glTexBufferRange *c = (struct qemu_glTexBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBufferRange( c->target, c->internalformat, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glTexBumpParameterfvATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBumpParameterfvATI( GLenum pname, const GLfloat *param )
{
    struct qemu_glTexBumpParameterfvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUMPPARAMETERFVATI);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBumpParameterfvATI(struct qemu_syscall *call)
{
    struct qemu_glTexBumpParameterfvATI *c = (struct qemu_glTexBumpParameterfvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBumpParameterfvATI( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glTexBumpParameterivATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexBumpParameterivATI( GLenum pname, const GLint *param )
{
    struct qemu_glTexBumpParameterivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXBUMPPARAMETERIVATI);
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexBumpParameterivATI(struct qemu_syscall *call)
{
    struct qemu_glTexBumpParameterivATI *c = (struct qemu_glTexBumpParameterivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexBumpParameterivATI( c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glTexCoord1bOES
{
    struct qemu_syscall super;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1bOES( GLbyte s )
{
    struct qemu_glTexCoord1bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1BOES);
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1bOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1bOES *c = (struct qemu_glTexCoord1bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1bOES( c->s ));
}

#endif

struct qemu_glTexCoord1bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1bvOES( const GLbyte *coords )
{
    struct qemu_glTexCoord1bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1bvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1bvOES *c = (struct qemu_glTexCoord1bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord1hNV
{
    struct qemu_syscall super;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1hNV( GLhalfNV s )
{
    struct qemu_glTexCoord1hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1HNV);
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1hNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1hNV *c = (struct qemu_glTexCoord1hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1hNV( c->s ));
}

#endif

struct qemu_glTexCoord1hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1hvNV( const GLhalfNV *v )
{
    struct qemu_glTexCoord1hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1hvNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1hvNV *c = (struct qemu_glTexCoord1hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord1xOES
{
    struct qemu_syscall super;
    uint64_t s;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1xOES( GLfixed s )
{
    struct qemu_glTexCoord1xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1XOES);
    call.s = s;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1xOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1xOES *c = (struct qemu_glTexCoord1xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1xOES( c->s ));
}

#endif

struct qemu_glTexCoord1xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord1xvOES( const GLfixed *coords )
{
    struct qemu_glTexCoord1xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD1XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord1xvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord1xvOES *c = (struct qemu_glTexCoord1xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord1xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord2bOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2bOES( GLbyte s, GLbyte t )
{
    struct qemu_glTexCoord2bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2BOES);
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2bOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2bOES *c = (struct qemu_glTexCoord2bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2bOES( c->s, c->t ));
}

#endif

struct qemu_glTexCoord2bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2bvOES( const GLbyte *coords )
{
    struct qemu_glTexCoord2bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2bvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2bvOES *c = (struct qemu_glTexCoord2bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord2fColor3fVertex3fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double r;
    double g;
    double b;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor3fVertex3fSUN( GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glTexCoord2fColor3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR3FVERTEX3FSUN);
    call.s = s;
    call.t = t;
    call.r = r;
    call.g = g;
    call.b = b;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor3fVertex3fSUN *c = (struct qemu_glTexCoord2fColor3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor3fVertex3fSUN( c->s, c->t, c->r, c->g, c->b, c->x, c->y, c->z ));
}

#endif

struct qemu_glTexCoord2fColor3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor3fVertex3fvSUN( const GLfloat *tc, const GLfloat *c, const GLfloat *v )
{
    struct qemu_glTexCoord2fColor3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor3fVertex3fvSUN *c = (struct qemu_glTexCoord2fColor3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor3fVertex3fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2fColor4fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double r;
    double g;
    double b;
    double a;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor4fNormal3fVertex3fSUN( GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glTexCoord2fColor4fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN);
    call.s = s;
    call.t = t;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor4fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor4fNormal3fVertex3fSUN *c = (struct qemu_glTexCoord2fColor4fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor4fNormal3fVertex3fSUN( c->s, c->t, c->r, c->g, c->b, c->a, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glTexCoord2fColor4fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t c;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor4fNormal3fVertex3fvSUN( const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glTexCoord2fColor4fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.c = (ULONG_PTR)c;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor4fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor4fNormal3fVertex3fvSUN *c = (struct qemu_glTexCoord2fColor4fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor4fNormal3fVertex3fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->c), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2fColor4ubVertex3fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    uint64_t r;
    uint64_t g;
    uint64_t b;
    uint64_t a;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor4ubVertex3fSUN( GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glTexCoord2fColor4ubVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN);
    call.s = s;
    call.t = t;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor4ubVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor4ubVertex3fSUN *c = (struct qemu_glTexCoord2fColor4ubVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor4ubVertex3fSUN( c->s, c->t, c->r, c->g, c->b, c->a, c->x, c->y, c->z ));
}

#endif

struct qemu_glTexCoord2fColor4ubVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t c;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fColor4ubVertex3fvSUN( const GLfloat *tc, const GLubyte *c, const GLfloat *v )
{
    struct qemu_glTexCoord2fColor4ubVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.c = (ULONG_PTR)c;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fColor4ubVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fColor4ubVertex3fvSUN *c = (struct qemu_glTexCoord2fColor4ubVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fColor4ubVertex3fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->c), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2fNormal3fVertex3fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fNormal3fVertex3fSUN( GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glTexCoord2fNormal3fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FNORMAL3FVERTEX3FSUN);
    call.s = s;
    call.t = t;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fNormal3fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fNormal3fVertex3fSUN *c = (struct qemu_glTexCoord2fNormal3fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fNormal3fVertex3fSUN( c->s, c->t, c->nx, c->ny, c->nz, c->x, c->y, c->z ));
}

#endif

struct qemu_glTexCoord2fNormal3fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fNormal3fVertex3fvSUN( const GLfloat *tc, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glTexCoord2fNormal3fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fNormal3fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fNormal3fVertex3fvSUN *c = (struct qemu_glTexCoord2fNormal3fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fNormal3fVertex3fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2fVertex3fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fVertex3fSUN( GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glTexCoord2fVertex3fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FVERTEX3FSUN);
    call.s = s;
    call.t = t;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fVertex3fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fVertex3fSUN *c = (struct qemu_glTexCoord2fVertex3fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fVertex3fSUN( c->s, c->t, c->x, c->y, c->z ));
}

#endif

struct qemu_glTexCoord2fVertex3fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2fVertex3fvSUN( const GLfloat *tc, const GLfloat *v )
{
    struct qemu_glTexCoord2fVertex3fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2FVERTEX3FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2fVertex3fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2fVertex3fvSUN *c = (struct qemu_glTexCoord2fVertex3fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2fVertex3fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2hNV
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2hNV( GLhalfNV s, GLhalfNV t )
{
    struct qemu_glTexCoord2hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2HNV);
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2hNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2hNV *c = (struct qemu_glTexCoord2hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2hNV( c->s, c->t ));
}

#endif

struct qemu_glTexCoord2hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2hvNV( const GLhalfNV *v )
{
    struct qemu_glTexCoord2hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2hvNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2hvNV *c = (struct qemu_glTexCoord2hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord2xOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2xOES( GLfixed s, GLfixed t )
{
    struct qemu_glTexCoord2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2XOES);
    call.s = s;
    call.t = t;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2xOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2xOES *c = (struct qemu_glTexCoord2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2xOES( c->s, c->t ));
}

#endif

struct qemu_glTexCoord2xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord2xvOES( const GLfixed *coords )
{
    struct qemu_glTexCoord2xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD2XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord2xvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord2xvOES *c = (struct qemu_glTexCoord2xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord2xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord3bOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3bOES( GLbyte s, GLbyte t, GLbyte r )
{
    struct qemu_glTexCoord3bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3BOES);
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3bOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3bOES *c = (struct qemu_glTexCoord3bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3bOES( c->s, c->t, c->r ));
}

#endif

struct qemu_glTexCoord3bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3bvOES( const GLbyte *coords )
{
    struct qemu_glTexCoord3bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3bvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3bvOES *c = (struct qemu_glTexCoord3bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord3hNV
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3hNV( GLhalfNV s, GLhalfNV t, GLhalfNV r )
{
    struct qemu_glTexCoord3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3HNV);
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3hNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3hNV *c = (struct qemu_glTexCoord3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3hNV( c->s, c->t, c->r ));
}

#endif

struct qemu_glTexCoord3hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3hvNV( const GLhalfNV *v )
{
    struct qemu_glTexCoord3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3hvNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3hvNV *c = (struct qemu_glTexCoord3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord3xOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3xOES( GLfixed s, GLfixed t, GLfixed r )
{
    struct qemu_glTexCoord3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3XOES);
    call.s = s;
    call.t = t;
    call.r = r;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3xOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3xOES *c = (struct qemu_glTexCoord3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3xOES( c->s, c->t, c->r ));
}

#endif

struct qemu_glTexCoord3xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord3xvOES( const GLfixed *coords )
{
    struct qemu_glTexCoord3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD3XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord3xvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord3xvOES *c = (struct qemu_glTexCoord3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord3xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord4bOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4bOES( GLbyte s, GLbyte t, GLbyte r, GLbyte q )
{
    struct qemu_glTexCoord4bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4BOES);
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4bOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4bOES *c = (struct qemu_glTexCoord4bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4bOES( c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glTexCoord4bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4bvOES( const GLbyte *coords )
{
    struct qemu_glTexCoord4bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4bvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4bvOES *c = (struct qemu_glTexCoord4bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoord4fColor4fNormal3fVertex4fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double p;
    double q;
    double r;
    double g;
    double b;
    double a;
    double nx;
    double ny;
    double nz;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4fColor4fNormal3fVertex4fSUN( GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glTexCoord4fColor4fNormal3fVertex4fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN);
    call.s = s;
    call.t = t;
    call.p = p;
    call.q = q;
    call.r = r;
    call.g = g;
    call.b = b;
    call.a = a;
    call.nx = nx;
    call.ny = ny;
    call.nz = nz;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4fColor4fNormal3fVertex4fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4fColor4fNormal3fVertex4fSUN *c = (struct qemu_glTexCoord4fColor4fNormal3fVertex4fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4fColor4fNormal3fVertex4fSUN( c->s, c->t, c->p, c->q, c->r, c->g, c->b, c->a, c->nx, c->ny, c->nz, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glTexCoord4fColor4fNormal3fVertex4fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t c;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4fColor4fNormal3fVertex4fvSUN( const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v )
{
    struct qemu_glTexCoord4fColor4fNormal3fVertex4fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.c = (ULONG_PTR)c;
    call.n = (ULONG_PTR)n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4fColor4fNormal3fVertex4fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4fColor4fNormal3fVertex4fvSUN *c = (struct qemu_glTexCoord4fColor4fNormal3fVertex4fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4fColor4fNormal3fVertex4fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->c), QEMU_G2H(c->n), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord4fVertex4fSUN
{
    struct qemu_syscall super;
    double s;
    double t;
    double p;
    double q;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4fVertex4fSUN( GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glTexCoord4fVertex4fSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4FVERTEX4FSUN);
    call.s = s;
    call.t = t;
    call.p = p;
    call.q = q;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4fVertex4fSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4fVertex4fSUN *c = (struct qemu_glTexCoord4fVertex4fSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4fVertex4fSUN( c->s, c->t, c->p, c->q, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glTexCoord4fVertex4fvSUN
{
    struct qemu_syscall super;
    uint64_t tc;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4fVertex4fvSUN( const GLfloat *tc, const GLfloat *v )
{
    struct qemu_glTexCoord4fVertex4fvSUN call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4FVERTEX4FVSUN);
    call.tc = (ULONG_PTR)tc;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4fVertex4fvSUN(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4fVertex4fvSUN *c = (struct qemu_glTexCoord4fVertex4fvSUN *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4fVertex4fvSUN( QEMU_G2H(c->tc), QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord4hNV
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4hNV( GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q )
{
    struct qemu_glTexCoord4hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4HNV);
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4hNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4hNV *c = (struct qemu_glTexCoord4hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4hNV( c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glTexCoord4hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4hvNV( const GLhalfNV *v )
{
    struct qemu_glTexCoord4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4hvNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4hvNV *c = (struct qemu_glTexCoord4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glTexCoord4xOES
{
    struct qemu_syscall super;
    uint64_t s;
    uint64_t t;
    uint64_t r;
    uint64_t q;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4xOES( GLfixed s, GLfixed t, GLfixed r, GLfixed q )
{
    struct qemu_glTexCoord4xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4XOES);
    call.s = s;
    call.t = t;
    call.r = r;
    call.q = q;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4xOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4xOES *c = (struct qemu_glTexCoord4xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4xOES( c->s, c->t, c->r, c->q ));
}

#endif

struct qemu_glTexCoord4xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoord4xvOES( const GLfixed *coords )
{
    struct qemu_glTexCoord4xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORD4XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoord4xvOES(struct qemu_syscall *call)
{
    struct qemu_glTexCoord4xvOES *c = (struct qemu_glTexCoord4xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoord4xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoordFormatNV
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordFormatNV( GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glTexCoordFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDFORMATNV);
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordFormatNV(struct qemu_syscall *call)
{
    struct qemu_glTexCoordFormatNV *c = (struct qemu_glTexCoordFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordFormatNV( c->size, c->type, c->stride ));
}

#endif

struct qemu_glTexCoordP1ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP1ui( GLenum type, GLuint coords )
{
    struct qemu_glTexCoordP1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP1UI);
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP1ui(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP1ui *c = (struct qemu_glTexCoordP1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP1ui( c->type, c->coords ));
}

#endif

struct qemu_glTexCoordP1uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP1uiv( GLenum type, const GLuint *coords )
{
    struct qemu_glTexCoordP1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP1UIV);
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP1uiv(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP1uiv *c = (struct qemu_glTexCoordP1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP1uiv( c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoordP2ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP2ui( GLenum type, GLuint coords )
{
    struct qemu_glTexCoordP2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP2UI);
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP2ui(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP2ui *c = (struct qemu_glTexCoordP2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP2ui( c->type, c->coords ));
}

#endif

struct qemu_glTexCoordP2uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP2uiv( GLenum type, const GLuint *coords )
{
    struct qemu_glTexCoordP2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP2UIV);
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP2uiv(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP2uiv *c = (struct qemu_glTexCoordP2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP2uiv( c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoordP3ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP3ui( GLenum type, GLuint coords )
{
    struct qemu_glTexCoordP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP3UI);
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP3ui(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP3ui *c = (struct qemu_glTexCoordP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP3ui( c->type, c->coords ));
}

#endif

struct qemu_glTexCoordP3uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP3uiv( GLenum type, const GLuint *coords )
{
    struct qemu_glTexCoordP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP3UIV);
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP3uiv(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP3uiv *c = (struct qemu_glTexCoordP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP3uiv( c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoordP4ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP4ui( GLenum type, GLuint coords )
{
    struct qemu_glTexCoordP4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP4UI);
    call.type = type;
    call.coords = coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP4ui(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP4ui *c = (struct qemu_glTexCoordP4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP4ui( c->type, c->coords ));
}

#endif

struct qemu_glTexCoordP4uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordP4uiv( GLenum type, const GLuint *coords )
{
    struct qemu_glTexCoordP4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDP4UIV);
    call.type = type;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordP4uiv(struct qemu_syscall *call)
{
    struct qemu_glTexCoordP4uiv *c = (struct qemu_glTexCoordP4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordP4uiv( c->type, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glTexCoordPointerEXT
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordPointerEXT( GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer )
{
    struct qemu_glTexCoordPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDPOINTEREXT);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glTexCoordPointerEXT *c = (struct qemu_glTexCoordPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordPointerEXT( c->size, c->type, c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glTexCoordPointerListIBM
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordPointerListIBM( GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glTexCoordPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDPOINTERLISTIBM);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glTexCoordPointerListIBM *c = (struct qemu_glTexCoordPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordPointerListIBM( c->size, c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glTexCoordPointervINTEL
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexCoordPointervINTEL( GLint size, GLenum type, const void **pointer )
{
    struct qemu_glTexCoordPointervINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXCOORDPOINTERVINTEL);
    call.size = size;
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexCoordPointervINTEL(struct qemu_syscall *call)
{
    struct qemu_glTexCoordPointervINTEL *c = (struct qemu_glTexCoordPointervINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexCoordPointervINTEL( c->size, c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glTexEnvxOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexEnvxOES( GLenum target, GLenum pname, GLfixed param )
{
    struct qemu_glTexEnvxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXENVXOES);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexEnvxOES(struct qemu_syscall *call)
{
    struct qemu_glTexEnvxOES *c = (struct qemu_glTexEnvxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexEnvxOES( c->target, c->pname, c->param ));
}

#endif

struct qemu_glTexEnvxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexEnvxvOES( GLenum target, GLenum pname, const GLfixed *params )
{
    struct qemu_glTexEnvxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXENVXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexEnvxvOES(struct qemu_syscall *call)
{
    struct qemu_glTexEnvxvOES *c = (struct qemu_glTexEnvxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexEnvxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexFilterFuncSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t filter;
    uint64_t n;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexFilterFuncSGIS( GLenum target, GLenum filter, GLsizei n, const GLfloat *weights )
{
    struct qemu_glTexFilterFuncSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXFILTERFUNCSGIS);
    call.target = target;
    call.filter = filter;
    call.n = n;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexFilterFuncSGIS(struct qemu_syscall *call)
{
    struct qemu_glTexFilterFuncSGIS *c = (struct qemu_glTexFilterFuncSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexFilterFuncSGIS( c->target, c->filter, c->n, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glTexGenxOES
{
    struct qemu_syscall super;
    uint64_t coord;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexGenxOES( GLenum coord, GLenum pname, GLfixed param )
{
    struct qemu_glTexGenxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXGENXOES);
    call.coord = coord;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexGenxOES(struct qemu_syscall *call)
{
    struct qemu_glTexGenxOES *c = (struct qemu_glTexGenxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexGenxOES( c->coord, c->pname, c->param ));
}

#endif

struct qemu_glTexGenxvOES
{
    struct qemu_syscall super;
    uint64_t coord;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexGenxvOES( GLenum coord, GLenum pname, const GLfixed *params )
{
    struct qemu_glTexGenxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXGENXVOES);
    call.coord = coord;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexGenxvOES(struct qemu_syscall *call)
{
    struct qemu_glTexGenxvOES *c = (struct qemu_glTexGenxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexGenxvOES( c->coord, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexImage2DMultisample
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage2DMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations )
{
    struct qemu_glTexImage2DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE2DMULTISAMPLE);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage2DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTexImage2DMultisample *c = (struct qemu_glTexImage2DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage2DMultisample( c->target, c->samples, c->internalformat, c->width, c->height, c->fixedsamplelocations ));
}

#endif

struct qemu_glTexImage2DMultisampleCoverageNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage2DMultisampleCoverageNV( GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations )
{
    struct qemu_glTexImage2DMultisampleCoverageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE2DMULTISAMPLECOVERAGENV);
    call.target = target;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage2DMultisampleCoverageNV(struct qemu_syscall *call)
{
    struct qemu_glTexImage2DMultisampleCoverageNV *c = (struct qemu_glTexImage2DMultisampleCoverageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage2DMultisampleCoverageNV( c->target, c->coverageSamples, c->colorSamples, c->internalFormat, c->width, c->height, c->fixedSampleLocations ));
}

#endif

struct qemu_glTexImage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage3D( GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE3D);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage3D(struct qemu_syscall *call)
{
    struct qemu_glTexImage3D *c = (struct qemu_glTexImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage3D( c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexImage3DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage3DEXT( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE3DEXT);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexImage3DEXT *c = (struct qemu_glTexImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage3DEXT( c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexImage3DMultisample
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage3DMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations )
{
    struct qemu_glTexImage3DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE3DMULTISAMPLE);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage3DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTexImage3DMultisample *c = (struct qemu_glTexImage3DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage3DMultisample( c->target, c->samples, c->internalformat, c->width, c->height, c->depth, c->fixedsamplelocations ));
}

#endif

struct qemu_glTexImage3DMultisampleCoverageNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage3DMultisampleCoverageNV( GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations )
{
    struct qemu_glTexImage3DMultisampleCoverageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE3DMULTISAMPLECOVERAGENV);
    call.target = target;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage3DMultisampleCoverageNV(struct qemu_syscall *call)
{
    struct qemu_glTexImage3DMultisampleCoverageNV *c = (struct qemu_glTexImage3DMultisampleCoverageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage3DMultisampleCoverageNV( c->target, c->coverageSamples, c->colorSamples, c->internalFormat, c->width, c->height, c->depth, c->fixedSampleLocations ));
}

#endif

struct qemu_glTexImage4DSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t size4d;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexImage4DSGIS( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexImage4DSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXIMAGE4DSGIS);
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.size4d = size4d;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexImage4DSGIS(struct qemu_syscall *call)
{
    struct qemu_glTexImage4DSGIS *c = (struct qemu_glTexImage4DSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexImage4DSGIS( c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->size4d, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexPageCommitmentARB
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t commit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexPageCommitmentARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit )
{
    struct qemu_glTexPageCommitmentARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPAGECOMMITMENTARB);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.commit = commit;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexPageCommitmentARB(struct qemu_syscall *call)
{
    struct qemu_glTexPageCommitmentARB *c = (struct qemu_glTexPageCommitmentARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexPageCommitmentARB( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->commit ));
}

#endif

struct qemu_glTexParameterIiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterIiv( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glTexParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERIIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glTexParameterIiv *c = (struct qemu_glTexParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterIiv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterIivEXT( GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glTexParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERIIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glTexParameterIivEXT *c = (struct qemu_glTexParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterIivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexParameterIuiv
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterIuiv( GLenum target, GLenum pname, const GLuint *params )
{
    struct qemu_glTexParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERIUIV);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glTexParameterIuiv *c = (struct qemu_glTexParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterIuiv( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterIuivEXT( GLenum target, GLenum pname, const GLuint *params )
{
    struct qemu_glTexParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERIUIVEXT);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glTexParameterIuivEXT *c = (struct qemu_glTexParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterIuivEXT( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexParameterxOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterxOES( GLenum target, GLenum pname, GLfixed param )
{
    struct qemu_glTexParameterxOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERXOES);
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterxOES(struct qemu_syscall *call)
{
    struct qemu_glTexParameterxOES *c = (struct qemu_glTexParameterxOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterxOES( c->target, c->pname, c->param ));
}

#endif

struct qemu_glTexParameterxvOES
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexParameterxvOES( GLenum target, GLenum pname, const GLfixed *params )
{
    struct qemu_glTexParameterxvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXPARAMETERXVOES);
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexParameterxvOES(struct qemu_syscall *call)
{
    struct qemu_glTexParameterxvOES *c = (struct qemu_glTexParameterxvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexParameterxvOES( c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTexRenderbufferNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexRenderbufferNV( GLenum target, GLuint renderbuffer )
{
    struct qemu_glTexRenderbufferNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXRENDERBUFFERNV);
    call.target = target;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexRenderbufferNV(struct qemu_syscall *call)
{
    struct qemu_glTexRenderbufferNV *c = (struct qemu_glTexRenderbufferNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexRenderbufferNV( c->target, c->renderbuffer ));
}

#endif

struct qemu_glTexStorage1D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorage1D( GLenum target, GLsizei levels, GLenum internalformat, GLsizei width )
{
    struct qemu_glTexStorage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGE1D);
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorage1D(struct qemu_syscall *call)
{
    struct qemu_glTexStorage1D *c = (struct qemu_glTexStorage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorage1D( c->target, c->levels, c->internalformat, c->width ));
}

#endif

struct qemu_glTexStorage2D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorage2D( GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glTexStorage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGE2D);
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorage2D(struct qemu_syscall *call)
{
    struct qemu_glTexStorage2D *c = (struct qemu_glTexStorage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorage2D( c->target, c->levels, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glTexStorage2DMultisample
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorage2DMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations )
{
    struct qemu_glTexStorage2DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGE2DMULTISAMPLE);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorage2DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTexStorage2DMultisample *c = (struct qemu_glTexStorage2DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorage2DMultisample( c->target, c->samples, c->internalformat, c->width, c->height, c->fixedsamplelocations ));
}

#endif

struct qemu_glTexStorage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorage3D( GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glTexStorage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGE3D);
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorage3D(struct qemu_syscall *call)
{
    struct qemu_glTexStorage3D *c = (struct qemu_glTexStorage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorage3D( c->target, c->levels, c->internalformat, c->width, c->height, c->depth ));
}

#endif

struct qemu_glTexStorage3DMultisample
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorage3DMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations )
{
    struct qemu_glTexStorage3DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGE3DMULTISAMPLE);
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorage3DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTexStorage3DMultisample *c = (struct qemu_glTexStorage3DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorage3DMultisample( c->target, c->samples, c->internalformat, c->width, c->height, c->depth, c->fixedsamplelocations ));
}

#endif

struct qemu_glTexStorageMem1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageMem1DEXT( GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexStorageMem1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGEMEM1DEXT);
    call.target = target;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageMem1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexStorageMem1DEXT *c = (struct qemu_glTexStorageMem1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageMem1DEXT( c->target, c->levels, c->internalFormat, c->width, c->memory, c->offset ));
}

#endif

struct qemu_glTexStorageMem2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageMem2DEXT( GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexStorageMem2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGEMEM2DEXT);
    call.target = target;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageMem2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexStorageMem2DEXT *c = (struct qemu_glTexStorageMem2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageMem2DEXT( c->target, c->levels, c->internalFormat, c->width, c->height, c->memory, c->offset ));
}

#endif

struct qemu_glTexStorageMem2DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedSampleLocations;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageMem2DMultisampleEXT( GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexStorageMem2DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGEMEM2DMULTISAMPLEEXT);
    call.target = target;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.fixedSampleLocations = fixedSampleLocations;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageMem2DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTexStorageMem2DMultisampleEXT *c = (struct qemu_glTexStorageMem2DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageMem2DMultisampleEXT( c->target, c->samples, c->internalFormat, c->width, c->height, c->fixedSampleLocations, c->memory, c->offset ));
}

#endif

struct qemu_glTexStorageMem3DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageMem3DEXT( GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexStorageMem3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGEMEM3DEXT);
    call.target = target;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageMem3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexStorageMem3DEXT *c = (struct qemu_glTexStorageMem3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageMem3DEXT( c->target, c->levels, c->internalFormat, c->width, c->height, c->depth, c->memory, c->offset ));
}

#endif

struct qemu_glTexStorageMem3DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedSampleLocations;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageMem3DMultisampleEXT( GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset )
{
    struct qemu_glTexStorageMem3DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGEMEM3DMULTISAMPLEEXT);
    call.target = target;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedSampleLocations = fixedSampleLocations;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageMem3DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTexStorageMem3DMultisampleEXT *c = (struct qemu_glTexStorageMem3DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageMem3DMultisampleEXT( c->target, c->samples, c->internalFormat, c->width, c->height, c->depth, c->fixedSampleLocations, c->memory, c->offset ));
}

#endif

struct qemu_glTexStorageSparseAMD
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t layers;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexStorageSparseAMD( GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags )
{
    struct qemu_glTexStorageSparseAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSTORAGESPARSEAMD);
    call.target = target;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.layers = layers;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexStorageSparseAMD(struct qemu_syscall *call)
{
    struct qemu_glTexStorageSparseAMD *c = (struct qemu_glTexStorageSparseAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexStorageSparseAMD( c->target, c->internalFormat, c->width, c->height, c->depth, c->layers, c->flags ));
}

#endif

struct qemu_glTexSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexSubImage1DEXT( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSUBIMAGE1DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexSubImage1DEXT *c = (struct qemu_glTexSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexSubImage1DEXT( c->target, c->level, c->xoffset, c->width, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexSubImage2DEXT( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSUBIMAGE2DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexSubImage2DEXT *c = (struct qemu_glTexSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexSubImage2DEXT( c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexSubImage3D
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSUBIMAGE3D);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glTexSubImage3D *c = (struct qemu_glTexSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexSubImage3D( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexSubImage3DEXT( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSUBIMAGE3DEXT);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTexSubImage3DEXT *c = (struct qemu_glTexSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexSubImage3DEXT( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTexSubImage4DSGIS
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t woffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t size4d;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexSubImage4DSGIS( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTexSubImage4DSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXSUBIMAGE4DSGIS);
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.woffset = woffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.size4d = size4d;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexSubImage4DSGIS(struct qemu_syscall *call)
{
    struct qemu_glTexSubImage4DSGIS *c = (struct qemu_glTexSubImage4DSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexSubImage4DSGIS( c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->woffset, c->width, c->height, c->depth, c->size4d, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureAttachMemoryNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureAttachMemoryNV( GLuint texture, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureAttachMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREATTACHMEMORYNV);
    call.texture = texture;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureAttachMemoryNV(struct qemu_syscall *call)
{
    struct qemu_glTextureAttachMemoryNV *c = (struct qemu_glTextureAttachMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureAttachMemoryNV( c->texture, c->memory, c->offset ));
}

#endif

struct qemu_glTextureBarrier
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBarrier(void)
{
    struct qemu_glTextureBarrier call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBARRIER);

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBarrier(struct qemu_syscall *call)
{
    struct qemu_glTextureBarrier *c = (struct qemu_glTextureBarrier *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBarrier());
}

#endif

struct qemu_glTextureBarrierNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBarrierNV(void)
{
    struct qemu_glTextureBarrierNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBARRIERNV);

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBarrierNV(struct qemu_syscall *call)
{
    struct qemu_glTextureBarrierNV *c = (struct qemu_glTextureBarrierNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBarrierNV());
}

#endif

struct qemu_glTextureBuffer
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBuffer( GLuint texture, GLenum internalformat, GLuint buffer )
{
    struct qemu_glTextureBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBUFFER);
    call.texture = texture;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBuffer(struct qemu_syscall *call)
{
    struct qemu_glTextureBuffer *c = (struct qemu_glTextureBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBuffer( c->texture, c->internalformat, c->buffer ));
}

#endif

struct qemu_glTextureBufferEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBufferEXT( GLuint texture, GLenum target, GLenum internalformat, GLuint buffer )
{
    struct qemu_glTextureBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBUFFEREXT);
    call.texture = texture;
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureBufferEXT *c = (struct qemu_glTextureBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBufferEXT( c->texture, c->target, c->internalformat, c->buffer ));
}

#endif

struct qemu_glTextureBufferRange
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t internalformat;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBufferRange( GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glTextureBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBUFFERRANGE);
    call.texture = texture;
    call.internalformat = internalformat;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBufferRange(struct qemu_syscall *call)
{
    struct qemu_glTextureBufferRange *c = (struct qemu_glTextureBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBufferRange( c->texture, c->internalformat, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glTextureBufferRangeEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t internalformat;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureBufferRangeEXT( GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glTextureBufferRangeEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREBUFFERRANGEEXT);
    call.texture = texture;
    call.target = target;
    call.internalformat = internalformat;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureBufferRangeEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureBufferRangeEXT *c = (struct qemu_glTextureBufferRangeEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureBufferRangeEXT( c->texture, c->target, c->internalformat, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glTextureColorMaskSGIS
{
    struct qemu_syscall super;
    uint64_t red;
    uint64_t green;
    uint64_t blue;
    uint64_t alpha;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureColorMaskSGIS( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )
{
    struct qemu_glTextureColorMaskSGIS call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURECOLORMASKSGIS);
    call.red = red;
    call.green = green;
    call.blue = blue;
    call.alpha = alpha;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureColorMaskSGIS(struct qemu_syscall *call)
{
    struct qemu_glTextureColorMaskSGIS *c = (struct qemu_glTextureColorMaskSGIS *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureColorMaskSGIS( c->red, c->green, c->blue, c->alpha ));
}

#endif

struct qemu_glTextureImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage1DEXT( GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureImage1DEXT *c = (struct qemu_glTextureImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage1DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage2DEXT( GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureImage2DEXT *c = (struct qemu_glTextureImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage2DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->height, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureImage2DMultisampleCoverageNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage2DMultisampleCoverageNV( GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations )
{
    struct qemu_glTextureImage2DMultisampleCoverageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV);
    call.texture = texture;
    call.target = target;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage2DMultisampleCoverageNV(struct qemu_syscall *call)
{
    struct qemu_glTextureImage2DMultisampleCoverageNV *c = (struct qemu_glTextureImage2DMultisampleCoverageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage2DMultisampleCoverageNV( c->texture, c->target, c->coverageSamples, c->colorSamples, c->internalFormat, c->width, c->height, c->fixedSampleLocations ));
}

#endif

struct qemu_glTextureImage2DMultisampleNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage2DMultisampleNV( GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations )
{
    struct qemu_glTextureImage2DMultisampleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE2DMULTISAMPLENV);
    call.texture = texture;
    call.target = target;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage2DMultisampleNV(struct qemu_syscall *call)
{
    struct qemu_glTextureImage2DMultisampleNV *c = (struct qemu_glTextureImage2DMultisampleNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage2DMultisampleNV( c->texture, c->target, c->samples, c->internalFormat, c->width, c->height, c->fixedSampleLocations ));
}

#endif

struct qemu_glTextureImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t border;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage3DEXT( GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.border = border;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureImage3DEXT *c = (struct qemu_glTextureImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage3DEXT( c->texture, c->target, c->level, c->internalformat, c->width, c->height, c->depth, c->border, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureImage3DMultisampleCoverageNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t coverageSamples;
    uint64_t colorSamples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage3DMultisampleCoverageNV( GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations )
{
    struct qemu_glTextureImage3DMultisampleCoverageNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV);
    call.texture = texture;
    call.target = target;
    call.coverageSamples = coverageSamples;
    call.colorSamples = colorSamples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage3DMultisampleCoverageNV(struct qemu_syscall *call)
{
    struct qemu_glTextureImage3DMultisampleCoverageNV *c = (struct qemu_glTextureImage3DMultisampleCoverageNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage3DMultisampleCoverageNV( c->texture, c->target, c->coverageSamples, c->colorSamples, c->internalFormat, c->width, c->height, c->depth, c->fixedSampleLocations ));
}

#endif

struct qemu_glTextureImage3DMultisampleNV
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedSampleLocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureImage3DMultisampleNV( GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations )
{
    struct qemu_glTextureImage3DMultisampleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREIMAGE3DMULTISAMPLENV);
    call.texture = texture;
    call.target = target;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedSampleLocations = fixedSampleLocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureImage3DMultisampleNV(struct qemu_syscall *call)
{
    struct qemu_glTextureImage3DMultisampleNV *c = (struct qemu_glTextureImage3DMultisampleNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureImage3DMultisampleNV( c->texture, c->target, c->samples, c->internalFormat, c->width, c->height, c->depth, c->fixedSampleLocations ));
}

#endif

struct qemu_glTextureLightEXT
{
    struct qemu_syscall super;
    uint64_t pname;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureLightEXT( GLenum pname )
{
    struct qemu_glTextureLightEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURELIGHTEXT);
    call.pname = pname;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureLightEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureLightEXT *c = (struct qemu_glTextureLightEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureLightEXT( c->pname ));
}

#endif

struct qemu_glTextureMaterialEXT
{
    struct qemu_syscall super;
    uint64_t face;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureMaterialEXT( GLenum face, GLenum mode )
{
    struct qemu_glTextureMaterialEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREMATERIALEXT);
    call.face = face;
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureMaterialEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureMaterialEXT *c = (struct qemu_glTextureMaterialEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureMaterialEXT( c->face, c->mode ));
}

#endif

struct qemu_glTextureNormalEXT
{
    struct qemu_syscall super;
    uint64_t mode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureNormalEXT( GLenum mode )
{
    struct qemu_glTextureNormalEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURENORMALEXT);
    call.mode = mode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureNormalEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureNormalEXT *c = (struct qemu_glTextureNormalEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureNormalEXT( c->mode ));
}

#endif

struct qemu_glTexturePageCommitmentEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t commit;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTexturePageCommitmentEXT( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit )
{
    struct qemu_glTexturePageCommitmentEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPAGECOMMITMENTEXT);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.commit = commit;

    qemu_syscall(&call.super);
}

#else

void qemu_glTexturePageCommitmentEXT(struct qemu_syscall *call)
{
    struct qemu_glTexturePageCommitmentEXT *c = (struct qemu_glTexturePageCommitmentEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTexturePageCommitmentEXT( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->commit ));
}

#endif

struct qemu_glTextureParameterIiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterIiv( GLuint texture, GLenum pname, const GLint *params )
{
    struct qemu_glTextureParameterIiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIIV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterIiv(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterIiv *c = (struct qemu_glTextureParameterIiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterIiv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureParameterIivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterIivEXT( GLuint texture, GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glTextureParameterIivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterIivEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterIivEXT *c = (struct qemu_glTextureParameterIivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterIivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureParameterIuiv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterIuiv( GLuint texture, GLenum pname, const GLuint *params )
{
    struct qemu_glTextureParameterIuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIUIV);
    call.texture = texture;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterIuiv(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterIuiv *c = (struct qemu_glTextureParameterIuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterIuiv( c->texture, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureParameterIuivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterIuivEXT( GLuint texture, GLenum target, GLenum pname, const GLuint *params )
{
    struct qemu_glTextureParameterIuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIUIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterIuivEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterIuivEXT *c = (struct qemu_glTextureParameterIuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterIuivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureParameterf
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterf( GLuint texture, GLenum pname, GLfloat param )
{
    struct qemu_glTextureParameterf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERF);
    call.texture = texture;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterf(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterf *c = (struct qemu_glTextureParameterf *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterf( c->texture, c->pname, c->param ));
}

#endif

struct qemu_glTextureParameterfEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterfEXT( GLuint texture, GLenum target, GLenum pname, GLfloat param )
{
    struct qemu_glTextureParameterfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERFEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterfEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterfEXT *c = (struct qemu_glTextureParameterfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterfEXT( c->texture, c->target, c->pname, c->param ));
}

#endif

struct qemu_glTextureParameterfv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterfv( GLuint texture, GLenum pname, const GLfloat *param )
{
    struct qemu_glTextureParameterfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERFV);
    call.texture = texture;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterfv(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterfv *c = (struct qemu_glTextureParameterfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterfv( c->texture, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glTextureParameterfvEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterfvEXT( GLuint texture, GLenum target, GLenum pname, const GLfloat *params )
{
    struct qemu_glTextureParameterfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERFVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterfvEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterfvEXT *c = (struct qemu_glTextureParameterfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterfvEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureParameteri
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameteri( GLuint texture, GLenum pname, GLint param )
{
    struct qemu_glTextureParameteri call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERI);
    call.texture = texture;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameteri(struct qemu_syscall *call)
{
    struct qemu_glTextureParameteri *c = (struct qemu_glTextureParameteri *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameteri( c->texture, c->pname, c->param ));
}

#endif

struct qemu_glTextureParameteriEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameteriEXT( GLuint texture, GLenum target, GLenum pname, GLint param )
{
    struct qemu_glTextureParameteriEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameteriEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameteriEXT *c = (struct qemu_glTextureParameteriEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameteriEXT( c->texture, c->target, c->pname, c->param ));
}

#endif

struct qemu_glTextureParameteriv
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameteriv( GLuint texture, GLenum pname, const GLint *param )
{
    struct qemu_glTextureParameteriv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIV);
    call.texture = texture;
    call.pname = pname;
    call.param = (ULONG_PTR)param;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameteriv(struct qemu_syscall *call)
{
    struct qemu_glTextureParameteriv *c = (struct qemu_glTextureParameteriv *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameteriv( c->texture, c->pname, QEMU_G2H(c->param) ));
}

#endif

struct qemu_glTextureParameterivEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureParameterivEXT( GLuint texture, GLenum target, GLenum pname, const GLint *params )
{
    struct qemu_glTextureParameterivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREPARAMETERIVEXT);
    call.texture = texture;
    call.target = target;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureParameterivEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureParameterivEXT *c = (struct qemu_glTextureParameterivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureParameterivEXT( c->texture, c->target, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glTextureRangeAPPLE
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t length;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureRangeAPPLE( GLenum target, GLsizei length, const void *pointer )
{
    struct qemu_glTextureRangeAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURERANGEAPPLE);
    call.target = target;
    call.length = length;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureRangeAPPLE(struct qemu_syscall *call)
{
    struct qemu_glTextureRangeAPPLE *c = (struct qemu_glTextureRangeAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureRangeAPPLE( c->target, c->length, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glTextureRenderbufferEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t renderbuffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureRenderbufferEXT( GLuint texture, GLenum target, GLuint renderbuffer )
{
    struct qemu_glTextureRenderbufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURERENDERBUFFEREXT);
    call.texture = texture;
    call.target = target;
    call.renderbuffer = renderbuffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureRenderbufferEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureRenderbufferEXT *c = (struct qemu_glTextureRenderbufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureRenderbufferEXT( c->texture, c->target, c->renderbuffer ));
}

#endif

struct qemu_glTextureStorage1D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage1D( GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width )
{
    struct qemu_glTextureStorage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE1D);
    call.texture = texture;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage1D(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage1D *c = (struct qemu_glTextureStorage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage1D( c->texture, c->levels, c->internalformat, c->width ));
}

#endif

struct qemu_glTextureStorage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage1DEXT( GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width )
{
    struct qemu_glTextureStorage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage1DEXT *c = (struct qemu_glTextureStorage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage1DEXT( c->texture, c->target, c->levels, c->internalformat, c->width ));
}

#endif

struct qemu_glTextureStorage2D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage2D( GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glTextureStorage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE2D);
    call.texture = texture;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage2D(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage2D *c = (struct qemu_glTextureStorage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage2D( c->texture, c->levels, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glTextureStorage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage2DEXT( GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height )
{
    struct qemu_glTextureStorage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage2DEXT *c = (struct qemu_glTextureStorage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage2DEXT( c->texture, c->target, c->levels, c->internalformat, c->width, c->height ));
}

#endif

struct qemu_glTextureStorage2DMultisample
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage2DMultisample( GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations )
{
    struct qemu_glTextureStorage2DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE2DMULTISAMPLE);
    call.texture = texture;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage2DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage2DMultisample *c = (struct qemu_glTextureStorage2DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage2DMultisample( c->texture, c->samples, c->internalformat, c->width, c->height, c->fixedsamplelocations ));
}

#endif

struct qemu_glTextureStorage2DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage2DMultisampleEXT( GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations )
{
    struct qemu_glTextureStorage2DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE2DMULTISAMPLEEXT);
    call.texture = texture;
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage2DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage2DMultisampleEXT *c = (struct qemu_glTextureStorage2DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage2DMultisampleEXT( c->texture, c->target, c->samples, c->internalformat, c->width, c->height, c->fixedsamplelocations ));
}

#endif

struct qemu_glTextureStorage3D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage3D( GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glTextureStorage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE3D);
    call.texture = texture;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage3D(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage3D *c = (struct qemu_glTextureStorage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage3D( c->texture, c->levels, c->internalformat, c->width, c->height, c->depth ));
}

#endif

struct qemu_glTextureStorage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t levels;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage3DEXT( GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth )
{
    struct qemu_glTextureStorage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.levels = levels;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage3DEXT *c = (struct qemu_glTextureStorage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage3DEXT( c->texture, c->target, c->levels, c->internalformat, c->width, c->height, c->depth ));
}

#endif

struct qemu_glTextureStorage3DMultisample
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage3DMultisample( GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations )
{
    struct qemu_glTextureStorage3DMultisample call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE3DMULTISAMPLE);
    call.texture = texture;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage3DMultisample(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage3DMultisample *c = (struct qemu_glTextureStorage3DMultisample *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage3DMultisample( c->texture, c->samples, c->internalformat, c->width, c->height, c->depth, c->fixedsamplelocations ));
}

#endif

struct qemu_glTextureStorage3DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t samples;
    uint64_t internalformat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedsamplelocations;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorage3DMultisampleEXT( GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations )
{
    struct qemu_glTextureStorage3DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGE3DMULTISAMPLEEXT);
    call.texture = texture;
    call.target = target;
    call.samples = samples;
    call.internalformat = internalformat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedsamplelocations = fixedsamplelocations;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorage3DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorage3DMultisampleEXT *c = (struct qemu_glTextureStorage3DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorage3DMultisampleEXT( c->texture, c->target, c->samples, c->internalformat, c->width, c->height, c->depth, c->fixedsamplelocations ));
}

#endif

struct qemu_glTextureStorageMem1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageMem1DEXT( GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureStorageMem1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGEMEM1DEXT);
    call.texture = texture;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageMem1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageMem1DEXT *c = (struct qemu_glTextureStorageMem1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageMem1DEXT( c->texture, c->levels, c->internalFormat, c->width, c->memory, c->offset ));
}

#endif

struct qemu_glTextureStorageMem2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageMem2DEXT( GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureStorageMem2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGEMEM2DEXT);
    call.texture = texture;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageMem2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageMem2DEXT *c = (struct qemu_glTextureStorageMem2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageMem2DEXT( c->texture, c->levels, c->internalFormat, c->width, c->height, c->memory, c->offset ));
}

#endif

struct qemu_glTextureStorageMem2DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t fixedSampleLocations;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageMem2DMultisampleEXT( GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureStorageMem2DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGEMEM2DMULTISAMPLEEXT);
    call.texture = texture;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.fixedSampleLocations = fixedSampleLocations;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageMem2DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageMem2DMultisampleEXT *c = (struct qemu_glTextureStorageMem2DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageMem2DMultisampleEXT( c->texture, c->samples, c->internalFormat, c->width, c->height, c->fixedSampleLocations, c->memory, c->offset ));
}

#endif

struct qemu_glTextureStorageMem3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t levels;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageMem3DEXT( GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureStorageMem3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGEMEM3DEXT);
    call.texture = texture;
    call.levels = levels;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageMem3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageMem3DEXT *c = (struct qemu_glTextureStorageMem3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageMem3DEXT( c->texture, c->levels, c->internalFormat, c->width, c->height, c->depth, c->memory, c->offset ));
}

#endif

struct qemu_glTextureStorageMem3DMultisampleEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t samples;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t fixedSampleLocations;
    uint64_t memory;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageMem3DMultisampleEXT( GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset )
{
    struct qemu_glTextureStorageMem3DMultisampleEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGEMEM3DMULTISAMPLEEXT);
    call.texture = texture;
    call.samples = samples;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.fixedSampleLocations = fixedSampleLocations;
    call.memory = memory;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageMem3DMultisampleEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageMem3DMultisampleEXT *c = (struct qemu_glTextureStorageMem3DMultisampleEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageMem3DMultisampleEXT( c->texture, c->samples, c->internalFormat, c->width, c->height, c->depth, c->fixedSampleLocations, c->memory, c->offset ));
}

#endif

struct qemu_glTextureStorageSparseAMD
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t internalFormat;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t layers;
    uint64_t flags;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureStorageSparseAMD( GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags )
{
    struct qemu_glTextureStorageSparseAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESTORAGESPARSEAMD);
    call.texture = texture;
    call.target = target;
    call.internalFormat = internalFormat;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.layers = layers;
    call.flags = flags;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureStorageSparseAMD(struct qemu_syscall *call)
{
    struct qemu_glTextureStorageSparseAMD *c = (struct qemu_glTextureStorageSparseAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureStorageSparseAMD( c->texture, c->target, c->internalFormat, c->width, c->height, c->depth, c->layers, c->flags ));
}

#endif

struct qemu_glTextureSubImage1D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage1D( GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage1D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE1D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage1D(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage1D *c = (struct qemu_glTextureSubImage1D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage1D( c->texture, c->level, c->xoffset, c->width, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureSubImage1DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t width;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage1DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage1DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE1DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.width = width;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage1DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage1DEXT *c = (struct qemu_glTextureSubImage1DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage1DEXT( c->texture, c->target, c->level, c->xoffset, c->width, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureSubImage2D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage2D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage2D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE2D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage2D(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage2D *c = (struct qemu_glTextureSubImage2D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage2D( c->texture, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureSubImage2DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t width;
    uint64_t height;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage2DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage2DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE2DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.width = width;
    call.height = height;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage2DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage2DEXT *c = (struct qemu_glTextureSubImage2DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage2DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->width, c->height, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureSubImage3D
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage3D( GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage3D call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE3D);
    call.texture = texture;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage3D(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage3D *c = (struct qemu_glTextureSubImage3D *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage3D( c->texture, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureSubImage3DEXT
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t level;
    uint64_t xoffset;
    uint64_t yoffset;
    uint64_t zoffset;
    uint64_t width;
    uint64_t height;
    uint64_t depth;
    uint64_t format;
    uint64_t type;
    uint64_t pixels;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureSubImage3DEXT( GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels )
{
    struct qemu_glTextureSubImage3DEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTURESUBIMAGE3DEXT);
    call.texture = texture;
    call.target = target;
    call.level = level;
    call.xoffset = xoffset;
    call.yoffset = yoffset;
    call.zoffset = zoffset;
    call.width = width;
    call.height = height;
    call.depth = depth;
    call.format = format;
    call.type = type;
    call.pixels = (ULONG_PTR)pixels;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureSubImage3DEXT(struct qemu_syscall *call)
{
    struct qemu_glTextureSubImage3DEXT *c = (struct qemu_glTextureSubImage3DEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureSubImage3DEXT( c->texture, c->target, c->level, c->xoffset, c->yoffset, c->zoffset, c->width, c->height, c->depth, c->format, c->type, QEMU_G2H(c->pixels) ));
}

#endif

struct qemu_glTextureView
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t target;
    uint64_t origtexture;
    uint64_t internalformat;
    uint64_t minlevel;
    uint64_t numlevels;
    uint64_t minlayer;
    uint64_t numlayers;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTextureView( GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers )
{
    struct qemu_glTextureView call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTEXTUREVIEW);
    call.texture = texture;
    call.target = target;
    call.origtexture = origtexture;
    call.internalformat = internalformat;
    call.minlevel = minlevel;
    call.numlevels = numlevels;
    call.minlayer = minlayer;
    call.numlayers = numlayers;

    qemu_syscall(&call.super);
}

#else

void qemu_glTextureView(struct qemu_syscall *call)
{
    struct qemu_glTextureView *c = (struct qemu_glTextureView *)call;
    WINE_FIXME("Unverified\n");
    (p_glTextureView( c->texture, c->target, c->origtexture, c->internalformat, c->minlevel, c->numlevels, c->minlayer, c->numlayers ));
}

#endif

struct qemu_glTrackMatrixNV
{
    struct qemu_syscall super;
    uint64_t target;
    uint64_t address;
    uint64_t matrix;
    uint64_t transform;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTrackMatrixNV( GLenum target, GLuint address, GLenum matrix, GLenum transform )
{
    struct qemu_glTrackMatrixNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRACKMATRIXNV);
    call.target = target;
    call.address = address;
    call.matrix = matrix;
    call.transform = transform;

    qemu_syscall(&call.super);
}

#else

void qemu_glTrackMatrixNV(struct qemu_syscall *call)
{
    struct qemu_glTrackMatrixNV *c = (struct qemu_glTrackMatrixNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTrackMatrixNV( c->target, c->address, c->matrix, c->transform ));
}

#endif

struct qemu_glTransformFeedbackAttribsNV
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t attribs;
    uint64_t bufferMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackAttribsNV( GLsizei count, const GLint *attribs, GLenum bufferMode )
{
    struct qemu_glTransformFeedbackAttribsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKATTRIBSNV);
    call.count = count;
    call.attribs = (ULONG_PTR)attribs;
    call.bufferMode = bufferMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackAttribsNV(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackAttribsNV *c = (struct qemu_glTransformFeedbackAttribsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackAttribsNV( c->count, QEMU_G2H(c->attribs), c->bufferMode ));
}

#endif

struct qemu_glTransformFeedbackBufferBase
{
    struct qemu_syscall super;
    uint64_t xfb;
    uint64_t index;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackBufferBase( GLuint xfb, GLuint index, GLuint buffer )
{
    struct qemu_glTransformFeedbackBufferBase call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKBUFFERBASE);
    call.xfb = xfb;
    call.index = index;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackBufferBase(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackBufferBase *c = (struct qemu_glTransformFeedbackBufferBase *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackBufferBase( c->xfb, c->index, c->buffer ));
}

#endif

struct qemu_glTransformFeedbackBufferRange
{
    struct qemu_syscall super;
    uint64_t xfb;
    uint64_t index;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackBufferRange( GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size )
{
    struct qemu_glTransformFeedbackBufferRange call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKBUFFERRANGE);
    call.xfb = xfb;
    call.index = index;
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackBufferRange(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackBufferRange *c = (struct qemu_glTransformFeedbackBufferRange *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackBufferRange( c->xfb, c->index, c->buffer, c->offset, c->size ));
}

#endif

struct qemu_glTransformFeedbackStreamAttribsNV
{
    struct qemu_syscall super;
    uint64_t count;
    uint64_t attribs;
    uint64_t nbuffers;
    uint64_t bufstreams;
    uint64_t bufferMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackStreamAttribsNV( GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode )
{
    struct qemu_glTransformFeedbackStreamAttribsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV);
    call.count = count;
    call.attribs = (ULONG_PTR)attribs;
    call.nbuffers = nbuffers;
    call.bufstreams = (ULONG_PTR)bufstreams;
    call.bufferMode = bufferMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackStreamAttribsNV(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackStreamAttribsNV *c = (struct qemu_glTransformFeedbackStreamAttribsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackStreamAttribsNV( c->count, QEMU_G2H(c->attribs), c->nbuffers, QEMU_G2H(c->bufstreams), c->bufferMode ));
}

#endif

struct qemu_glTransformFeedbackVaryings
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t count;
    uint64_t varyings;
    uint64_t bufferMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackVaryings( GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode )
{
    struct qemu_glTransformFeedbackVaryings call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKVARYINGS);
    call.program = program;
    call.count = count;
    call.varyings = (ULONG_PTR)varyings;
    call.bufferMode = bufferMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackVaryings(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackVaryings *c = (struct qemu_glTransformFeedbackVaryings *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackVaryings( c->program, c->count, QEMU_G2H(c->varyings), c->bufferMode ));
}

#endif

struct qemu_glTransformFeedbackVaryingsEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t count;
    uint64_t varyings;
    uint64_t bufferMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackVaryingsEXT( GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode )
{
    struct qemu_glTransformFeedbackVaryingsEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKVARYINGSEXT);
    call.program = program;
    call.count = count;
    call.varyings = (ULONG_PTR)varyings;
    call.bufferMode = bufferMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackVaryingsEXT(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackVaryingsEXT *c = (struct qemu_glTransformFeedbackVaryingsEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackVaryingsEXT( c->program, c->count, QEMU_G2H(c->varyings), c->bufferMode ));
}

#endif

struct qemu_glTransformFeedbackVaryingsNV
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t count;
    uint64_t locations;
    uint64_t bufferMode;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformFeedbackVaryingsNV( GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode )
{
    struct qemu_glTransformFeedbackVaryingsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMFEEDBACKVARYINGSNV);
    call.program = program;
    call.count = count;
    call.locations = (ULONG_PTR)locations;
    call.bufferMode = bufferMode;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformFeedbackVaryingsNV(struct qemu_syscall *call)
{
    struct qemu_glTransformFeedbackVaryingsNV *c = (struct qemu_glTransformFeedbackVaryingsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformFeedbackVaryingsNV( c->program, c->count, QEMU_G2H(c->locations), c->bufferMode ));
}

#endif

struct qemu_glTransformPathNV
{
    struct qemu_syscall super;
    uint64_t resultPath;
    uint64_t srcPath;
    uint64_t transformType;
    uint64_t transformValues;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTransformPathNV( GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues )
{
    struct qemu_glTransformPathNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSFORMPATHNV);
    call.resultPath = resultPath;
    call.srcPath = srcPath;
    call.transformType = transformType;
    call.transformValues = (ULONG_PTR)transformValues;

    qemu_syscall(&call.super);
}

#else

void qemu_glTransformPathNV(struct qemu_syscall *call)
{
    struct qemu_glTransformPathNV *c = (struct qemu_glTransformPathNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glTransformPathNV( c->resultPath, c->srcPath, c->transformType, QEMU_G2H(c->transformValues) ));
}

#endif

struct qemu_glTranslatexOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glTranslatexOES( GLfixed x, GLfixed y, GLfixed z )
{
    struct qemu_glTranslatexOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLTRANSLATEXOES);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glTranslatexOES(struct qemu_syscall *call)
{
    struct qemu_glTranslatexOES *c = (struct qemu_glTranslatexOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glTranslatexOES( c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform1d
{
    struct qemu_syscall super;
    uint64_t location;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1d( GLint location, GLdouble x )
{
    struct qemu_glUniform1d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1D);
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1d(struct qemu_syscall *call)
{
    struct qemu_glUniform1d *c = (struct qemu_glUniform1d *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1d( c->location, c->x ));
}

#endif

struct qemu_glUniform1dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1dv( GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glUniform1dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1DV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1dv(struct qemu_syscall *call)
{
    struct qemu_glUniform1dv *c = (struct qemu_glUniform1dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1dv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1f
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1f( GLint location, GLfloat v0 )
{
    struct qemu_glUniform1f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1F);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1f(struct qemu_syscall *call)
{
    struct qemu_glUniform1f *c = (struct qemu_glUniform1f *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1f( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1fARB
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1fARB( GLint location, GLfloat v0 )
{
    struct qemu_glUniform1fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1FARB);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1fARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1fARB *c = (struct qemu_glUniform1fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1fARB( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1fv( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform1fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1FV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1fv(struct qemu_syscall *call)
{
    struct qemu_glUniform1fv *c = (struct qemu_glUniform1fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1fv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1fvARB( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform1fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1FVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1fvARB *c = (struct qemu_glUniform1fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1fvARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1i
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1i( GLint location, GLint v0 )
{
    struct qemu_glUniform1i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1I);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1i(struct qemu_syscall *call)
{
    struct qemu_glUniform1i *c = (struct qemu_glUniform1i *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1i( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1i64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1i64ARB( GLint location, GLint64 x )
{
    struct qemu_glUniform1i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1I64ARB);
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1i64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1i64ARB *c = (struct qemu_glUniform1i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1i64ARB( c->location, c->x ));
}

#endif

struct qemu_glUniform1i64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1i64NV( GLint location, GLint64EXT x )
{
    struct qemu_glUniform1i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1I64NV);
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1i64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform1i64NV *c = (struct qemu_glUniform1i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1i64NV( c->location, c->x ));
}

#endif

struct qemu_glUniform1i64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1i64vARB( GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glUniform1i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1I64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1i64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1i64vARB *c = (struct qemu_glUniform1i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1i64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1i64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1i64vNV( GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glUniform1i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1I64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1i64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform1i64vNV *c = (struct qemu_glUniform1i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1i64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1iARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1iARB( GLint location, GLint v0 )
{
    struct qemu_glUniform1iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1IARB);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1iARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1iARB *c = (struct qemu_glUniform1iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1iARB( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1iv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1iv( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform1iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1IV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1iv(struct qemu_syscall *call)
{
    struct qemu_glUniform1iv *c = (struct qemu_glUniform1iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1iv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1ivARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ivARB( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform1ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1IVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ivARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1ivARB *c = (struct qemu_glUniform1ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ivARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1ui
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ui( GLint location, GLuint v0 )
{
    struct qemu_glUniform1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UI);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ui(struct qemu_syscall *call)
{
    struct qemu_glUniform1ui *c = (struct qemu_glUniform1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ui( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1ui64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ui64ARB( GLint location, GLuint64 x )
{
    struct qemu_glUniform1ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UI64ARB);
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1ui64ARB *c = (struct qemu_glUniform1ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ui64ARB( c->location, c->x ));
}

#endif

struct qemu_glUniform1ui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ui64NV( GLint location, GLuint64EXT x )
{
    struct qemu_glUniform1ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UI64NV);
    call.location = location;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform1ui64NV *c = (struct qemu_glUniform1ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ui64NV( c->location, c->x ));
}

#endif

struct qemu_glUniform1ui64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ui64vARB( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniform1ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UI64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform1ui64vARB *c = (struct qemu_glUniform1ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ui64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1ui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1ui64vNV( GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glUniform1ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform1ui64vNV *c = (struct qemu_glUniform1ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1ui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1uiEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1uiEXT( GLint location, GLuint v0 )
{
    struct qemu_glUniform1uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UIEXT);
    call.location = location;
    call.v0 = v0;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1uiEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform1uiEXT *c = (struct qemu_glUniform1uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1uiEXT( c->location, c->v0 ));
}

#endif

struct qemu_glUniform1uiv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1uiv( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UIV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1uiv(struct qemu_syscall *call)
{
    struct qemu_glUniform1uiv *c = (struct qemu_glUniform1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1uiv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform1uivEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform1uivEXT( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform1uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM1UIVEXT);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform1uivEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform1uivEXT *c = (struct qemu_glUniform1uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform1uivEXT( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2d
{
    struct qemu_syscall super;
    uint64_t location;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2d( GLint location, GLdouble x, GLdouble y )
{
    struct qemu_glUniform2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2D);
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2d(struct qemu_syscall *call)
{
    struct qemu_glUniform2d *c = (struct qemu_glUniform2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2d( c->location, c->x, c->y ));
}

#endif

struct qemu_glUniform2dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2dv( GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glUniform2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2DV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2dv(struct qemu_syscall *call)
{
    struct qemu_glUniform2dv *c = (struct qemu_glUniform2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2dv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2f
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2f( GLint location, GLfloat v0, GLfloat v1 )
{
    struct qemu_glUniform2f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2F);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2f(struct qemu_syscall *call)
{
    struct qemu_glUniform2f *c = (struct qemu_glUniform2f *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2f( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2fARB
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2fARB( GLint location, GLfloat v0, GLfloat v1 )
{
    struct qemu_glUniform2fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2FARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2fARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2fARB *c = (struct qemu_glUniform2fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2fARB( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2fv( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2FV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2fv(struct qemu_syscall *call)
{
    struct qemu_glUniform2fv *c = (struct qemu_glUniform2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2fv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2fvARB( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform2fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2FVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2fvARB *c = (struct qemu_glUniform2fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2fvARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2i
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2i( GLint location, GLint v0, GLint v1 )
{
    struct qemu_glUniform2i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2I);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2i(struct qemu_syscall *call)
{
    struct qemu_glUniform2i *c = (struct qemu_glUniform2i *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2i( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2i64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2i64ARB( GLint location, GLint64 x, GLint64 y )
{
    struct qemu_glUniform2i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2I64ARB);
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2i64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2i64ARB *c = (struct qemu_glUniform2i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2i64ARB( c->location, c->x, c->y ));
}

#endif

struct qemu_glUniform2i64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2i64NV( GLint location, GLint64EXT x, GLint64EXT y )
{
    struct qemu_glUniform2i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2I64NV);
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2i64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform2i64NV *c = (struct qemu_glUniform2i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2i64NV( c->location, c->x, c->y ));
}

#endif

struct qemu_glUniform2i64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2i64vARB( GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glUniform2i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2I64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2i64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2i64vARB *c = (struct qemu_glUniform2i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2i64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2i64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2i64vNV( GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glUniform2i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2I64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2i64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform2i64vNV *c = (struct qemu_glUniform2i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2i64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2iARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2iARB( GLint location, GLint v0, GLint v1 )
{
    struct qemu_glUniform2iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2IARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2iARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2iARB *c = (struct qemu_glUniform2iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2iARB( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2iv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2iv( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform2iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2IV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2iv(struct qemu_syscall *call)
{
    struct qemu_glUniform2iv *c = (struct qemu_glUniform2iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2iv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2ivARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ivARB( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform2ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2IVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ivARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2ivARB *c = (struct qemu_glUniform2ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ivARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2ui
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ui( GLint location, GLuint v0, GLuint v1 )
{
    struct qemu_glUniform2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UI);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ui(struct qemu_syscall *call)
{
    struct qemu_glUniform2ui *c = (struct qemu_glUniform2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ui( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2ui64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ui64ARB( GLint location, GLuint64 x, GLuint64 y )
{
    struct qemu_glUniform2ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UI64ARB);
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2ui64ARB *c = (struct qemu_glUniform2ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ui64ARB( c->location, c->x, c->y ));
}

#endif

struct qemu_glUniform2ui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ui64NV( GLint location, GLuint64EXT x, GLuint64EXT y )
{
    struct qemu_glUniform2ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UI64NV);
    call.location = location;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform2ui64NV *c = (struct qemu_glUniform2ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ui64NV( c->location, c->x, c->y ));
}

#endif

struct qemu_glUniform2ui64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ui64vARB( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniform2ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UI64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform2ui64vARB *c = (struct qemu_glUniform2ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ui64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2ui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2ui64vNV( GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glUniform2ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform2ui64vNV *c = (struct qemu_glUniform2ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2ui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2uiEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2uiEXT( GLint location, GLuint v0, GLuint v1 )
{
    struct qemu_glUniform2uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UIEXT);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2uiEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform2uiEXT *c = (struct qemu_glUniform2uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2uiEXT( c->location, c->v0, c->v1 ));
}

#endif

struct qemu_glUniform2uiv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2uiv( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UIV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2uiv(struct qemu_syscall *call)
{
    struct qemu_glUniform2uiv *c = (struct qemu_glUniform2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2uiv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform2uivEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform2uivEXT( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform2uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM2UIVEXT);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform2uivEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform2uivEXT *c = (struct qemu_glUniform2uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform2uivEXT( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3d
{
    struct qemu_syscall super;
    uint64_t location;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3d( GLint location, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glUniform3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3D);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3d(struct qemu_syscall *call)
{
    struct qemu_glUniform3d *c = (struct qemu_glUniform3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3d( c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform3dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3dv( GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glUniform3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3DV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3dv(struct qemu_syscall *call)
{
    struct qemu_glUniform3dv *c = (struct qemu_glUniform3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3dv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3f
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
    double v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3f( GLint location, GLfloat v0, GLfloat v1, GLfloat v2 )
{
    struct qemu_glUniform3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3F);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3f(struct qemu_syscall *call)
{
    struct qemu_glUniform3f *c = (struct qemu_glUniform3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3f( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3fARB
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
    double v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3fARB( GLint location, GLfloat v0, GLfloat v1, GLfloat v2 )
{
    struct qemu_glUniform3fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3FARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3fARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3fARB *c = (struct qemu_glUniform3fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3fARB( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3fv( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3FV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3fv(struct qemu_syscall *call)
{
    struct qemu_glUniform3fv *c = (struct qemu_glUniform3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3fv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3fvARB( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform3fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3FVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3fvARB *c = (struct qemu_glUniform3fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3fvARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3i
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3i( GLint location, GLint v0, GLint v1, GLint v2 )
{
    struct qemu_glUniform3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3I);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3i(struct qemu_syscall *call)
{
    struct qemu_glUniform3i *c = (struct qemu_glUniform3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3i( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3i64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3i64ARB( GLint location, GLint64 x, GLint64 y, GLint64 z )
{
    struct qemu_glUniform3i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3I64ARB);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3i64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3i64ARB *c = (struct qemu_glUniform3i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3i64ARB( c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform3i64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3i64NV( GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z )
{
    struct qemu_glUniform3i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3I64NV);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3i64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform3i64NV *c = (struct qemu_glUniform3i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3i64NV( c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform3i64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3i64vARB( GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glUniform3i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3I64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3i64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3i64vARB *c = (struct qemu_glUniform3i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3i64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3i64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3i64vNV( GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glUniform3i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3I64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3i64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform3i64vNV *c = (struct qemu_glUniform3i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3i64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3iARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3iARB( GLint location, GLint v0, GLint v1, GLint v2 )
{
    struct qemu_glUniform3iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3IARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3iARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3iARB *c = (struct qemu_glUniform3iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3iARB( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3iv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3iv( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3IV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3iv(struct qemu_syscall *call)
{
    struct qemu_glUniform3iv *c = (struct qemu_glUniform3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3iv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3ivARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ivARB( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform3ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3IVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ivARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3ivARB *c = (struct qemu_glUniform3ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ivARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3ui
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ui( GLint location, GLuint v0, GLuint v1, GLuint v2 )
{
    struct qemu_glUniform3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UI);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ui(struct qemu_syscall *call)
{
    struct qemu_glUniform3ui *c = (struct qemu_glUniform3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ui( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3ui64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ui64ARB( GLint location, GLuint64 x, GLuint64 y, GLuint64 z )
{
    struct qemu_glUniform3ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UI64ARB);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3ui64ARB *c = (struct qemu_glUniform3ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ui64ARB( c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform3ui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ui64NV( GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z )
{
    struct qemu_glUniform3ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UI64NV);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform3ui64NV *c = (struct qemu_glUniform3ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ui64NV( c->location, c->x, c->y, c->z ));
}

#endif

struct qemu_glUniform3ui64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ui64vARB( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniform3ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UI64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform3ui64vARB *c = (struct qemu_glUniform3ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ui64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3ui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3ui64vNV( GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glUniform3ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform3ui64vNV *c = (struct qemu_glUniform3ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3ui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3uiEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3uiEXT( GLint location, GLuint v0, GLuint v1, GLuint v2 )
{
    struct qemu_glUniform3uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UIEXT);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3uiEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform3uiEXT *c = (struct qemu_glUniform3uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3uiEXT( c->location, c->v0, c->v1, c->v2 ));
}

#endif

struct qemu_glUniform3uiv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3uiv( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UIV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3uiv(struct qemu_syscall *call)
{
    struct qemu_glUniform3uiv *c = (struct qemu_glUniform3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3uiv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform3uivEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform3uivEXT( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform3uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM3UIVEXT);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform3uivEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform3uivEXT *c = (struct qemu_glUniform3uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform3uivEXT( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4d
{
    struct qemu_syscall super;
    uint64_t location;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4d( GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glUniform4d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4D);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4d(struct qemu_syscall *call)
{
    struct qemu_glUniform4d *c = (struct qemu_glUniform4d *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4d( c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glUniform4dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4dv( GLint location, GLsizei count, const GLdouble *value )
{
    struct qemu_glUniform4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4DV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4dv(struct qemu_syscall *call)
{
    struct qemu_glUniform4dv *c = (struct qemu_glUniform4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4dv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4f
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
    double v2;
    double v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4f( GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 )
{
    struct qemu_glUniform4f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4F);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4f(struct qemu_syscall *call)
{
    struct qemu_glUniform4f *c = (struct qemu_glUniform4f *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4f( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4fARB
{
    struct qemu_syscall super;
    uint64_t location;
    double v0;
    double v1;
    double v2;
    double v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4fARB( GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 )
{
    struct qemu_glUniform4fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4FARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4fARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4fARB *c = (struct qemu_glUniform4fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4fARB( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4fv( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4FV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4fv(struct qemu_syscall *call)
{
    struct qemu_glUniform4fv *c = (struct qemu_glUniform4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4fv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4fvARB( GLint location, GLsizei count, const GLfloat *value )
{
    struct qemu_glUniform4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4FVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4fvARB *c = (struct qemu_glUniform4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4fvARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4i
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4i( GLint location, GLint v0, GLint v1, GLint v2, GLint v3 )
{
    struct qemu_glUniform4i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4I);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4i(struct qemu_syscall *call)
{
    struct qemu_glUniform4i *c = (struct qemu_glUniform4i *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4i( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4i64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4i64ARB( GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w )
{
    struct qemu_glUniform4i64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4I64ARB);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4i64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4i64ARB *c = (struct qemu_glUniform4i64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4i64ARB( c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glUniform4i64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4i64NV( GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w )
{
    struct qemu_glUniform4i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4I64NV);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4i64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform4i64NV *c = (struct qemu_glUniform4i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4i64NV( c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glUniform4i64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4i64vARB( GLint location, GLsizei count, const GLint64 *value )
{
    struct qemu_glUniform4i64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4I64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4i64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4i64vARB *c = (struct qemu_glUniform4i64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4i64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4i64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4i64vNV( GLint location, GLsizei count, const GLint64EXT *value )
{
    struct qemu_glUniform4i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4I64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4i64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform4i64vNV *c = (struct qemu_glUniform4i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4i64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4iARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4iARB( GLint location, GLint v0, GLint v1, GLint v2, GLint v3 )
{
    struct qemu_glUniform4iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4IARB);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4iARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4iARB *c = (struct qemu_glUniform4iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4iARB( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4iv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4iv( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform4iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4IV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4iv(struct qemu_syscall *call)
{
    struct qemu_glUniform4iv *c = (struct qemu_glUniform4iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4iv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4ivARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ivARB( GLint location, GLsizei count, const GLint *value )
{
    struct qemu_glUniform4ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4IVARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ivARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4ivARB *c = (struct qemu_glUniform4ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ivARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4ui
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ui( GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 )
{
    struct qemu_glUniform4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UI);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ui(struct qemu_syscall *call)
{
    struct qemu_glUniform4ui *c = (struct qemu_glUniform4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ui( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4ui64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ui64ARB( GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w )
{
    struct qemu_glUniform4ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UI64ARB);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4ui64ARB *c = (struct qemu_glUniform4ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ui64ARB( c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glUniform4ui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ui64NV( GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w )
{
    struct qemu_glUniform4ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UI64NV);
    call.location = location;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniform4ui64NV *c = (struct qemu_glUniform4ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ui64NV( c->location, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glUniform4ui64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ui64vARB( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniform4ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UI64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniform4ui64vARB *c = (struct qemu_glUniform4ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ui64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4ui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4ui64vNV( GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glUniform4ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniform4ui64vNV *c = (struct qemu_glUniform4ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4ui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4uiEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t v0;
    uint64_t v1;
    uint64_t v2;
    uint64_t v3;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4uiEXT( GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 )
{
    struct qemu_glUniform4uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UIEXT);
    call.location = location;
    call.v0 = v0;
    call.v1 = v1;
    call.v2 = v2;
    call.v3 = v3;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4uiEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform4uiEXT *c = (struct qemu_glUniform4uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4uiEXT( c->location, c->v0, c->v1, c->v2, c->v3 ));
}

#endif

struct qemu_glUniform4uiv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4uiv( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UIV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4uiv(struct qemu_syscall *call)
{
    struct qemu_glUniform4uiv *c = (struct qemu_glUniform4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4uiv( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniform4uivEXT
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniform4uivEXT( GLint location, GLsizei count, const GLuint *value )
{
    struct qemu_glUniform4uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORM4UIVEXT);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniform4uivEXT(struct qemu_syscall *call)
{
    struct qemu_glUniform4uivEXT *c = (struct qemu_glUniform4uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniform4uivEXT( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformBlockBinding
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t uniformBlockIndex;
    uint64_t uniformBlockBinding;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformBlockBinding( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding )
{
    struct qemu_glUniformBlockBinding call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMBLOCKBINDING);
    call.program = program;
    call.uniformBlockIndex = uniformBlockIndex;
    call.uniformBlockBinding = uniformBlockBinding;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformBlockBinding(struct qemu_syscall *call)
{
    struct qemu_glUniformBlockBinding *c = (struct qemu_glUniformBlockBinding *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformBlockBinding( c->program, c->uniformBlockIndex, c->uniformBlockBinding ));
}

#endif

struct qemu_glUniformBufferEXT
{
    struct qemu_syscall super;
    uint64_t program;
    uint64_t location;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformBufferEXT( GLuint program, GLint location, GLuint buffer )
{
    struct qemu_glUniformBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMBUFFEREXT);
    call.program = program;
    call.location = location;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glUniformBufferEXT *c = (struct qemu_glUniformBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformBufferEXT( c->program, c->location, c->buffer ));
}

#endif

struct qemu_glUniformHandleui64ARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformHandleui64ARB( GLint location, GLuint64 value )
{
    struct qemu_glUniformHandleui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMHANDLEUI64ARB);
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformHandleui64ARB(struct qemu_syscall *call)
{
    struct qemu_glUniformHandleui64ARB *c = (struct qemu_glUniformHandleui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformHandleui64ARB( c->location, c->value ));
}

#endif

struct qemu_glUniformHandleui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformHandleui64NV( GLint location, GLuint64 value )
{
    struct qemu_glUniformHandleui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMHANDLEUI64NV);
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformHandleui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniformHandleui64NV *c = (struct qemu_glUniformHandleui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformHandleui64NV( c->location, c->value ));
}

#endif

struct qemu_glUniformHandleui64vARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformHandleui64vARB( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniformHandleui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMHANDLEUI64VARB);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformHandleui64vARB(struct qemu_syscall *call)
{
    struct qemu_glUniformHandleui64vARB *c = (struct qemu_glUniformHandleui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformHandleui64vARB( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformHandleui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformHandleui64vNV( GLint location, GLsizei count, const GLuint64 *value )
{
    struct qemu_glUniformHandleui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMHANDLEUI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformHandleui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniformHandleui64vNV *c = (struct qemu_glUniformHandleui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformHandleui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2dv *c = (struct qemu_glUniformMatrix2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2fv *c = (struct qemu_glUniformMatrix2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2fvARB( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix2fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2FVARB);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2fvARB *c = (struct qemu_glUniformMatrix2fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2fvARB( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2x3dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2x3dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix2x3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2X3DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2x3dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2x3dv *c = (struct qemu_glUniformMatrix2x3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2x3dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2x3fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2x3fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix2x3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2X3FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2x3fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2x3fv *c = (struct qemu_glUniformMatrix2x3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2x3fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2x4dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2x4dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix2x4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2X4DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2x4dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2x4dv *c = (struct qemu_glUniformMatrix2x4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2x4dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix2x4fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix2x4fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix2x4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX2X4FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix2x4fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix2x4fv *c = (struct qemu_glUniformMatrix2x4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix2x4fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3dv *c = (struct qemu_glUniformMatrix3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3fv *c = (struct qemu_glUniformMatrix3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3fvARB( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix3fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3FVARB);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3fvARB *c = (struct qemu_glUniformMatrix3fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3fvARB( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3x2dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3x2dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix3x2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3X2DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3x2dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3x2dv *c = (struct qemu_glUniformMatrix3x2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3x2dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3x2fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3x2fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix3x2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3X2FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3x2fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3x2fv *c = (struct qemu_glUniformMatrix3x2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3x2fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3x4dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3x4dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix3x4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3X4DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3x4dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3x4dv *c = (struct qemu_glUniformMatrix3x4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3x4dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix3x4fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix3x4fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix3x4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX3X4FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix3x4fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix3x4fv *c = (struct qemu_glUniformMatrix3x4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix3x4fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4dv *c = (struct qemu_glUniformMatrix4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4fv *c = (struct qemu_glUniformMatrix4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4fvARB
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4fvARB( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4FVARB);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4fvARB(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4fvARB *c = (struct qemu_glUniformMatrix4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4fvARB( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4x2dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4x2dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix4x2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4X2DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4x2dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4x2dv *c = (struct qemu_glUniformMatrix4x2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4x2dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4x2fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4x2fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix4x2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4X2FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4x2fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4x2fv *c = (struct qemu_glUniformMatrix4x2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4x2fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4x3dv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4x3dv( GLint location, GLsizei count, GLboolean transpose, const GLdouble *value )
{
    struct qemu_glUniformMatrix4x3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4X3DV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4x3dv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4x3dv *c = (struct qemu_glUniformMatrix4x3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4x3dv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformMatrix4x3fv
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t transpose;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformMatrix4x3fv( GLint location, GLsizei count, GLboolean transpose, const GLfloat *value )
{
    struct qemu_glUniformMatrix4x3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMMATRIX4X3FV);
    call.location = location;
    call.count = count;
    call.transpose = transpose;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformMatrix4x3fv(struct qemu_syscall *call)
{
    struct qemu_glUniformMatrix4x3fv *c = (struct qemu_glUniformMatrix4x3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformMatrix4x3fv( c->location, c->count, c->transpose, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUniformSubroutinesuiv
{
    struct qemu_syscall super;
    uint64_t shadertype;
    uint64_t count;
    uint64_t indices;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformSubroutinesuiv( GLenum shadertype, GLsizei count, const GLuint *indices )
{
    struct qemu_glUniformSubroutinesuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMSUBROUTINESUIV);
    call.shadertype = shadertype;
    call.count = count;
    call.indices = (ULONG_PTR)indices;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformSubroutinesuiv(struct qemu_syscall *call)
{
    struct qemu_glUniformSubroutinesuiv *c = (struct qemu_glUniformSubroutinesuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformSubroutinesuiv( c->shadertype, c->count, QEMU_G2H(c->indices) ));
}

#endif

struct qemu_glUniformui64NV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformui64NV( GLint location, GLuint64EXT value )
{
    struct qemu_glUniformui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMUI64NV);
    call.location = location;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformui64NV(struct qemu_syscall *call)
{
    struct qemu_glUniformui64NV *c = (struct qemu_glUniformui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformui64NV( c->location, c->value ));
}

#endif

struct qemu_glUniformui64vNV
{
    struct qemu_syscall super;
    uint64_t location;
    uint64_t count;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUniformui64vNV( GLint location, GLsizei count, const GLuint64EXT *value )
{
    struct qemu_glUniformui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNIFORMUI64VNV);
    call.location = location;
    call.count = count;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glUniformui64vNV(struct qemu_syscall *call)
{
    struct qemu_glUniformui64vNV *c = (struct qemu_glUniformui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glUniformui64vNV( c->location, c->count, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glUnlockArraysEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUnlockArraysEXT(void)
{
    struct qemu_glUnlockArraysEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNLOCKARRAYSEXT);

    qemu_syscall(&call.super);
}

#else

void qemu_glUnlockArraysEXT(struct qemu_syscall *call)
{
    struct qemu_glUnlockArraysEXT *c = (struct qemu_glUnlockArraysEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUnlockArraysEXT());
}

#endif

struct qemu_glUnmapBuffer
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glUnmapBuffer( GLenum target )
{
    struct qemu_glUnmapBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPBUFFER);
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glUnmapBuffer(struct qemu_syscall *call)
{
    struct qemu_glUnmapBuffer *c = (struct qemu_glUnmapBuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glUnmapBuffer( c->target ));
}

#endif

struct qemu_glUnmapBufferARB
{
    struct qemu_syscall super;
    uint64_t target;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glUnmapBufferARB( GLenum target )
{
    struct qemu_glUnmapBufferARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPBUFFERARB);
    call.target = target;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glUnmapBufferARB(struct qemu_syscall *call)
{
    struct qemu_glUnmapBufferARB *c = (struct qemu_glUnmapBufferARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glUnmapBufferARB( c->target ));
}

#endif

struct qemu_glUnmapNamedBuffer
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glUnmapNamedBuffer( GLuint buffer )
{
    struct qemu_glUnmapNamedBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPNAMEDBUFFER);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glUnmapNamedBuffer(struct qemu_syscall *call)
{
    struct qemu_glUnmapNamedBuffer *c = (struct qemu_glUnmapNamedBuffer *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glUnmapNamedBuffer( c->buffer ));
}

#endif

struct qemu_glUnmapNamedBufferEXT
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glUnmapNamedBufferEXT( GLuint buffer )
{
    struct qemu_glUnmapNamedBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPNAMEDBUFFEREXT);
    call.buffer = buffer;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glUnmapNamedBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glUnmapNamedBufferEXT *c = (struct qemu_glUnmapNamedBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glUnmapNamedBufferEXT( c->buffer ));
}

#endif

struct qemu_glUnmapObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUnmapObjectBufferATI( GLuint buffer )
{
    struct qemu_glUnmapObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPOBJECTBUFFERATI);
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glUnmapObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glUnmapObjectBufferATI *c = (struct qemu_glUnmapObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glUnmapObjectBufferATI( c->buffer ));
}

#endif

struct qemu_glUnmapTexture2DINTEL
{
    struct qemu_syscall super;
    uint64_t texture;
    uint64_t level;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUnmapTexture2DINTEL( GLuint texture, GLint level )
{
    struct qemu_glUnmapTexture2DINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUNMAPTEXTURE2DINTEL);
    call.texture = texture;
    call.level = level;

    qemu_syscall(&call.super);
}

#else

void qemu_glUnmapTexture2DINTEL(struct qemu_syscall *call)
{
    struct qemu_glUnmapTexture2DINTEL *c = (struct qemu_glUnmapTexture2DINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glUnmapTexture2DINTEL( c->texture, c->level ));
}

#endif

struct qemu_glUpdateObjectBufferATI
{
    struct qemu_syscall super;
    uint64_t buffer;
    uint64_t offset;
    uint64_t size;
    uint64_t pointer;
    uint64_t preserve;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUpdateObjectBufferATI( GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve )
{
    struct qemu_glUpdateObjectBufferATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUPDATEOBJECTBUFFERATI);
    call.buffer = buffer;
    call.offset = offset;
    call.size = size;
    call.pointer = (ULONG_PTR)pointer;
    call.preserve = preserve;

    qemu_syscall(&call.super);
}

#else

void qemu_glUpdateObjectBufferATI(struct qemu_syscall *call)
{
    struct qemu_glUpdateObjectBufferATI *c = (struct qemu_glUpdateObjectBufferATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glUpdateObjectBufferATI( c->buffer, c->offset, c->size, QEMU_G2H(c->pointer), c->preserve ));
}

#endif

struct qemu_glUploadGpuMaskNVX
{
    struct qemu_syscall super;
    uint64_t mask;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUploadGpuMaskNVX( GLbitfield mask )
{
    struct qemu_glUploadGpuMaskNVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUPLOADGPUMASKNVX);
    call.mask = mask;

    qemu_syscall(&call.super);
}

#else

void qemu_glUploadGpuMaskNVX(struct qemu_syscall *call)
{
    struct qemu_glUploadGpuMaskNVX *c = (struct qemu_glUploadGpuMaskNVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glUploadGpuMaskNVX( c->mask ));
}

#endif

struct qemu_glUseProgram
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUseProgram( GLuint program )
{
    struct qemu_glUseProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUSEPROGRAM);
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glUseProgram(struct qemu_syscall *call)
{
    struct qemu_glUseProgram *c = (struct qemu_glUseProgram *)call;
    WINE_FIXME("Unverified\n");
    (p_glUseProgram( c->program ));
}

#endif

struct qemu_glUseProgramObjectARB
{
    struct qemu_syscall super;
    uint64_t programObj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUseProgramObjectARB( GLhandleARB programObj )
{
    struct qemu_glUseProgramObjectARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUSEPROGRAMOBJECTARB);
    call.programObj = programObj;

    qemu_syscall(&call.super);
}

#else

void qemu_glUseProgramObjectARB(struct qemu_syscall *call)
{
    struct qemu_glUseProgramObjectARB *c = (struct qemu_glUseProgramObjectARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glUseProgramObjectARB( c->programObj ));
}

#endif

struct qemu_glUseProgramStages
{
    struct qemu_syscall super;
    uint64_t pipeline;
    uint64_t stages;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUseProgramStages( GLuint pipeline, GLbitfield stages, GLuint program )
{
    struct qemu_glUseProgramStages call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUSEPROGRAMSTAGES);
    call.pipeline = pipeline;
    call.stages = stages;
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glUseProgramStages(struct qemu_syscall *call)
{
    struct qemu_glUseProgramStages *c = (struct qemu_glUseProgramStages *)call;
    WINE_FIXME("Unverified\n");
    (p_glUseProgramStages( c->pipeline, c->stages, c->program ));
}

#endif

struct qemu_glUseShaderProgramEXT
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glUseShaderProgramEXT( GLenum type, GLuint program )
{
    struct qemu_glUseShaderProgramEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLUSESHADERPROGRAMEXT);
    call.type = type;
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glUseShaderProgramEXT(struct qemu_syscall *call)
{
    struct qemu_glUseShaderProgramEXT *c = (struct qemu_glUseShaderProgramEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glUseShaderProgramEXT( c->type, c->program ));
}

#endif

struct qemu_glVDPAUFiniNV
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUFiniNV(void)
{
    struct qemu_glVDPAUFiniNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUFININV);

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUFiniNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUFiniNV *c = (struct qemu_glVDPAUFiniNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUFiniNV());
}

#endif

struct qemu_glVDPAUGetSurfaceivNV
{
    struct qemu_syscall super;
    uint64_t surface;
    uint64_t pname;
    uint64_t count;
    uint64_t length;
    uint64_t values;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUGetSurfaceivNV( GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei *length, GLint *values )
{
    struct qemu_glVDPAUGetSurfaceivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUGETSURFACEIVNV);
    call.surface = surface;
    call.pname = pname;
    call.count = count;
    call.length = (ULONG_PTR)length;
    call.values = (ULONG_PTR)values;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUGetSurfaceivNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUGetSurfaceivNV *c = (struct qemu_glVDPAUGetSurfaceivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUGetSurfaceivNV( c->surface, c->pname, c->count, QEMU_G2H(c->length), QEMU_G2H(c->values) ));
}

#endif

struct qemu_glVDPAUInitNV
{
    struct qemu_syscall super;
    uint64_t vdpDevice;
    uint64_t getProcAddress;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUInitNV( const void *vdpDevice, const void *getProcAddress )
{
    struct qemu_glVDPAUInitNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUINITNV);
    call.vdpDevice = (ULONG_PTR)vdpDevice;
    call.getProcAddress = (ULONG_PTR)getProcAddress;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUInitNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUInitNV *c = (struct qemu_glVDPAUInitNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUInitNV( QEMU_G2H(c->vdpDevice), QEMU_G2H(c->getProcAddress) ));
}

#endif

struct qemu_glVDPAUIsSurfaceNV
{
    struct qemu_syscall super;
    uint64_t surface;
};

#ifdef QEMU_DLL_GUEST

GLboolean WINAPI glVDPAUIsSurfaceNV( GLvdpauSurfaceNV surface )
{
    struct qemu_glVDPAUIsSurfaceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUISSURFACENV);
    call.surface = surface;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glVDPAUIsSurfaceNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUIsSurfaceNV *c = (struct qemu_glVDPAUIsSurfaceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glVDPAUIsSurfaceNV( c->surface ));
}

#endif

struct qemu_glVDPAUMapSurfacesNV
{
    struct qemu_syscall super;
    uint64_t numSurfaces;
    uint64_t surfaces;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUMapSurfacesNV( GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces )
{
    struct qemu_glVDPAUMapSurfacesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUMAPSURFACESNV);
    call.numSurfaces = numSurfaces;
    call.surfaces = (ULONG_PTR)surfaces;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUMapSurfacesNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUMapSurfacesNV *c = (struct qemu_glVDPAUMapSurfacesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUMapSurfacesNV( c->numSurfaces, QEMU_G2H(c->surfaces) ));
}

#endif

struct qemu_glVDPAURegisterOutputSurfaceNV
{
    struct qemu_syscall super;
    uint64_t vdpSurface;
    uint64_t target;
    uint64_t numTextureNames;
    uint64_t textureNames;
};

#ifdef QEMU_DLL_GUEST

GLvdpauSurfaceNV WINAPI glVDPAURegisterOutputSurfaceNV( const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames )
{
    struct qemu_glVDPAURegisterOutputSurfaceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUREGISTEROUTPUTSURFACENV);
    call.vdpSurface = (ULONG_PTR)vdpSurface;
    call.target = target;
    call.numTextureNames = numTextureNames;
    call.textureNames = (ULONG_PTR)textureNames;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glVDPAURegisterOutputSurfaceNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAURegisterOutputSurfaceNV *c = (struct qemu_glVDPAURegisterOutputSurfaceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glVDPAURegisterOutputSurfaceNV( QEMU_G2H(c->vdpSurface), c->target, c->numTextureNames, QEMU_G2H(c->textureNames) ));
}

#endif

struct qemu_glVDPAURegisterVideoSurfaceNV
{
    struct qemu_syscall super;
    uint64_t vdpSurface;
    uint64_t target;
    uint64_t numTextureNames;
    uint64_t textureNames;
};

#ifdef QEMU_DLL_GUEST

GLvdpauSurfaceNV WINAPI glVDPAURegisterVideoSurfaceNV( const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames )
{
    struct qemu_glVDPAURegisterVideoSurfaceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUREGISTERVIDEOSURFACENV);
    call.vdpSurface = (ULONG_PTR)vdpSurface;
    call.target = target;
    call.numTextureNames = numTextureNames;
    call.textureNames = (ULONG_PTR)textureNames;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glVDPAURegisterVideoSurfaceNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAURegisterVideoSurfaceNV *c = (struct qemu_glVDPAURegisterVideoSurfaceNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glVDPAURegisterVideoSurfaceNV( QEMU_G2H(c->vdpSurface), c->target, c->numTextureNames, QEMU_G2H(c->textureNames) ));
}

#endif

struct qemu_glVDPAURegisterVideoSurfaceWithPictureStructureNV
{
    struct qemu_syscall super;
    uint64_t vdpSurface;
    uint64_t target;
    uint64_t numTextureNames;
    uint64_t textureNames;
    uint64_t isFrameStructure;
};

#ifdef QEMU_DLL_GUEST

GLvdpauSurfaceNV WINAPI glVDPAURegisterVideoSurfaceWithPictureStructureNV( const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure )
{
    struct qemu_glVDPAURegisterVideoSurfaceWithPictureStructureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENV);
    call.vdpSurface = (ULONG_PTR)vdpSurface;
    call.target = target;
    call.numTextureNames = numTextureNames;
    call.textureNames = (ULONG_PTR)textureNames;
    call.isFrameStructure = isFrameStructure;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glVDPAURegisterVideoSurfaceWithPictureStructureNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAURegisterVideoSurfaceWithPictureStructureNV *c = (struct qemu_glVDPAURegisterVideoSurfaceWithPictureStructureNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glVDPAURegisterVideoSurfaceWithPictureStructureNV( QEMU_G2H(c->vdpSurface), c->target, c->numTextureNames, QEMU_G2H(c->textureNames), c->isFrameStructure ));
}

#endif

struct qemu_glVDPAUSurfaceAccessNV
{
    struct qemu_syscall super;
    uint64_t surface;
    uint64_t access;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUSurfaceAccessNV( GLvdpauSurfaceNV surface, GLenum access )
{
    struct qemu_glVDPAUSurfaceAccessNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUSURFACEACCESSNV);
    call.surface = surface;
    call.access = access;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUSurfaceAccessNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUSurfaceAccessNV *c = (struct qemu_glVDPAUSurfaceAccessNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUSurfaceAccessNV( c->surface, c->access ));
}

#endif

struct qemu_glVDPAUUnmapSurfacesNV
{
    struct qemu_syscall super;
    uint64_t numSurface;
    uint64_t surfaces;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUUnmapSurfacesNV( GLsizei numSurface, const GLvdpauSurfaceNV *surfaces )
{
    struct qemu_glVDPAUUnmapSurfacesNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUUNMAPSURFACESNV);
    call.numSurface = numSurface;
    call.surfaces = (ULONG_PTR)surfaces;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUUnmapSurfacesNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUUnmapSurfacesNV *c = (struct qemu_glVDPAUUnmapSurfacesNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUUnmapSurfacesNV( c->numSurface, QEMU_G2H(c->surfaces) ));
}

#endif

struct qemu_glVDPAUUnregisterSurfaceNV
{
    struct qemu_syscall super;
    uint64_t surface;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVDPAUUnregisterSurfaceNV( GLvdpauSurfaceNV surface )
{
    struct qemu_glVDPAUUnregisterSurfaceNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVDPAUUNREGISTERSURFACENV);
    call.surface = surface;

    qemu_syscall(&call.super);
}

#else

void qemu_glVDPAUUnregisterSurfaceNV(struct qemu_syscall *call)
{
    struct qemu_glVDPAUUnregisterSurfaceNV *c = (struct qemu_glVDPAUUnregisterSurfaceNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVDPAUUnregisterSurfaceNV( c->surface ));
}

#endif

struct qemu_glValidateProgram
{
    struct qemu_syscall super;
    uint64_t program;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glValidateProgram( GLuint program )
{
    struct qemu_glValidateProgram call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVALIDATEPROGRAM);
    call.program = program;

    qemu_syscall(&call.super);
}

#else

void qemu_glValidateProgram(struct qemu_syscall *call)
{
    struct qemu_glValidateProgram *c = (struct qemu_glValidateProgram *)call;
    WINE_FIXME("Unverified\n");
    (p_glValidateProgram( c->program ));
}

#endif

struct qemu_glValidateProgramARB
{
    struct qemu_syscall super;
    uint64_t programObj;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glValidateProgramARB( GLhandleARB programObj )
{
    struct qemu_glValidateProgramARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVALIDATEPROGRAMARB);
    call.programObj = programObj;

    qemu_syscall(&call.super);
}

#else

void qemu_glValidateProgramARB(struct qemu_syscall *call)
{
    struct qemu_glValidateProgramARB *c = (struct qemu_glValidateProgramARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glValidateProgramARB( c->programObj ));
}

#endif

struct qemu_glValidateProgramPipeline
{
    struct qemu_syscall super;
    uint64_t pipeline;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glValidateProgramPipeline( GLuint pipeline )
{
    struct qemu_glValidateProgramPipeline call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVALIDATEPROGRAMPIPELINE);
    call.pipeline = pipeline;

    qemu_syscall(&call.super);
}

#else

void qemu_glValidateProgramPipeline(struct qemu_syscall *call)
{
    struct qemu_glValidateProgramPipeline *c = (struct qemu_glValidateProgramPipeline *)call;
    WINE_FIXME("Unverified\n");
    (p_glValidateProgramPipeline( c->pipeline ));
}

#endif

struct qemu_glVariantArrayObjectATI
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t type;
    uint64_t stride;
    uint64_t buffer;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantArrayObjectATI( GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset )
{
    struct qemu_glVariantArrayObjectATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTARRAYOBJECTATI);
    call.id = id;
    call.type = type;
    call.stride = stride;
    call.buffer = buffer;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantArrayObjectATI(struct qemu_syscall *call)
{
    struct qemu_glVariantArrayObjectATI *c = (struct qemu_glVariantArrayObjectATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantArrayObjectATI( c->id, c->type, c->stride, c->buffer, c->offset ));
}

#endif

struct qemu_glVariantPointerEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t type;
    uint64_t stride;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantPointerEXT( GLuint id, GLenum type, GLuint stride, const void *addr )
{
    struct qemu_glVariantPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTPOINTEREXT);
    call.id = id;
    call.type = type;
    call.stride = stride;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantPointerEXT *c = (struct qemu_glVariantPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantPointerEXT( c->id, c->type, c->stride, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantbvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantbvEXT( GLuint id, const GLbyte *addr )
{
    struct qemu_glVariantbvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTBVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantbvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantbvEXT *c = (struct qemu_glVariantbvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantbvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantdvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantdvEXT( GLuint id, const GLdouble *addr )
{
    struct qemu_glVariantdvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTDVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantdvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantdvEXT *c = (struct qemu_glVariantdvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantdvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantfvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantfvEXT( GLuint id, const GLfloat *addr )
{
    struct qemu_glVariantfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTFVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantfvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantfvEXT *c = (struct qemu_glVariantfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantfvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantivEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantivEXT( GLuint id, const GLint *addr )
{
    struct qemu_glVariantivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTIVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantivEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantivEXT *c = (struct qemu_glVariantivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantivEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantsvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantsvEXT( GLuint id, const GLshort *addr )
{
    struct qemu_glVariantsvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTSVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantsvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantsvEXT *c = (struct qemu_glVariantsvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantsvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantubvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantubvEXT( GLuint id, const GLubyte *addr )
{
    struct qemu_glVariantubvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTUBVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantubvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantubvEXT *c = (struct qemu_glVariantubvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantubvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantuivEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantuivEXT( GLuint id, const GLuint *addr )
{
    struct qemu_glVariantuivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTUIVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantuivEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantuivEXT *c = (struct qemu_glVariantuivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantuivEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVariantusvEXT
{
    struct qemu_syscall super;
    uint64_t id;
    uint64_t addr;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVariantusvEXT( GLuint id, const GLushort *addr )
{
    struct qemu_glVariantusvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVARIANTUSVEXT);
    call.id = id;
    call.addr = (ULONG_PTR)addr;

    qemu_syscall(&call.super);
}

#else

void qemu_glVariantusvEXT(struct qemu_syscall *call)
{
    struct qemu_glVariantusvEXT *c = (struct qemu_glVariantusvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVariantusvEXT( c->id, QEMU_G2H(c->addr) ));
}

#endif

struct qemu_glVertex2bOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2bOES( GLbyte x, GLbyte y )
{
    struct qemu_glVertex2bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2BOES);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2bOES(struct qemu_syscall *call)
{
    struct qemu_glVertex2bOES *c = (struct qemu_glVertex2bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2bOES( c->x, c->y ));
}

#endif

struct qemu_glVertex2bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2bvOES( const GLbyte *coords )
{
    struct qemu_glVertex2bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2bvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex2bvOES *c = (struct qemu_glVertex2bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertex2hNV
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2hNV( GLhalfNV x, GLhalfNV y )
{
    struct qemu_glVertex2hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2HNV);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2hNV(struct qemu_syscall *call)
{
    struct qemu_glVertex2hNV *c = (struct qemu_glVertex2hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2hNV( c->x, c->y ));
}

#endif

struct qemu_glVertex2hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2hvNV( const GLhalfNV *v )
{
    struct qemu_glVertex2hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertex2hvNV *c = (struct qemu_glVertex2hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertex2xOES
{
    struct qemu_syscall super;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2xOES( GLfixed x )
{
    struct qemu_glVertex2xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2XOES);
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2xOES(struct qemu_syscall *call)
{
    struct qemu_glVertex2xOES *c = (struct qemu_glVertex2xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2xOES( c->x ));
}

#endif

struct qemu_glVertex2xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex2xvOES( const GLfixed *coords )
{
    struct qemu_glVertex2xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX2XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex2xvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex2xvOES *c = (struct qemu_glVertex2xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex2xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertex3bOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3bOES( GLbyte x, GLbyte y, GLbyte z )
{
    struct qemu_glVertex3bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3BOES);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3bOES(struct qemu_syscall *call)
{
    struct qemu_glVertex3bOES *c = (struct qemu_glVertex3bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3bOES( c->x, c->y, c->z ));
}

#endif

struct qemu_glVertex3bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3bvOES( const GLbyte *coords )
{
    struct qemu_glVertex3bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3bvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex3bvOES *c = (struct qemu_glVertex3bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertex3hNV
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3hNV( GLhalfNV x, GLhalfNV y, GLhalfNV z )
{
    struct qemu_glVertex3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3HNV);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3hNV(struct qemu_syscall *call)
{
    struct qemu_glVertex3hNV *c = (struct qemu_glVertex3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3hNV( c->x, c->y, c->z ));
}

#endif

struct qemu_glVertex3hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3hvNV( const GLhalfNV *v )
{
    struct qemu_glVertex3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertex3hvNV *c = (struct qemu_glVertex3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertex3xOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3xOES( GLfixed x, GLfixed y )
{
    struct qemu_glVertex3xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3XOES);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3xOES(struct qemu_syscall *call)
{
    struct qemu_glVertex3xOES *c = (struct qemu_glVertex3xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3xOES( c->x, c->y ));
}

#endif

struct qemu_glVertex3xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex3xvOES( const GLfixed *coords )
{
    struct qemu_glVertex3xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX3XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex3xvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex3xvOES *c = (struct qemu_glVertex3xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex3xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertex4bOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4bOES( GLbyte x, GLbyte y, GLbyte z, GLbyte w )
{
    struct qemu_glVertex4bOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4BOES);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4bOES(struct qemu_syscall *call)
{
    struct qemu_glVertex4bOES *c = (struct qemu_glVertex4bOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4bOES( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertex4bvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4bvOES( const GLbyte *coords )
{
    struct qemu_glVertex4bvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4BVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4bvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex4bvOES *c = (struct qemu_glVertex4bvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4bvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertex4hNV
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4hNV( GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w )
{
    struct qemu_glVertex4hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4HNV);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4hNV(struct qemu_syscall *call)
{
    struct qemu_glVertex4hNV *c = (struct qemu_glVertex4hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4hNV( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertex4hvNV
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4hvNV( const GLhalfNV *v )
{
    struct qemu_glVertex4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4HVNV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertex4hvNV *c = (struct qemu_glVertex4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4hvNV( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertex4xOES
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4xOES( GLfixed x, GLfixed y, GLfixed z )
{
    struct qemu_glVertex4xOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4XOES);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4xOES(struct qemu_syscall *call)
{
    struct qemu_glVertex4xOES *c = (struct qemu_glVertex4xOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4xOES( c->x, c->y, c->z ));
}

#endif

struct qemu_glVertex4xvOES
{
    struct qemu_syscall super;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertex4xvOES( const GLfixed *coords )
{
    struct qemu_glVertex4xvOES call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEX4XVOES);
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertex4xvOES(struct qemu_syscall *call)
{
    struct qemu_glVertex4xvOES *c = (struct qemu_glVertex4xvOES *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertex4xvOES( QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexArrayAttribBinding
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t bindingindex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayAttribBinding( GLuint vaobj, GLuint attribindex, GLuint bindingindex )
{
    struct qemu_glVertexArrayAttribBinding call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYATTRIBBINDING);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.bindingindex = bindingindex;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayAttribBinding(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayAttribBinding *c = (struct qemu_glVertexArrayAttribBinding *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayAttribBinding( c->vaobj, c->attribindex, c->bindingindex ));
}

#endif

struct qemu_glVertexArrayAttribFormat
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayAttribFormat( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset )
{
    struct qemu_glVertexArrayAttribFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYATTRIBFORMAT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayAttribFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayAttribFormat *c = (struct qemu_glVertexArrayAttribFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayAttribFormat( c->vaobj, c->attribindex, c->size, c->type, c->normalized, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayAttribIFormat
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayAttribIFormat( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexArrayAttribIFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYATTRIBIFORMAT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayAttribIFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayAttribIFormat *c = (struct qemu_glVertexArrayAttribIFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayAttribIFormat( c->vaobj, c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayAttribLFormat
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayAttribLFormat( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexArrayAttribLFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYATTRIBLFORMAT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayAttribLFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayAttribLFormat *c = (struct qemu_glVertexArrayAttribLFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayAttribLFormat( c->vaobj, c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayBindVertexBufferEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t bindingindex;
    uint64_t buffer;
    uint64_t offset;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayBindVertexBufferEXT( GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride )
{
    struct qemu_glVertexArrayBindVertexBufferEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYBINDVERTEXBUFFEREXT);
    call.vaobj = vaobj;
    call.bindingindex = bindingindex;
    call.buffer = buffer;
    call.offset = offset;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayBindVertexBufferEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayBindVertexBufferEXT *c = (struct qemu_glVertexArrayBindVertexBufferEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayBindVertexBufferEXT( c->vaobj, c->bindingindex, c->buffer, c->offset, c->stride ));
}

#endif

struct qemu_glVertexArrayBindingDivisor
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t bindingindex;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayBindingDivisor( GLuint vaobj, GLuint bindingindex, GLuint divisor )
{
    struct qemu_glVertexArrayBindingDivisor call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYBINDINGDIVISOR);
    call.vaobj = vaobj;
    call.bindingindex = bindingindex;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayBindingDivisor(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayBindingDivisor *c = (struct qemu_glVertexArrayBindingDivisor *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayBindingDivisor( c->vaobj, c->bindingindex, c->divisor ));
}

#endif

struct qemu_glVertexArrayColorOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayColorOffsetEXT( GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayColorOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYCOLOROFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayColorOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayColorOffsetEXT *c = (struct qemu_glVertexArrayColorOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayColorOffsetEXT( c->vaobj, c->buffer, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayEdgeFlagOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayEdgeFlagOffsetEXT( GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayEdgeFlagOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYEDGEFLAGOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayEdgeFlagOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayEdgeFlagOffsetEXT *c = (struct qemu_glVertexArrayEdgeFlagOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayEdgeFlagOffsetEXT( c->vaobj, c->buffer, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayElementBuffer
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayElementBuffer( GLuint vaobj, GLuint buffer )
{
    struct qemu_glVertexArrayElementBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYELEMENTBUFFER);
    call.vaobj = vaobj;
    call.buffer = buffer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayElementBuffer(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayElementBuffer *c = (struct qemu_glVertexArrayElementBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayElementBuffer( c->vaobj, c->buffer ));
}

#endif

struct qemu_glVertexArrayFogCoordOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayFogCoordOffsetEXT( GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayFogCoordOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYFOGCOORDOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayFogCoordOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayFogCoordOffsetEXT *c = (struct qemu_glVertexArrayFogCoordOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayFogCoordOffsetEXT( c->vaobj, c->buffer, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayIndexOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayIndexOffsetEXT( GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayIndexOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYINDEXOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayIndexOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayIndexOffsetEXT *c = (struct qemu_glVertexArrayIndexOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayIndexOffsetEXT( c->vaobj, c->buffer, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayMultiTexCoordOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t texunit;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayMultiTexCoordOffsetEXT( GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayMultiTexCoordOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.texunit = texunit;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayMultiTexCoordOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayMultiTexCoordOffsetEXT *c = (struct qemu_glVertexArrayMultiTexCoordOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayMultiTexCoordOffsetEXT( c->vaobj, c->buffer, c->texunit, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayNormalOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayNormalOffsetEXT( GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayNormalOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYNORMALOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayNormalOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayNormalOffsetEXT *c = (struct qemu_glVertexArrayNormalOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayNormalOffsetEXT( c->vaobj, c->buffer, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayParameteriAPPLE
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayParameteriAPPLE( GLenum pname, GLint param )
{
    struct qemu_glVertexArrayParameteriAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYPARAMETERIAPPLE);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayParameteriAPPLE(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayParameteriAPPLE *c = (struct qemu_glVertexArrayParameteriAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayParameteriAPPLE( c->pname, c->param ));
}

#endif

struct qemu_glVertexArrayRangeAPPLE
{
    struct qemu_syscall super;
    uint64_t length;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayRangeAPPLE( GLsizei length, void *pointer )
{
    struct qemu_glVertexArrayRangeAPPLE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYRANGEAPPLE);
    call.length = length;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayRangeAPPLE(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayRangeAPPLE *c = (struct qemu_glVertexArrayRangeAPPLE *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayRangeAPPLE( c->length, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexArrayRangeNV
{
    struct qemu_syscall super;
    uint64_t length;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayRangeNV( GLsizei length, const void *pointer )
{
    struct qemu_glVertexArrayRangeNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYRANGENV);
    call.length = length;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayRangeNV(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayRangeNV *c = (struct qemu_glVertexArrayRangeNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayRangeNV( c->length, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexArraySecondaryColorOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArraySecondaryColorOffsetEXT( GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArraySecondaryColorOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArraySecondaryColorOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArraySecondaryColorOffsetEXT *c = (struct qemu_glVertexArraySecondaryColorOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArraySecondaryColorOffsetEXT( c->vaobj, c->buffer, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayTexCoordOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayTexCoordOffsetEXT( GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayTexCoordOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYTEXCOORDOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayTexCoordOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayTexCoordOffsetEXT *c = (struct qemu_glVertexArrayTexCoordOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayTexCoordOffsetEXT( c->vaobj, c->buffer, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayVertexAttribBindingEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t bindingindex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribBindingEXT( GLuint vaobj, GLuint attribindex, GLuint bindingindex )
{
    struct qemu_glVertexArrayVertexAttribBindingEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.bindingindex = bindingindex;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribBindingEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribBindingEXT *c = (struct qemu_glVertexArrayVertexAttribBindingEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribBindingEXT( c->vaobj, c->attribindex, c->bindingindex ));
}

#endif

struct qemu_glVertexArrayVertexAttribDivisorEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t index;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribDivisorEXT( GLuint vaobj, GLuint index, GLuint divisor )
{
    struct qemu_glVertexArrayVertexAttribDivisorEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBDIVISOREXT);
    call.vaobj = vaobj;
    call.index = index;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribDivisorEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribDivisorEXT *c = (struct qemu_glVertexArrayVertexAttribDivisorEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribDivisorEXT( c->vaobj, c->index, c->divisor ));
}

#endif

struct qemu_glVertexArrayVertexAttribFormatEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribFormatEXT( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset )
{
    struct qemu_glVertexArrayVertexAttribFormatEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBFORMATEXT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribFormatEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribFormatEXT *c = (struct qemu_glVertexArrayVertexAttribFormatEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribFormatEXT( c->vaobj, c->attribindex, c->size, c->type, c->normalized, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayVertexAttribIFormatEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribIFormatEXT( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexArrayVertexAttribIFormatEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribIFormatEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribIFormatEXT *c = (struct qemu_glVertexArrayVertexAttribIFormatEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribIFormatEXT( c->vaobj, c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayVertexAttribIOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribIOffsetEXT( GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayVertexAttribIOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribIOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribIOffsetEXT *c = (struct qemu_glVertexArrayVertexAttribIOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribIOffsetEXT( c->vaobj, c->buffer, c->index, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayVertexAttribLFormatEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribLFormatEXT( GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexArrayVertexAttribLFormatEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT);
    call.vaobj = vaobj;
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribLFormatEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribLFormatEXT *c = (struct qemu_glVertexArrayVertexAttribLFormatEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribLFormatEXT( c->vaobj, c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexArrayVertexAttribLOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribLOffsetEXT( GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayVertexAttribLOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribLOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribLOffsetEXT *c = (struct qemu_glVertexArrayVertexAttribLOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribLOffsetEXT( c->vaobj, c->buffer, c->index, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayVertexAttribOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexAttribOffsetEXT( GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayVertexAttribOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.index = index;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexAttribOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexAttribOffsetEXT *c = (struct qemu_glVertexArrayVertexAttribOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexAttribOffsetEXT( c->vaobj, c->buffer, c->index, c->size, c->type, c->normalized, c->stride, c->offset ));
}

#endif

struct qemu_glVertexArrayVertexBindingDivisorEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t bindingindex;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexBindingDivisorEXT( GLuint vaobj, GLuint bindingindex, GLuint divisor )
{
    struct qemu_glVertexArrayVertexBindingDivisorEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT);
    call.vaobj = vaobj;
    call.bindingindex = bindingindex;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexBindingDivisorEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexBindingDivisorEXT *c = (struct qemu_glVertexArrayVertexBindingDivisorEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexBindingDivisorEXT( c->vaobj, c->bindingindex, c->divisor ));
}

#endif

struct qemu_glVertexArrayVertexBuffer
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t bindingindex;
    uint64_t buffer;
    uint64_t offset;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexBuffer( GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride )
{
    struct qemu_glVertexArrayVertexBuffer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXBUFFER);
    call.vaobj = vaobj;
    call.bindingindex = bindingindex;
    call.buffer = buffer;
    call.offset = offset;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexBuffer(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexBuffer *c = (struct qemu_glVertexArrayVertexBuffer *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexBuffer( c->vaobj, c->bindingindex, c->buffer, c->offset, c->stride ));
}

#endif

struct qemu_glVertexArrayVertexBuffers
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t first;
    uint64_t count;
    uint64_t buffers;
    uint64_t offsets;
    uint64_t strides;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexBuffers( GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides )
{
    struct qemu_glVertexArrayVertexBuffers call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXBUFFERS);
    call.vaobj = vaobj;
    call.first = first;
    call.count = count;
    call.buffers = (ULONG_PTR)buffers;
    call.offsets = (ULONG_PTR)offsets;
    call.strides = (ULONG_PTR)strides;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexBuffers(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexBuffers *c = (struct qemu_glVertexArrayVertexBuffers *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexBuffers( c->vaobj, c->first, c->count, QEMU_G2H(c->buffers), QEMU_G2H(c->offsets), QEMU_G2H(c->strides) ));
}

#endif

struct qemu_glVertexArrayVertexOffsetEXT
{
    struct qemu_syscall super;
    uint64_t vaobj;
    uint64_t buffer;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexArrayVertexOffsetEXT( GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset )
{
    struct qemu_glVertexArrayVertexOffsetEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXARRAYVERTEXOFFSETEXT);
    call.vaobj = vaobj;
    call.buffer = buffer;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexArrayVertexOffsetEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexArrayVertexOffsetEXT *c = (struct qemu_glVertexArrayVertexOffsetEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexArrayVertexOffsetEXT( c->vaobj, c->buffer, c->size, c->type, c->stride, c->offset ));
}

#endif

struct qemu_glVertexAttrib1d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1d( GLuint index, GLdouble x )
{
    struct qemu_glVertexAttrib1d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1D);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1d *c = (struct qemu_glVertexAttrib1d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1d( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1dARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1dARB( GLuint index, GLdouble x )
{
    struct qemu_glVertexAttrib1dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1DARB);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1dARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1dARB *c = (struct qemu_glVertexAttrib1dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1dARB( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1dNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1dNV( GLuint index, GLdouble x )
{
    struct qemu_glVertexAttrib1dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1DNV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1dNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1dNV *c = (struct qemu_glVertexAttrib1dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1dNV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib1dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1dv *c = (struct qemu_glVertexAttrib1dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1dvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1dvARB( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib1dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1DVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1dvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1dvARB *c = (struct qemu_glVertexAttrib1dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1dvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1dvNV( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib1dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1DVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1dvNV *c = (struct qemu_glVertexAttrib1dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1dvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1f
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1f( GLuint index, GLfloat x )
{
    struct qemu_glVertexAttrib1f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1F);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1f(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1f *c = (struct qemu_glVertexAttrib1f *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1f( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1fARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1fARB( GLuint index, GLfloat x )
{
    struct qemu_glVertexAttrib1fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1FARB);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1fARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1fARB *c = (struct qemu_glVertexAttrib1fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1fARB( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1fNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1fNV( GLuint index, GLfloat x )
{
    struct qemu_glVertexAttrib1fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1FNV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1fNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1fNV *c = (struct qemu_glVertexAttrib1fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1fNV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1fv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1fv( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib1fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1FV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1fv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1fv *c = (struct qemu_glVertexAttrib1fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1fv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1fvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1fvARB( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib1fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1FVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1fvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1fvARB *c = (struct qemu_glVertexAttrib1fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1fvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1fvNV( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib1fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1FVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1fvNV *c = (struct qemu_glVertexAttrib1fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1fvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1hNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1hNV( GLuint index, GLhalfNV x )
{
    struct qemu_glVertexAttrib1hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1HNV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1hNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1hNV *c = (struct qemu_glVertexAttrib1hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1hNV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1hvNV( GLuint index, const GLhalfNV *v )
{
    struct qemu_glVertexAttrib1hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1HVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1hvNV *c = (struct qemu_glVertexAttrib1hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1hvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1s
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1s( GLuint index, GLshort x )
{
    struct qemu_glVertexAttrib1s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1S);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1s(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1s *c = (struct qemu_glVertexAttrib1s *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1s( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1sARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1sARB( GLuint index, GLshort x )
{
    struct qemu_glVertexAttrib1sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1SARB);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1sARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1sARB *c = (struct qemu_glVertexAttrib1sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1sARB( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1sNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1sNV( GLuint index, GLshort x )
{
    struct qemu_glVertexAttrib1sNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1SNV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1sNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1sNV *c = (struct qemu_glVertexAttrib1sNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1sNV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttrib1sv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1sv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib1sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1SV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1sv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1sv *c = (struct qemu_glVertexAttrib1sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1sv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1svARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1svARB( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib1svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1SVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1svARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1svARB *c = (struct qemu_glVertexAttrib1svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1svARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib1svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib1svNV( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib1svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB1SVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib1svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib1svNV *c = (struct qemu_glVertexAttrib1svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib1svNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2d( GLuint index, GLdouble x, GLdouble y )
{
    struct qemu_glVertexAttrib2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2D);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2d *c = (struct qemu_glVertexAttrib2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2d( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2dARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2dARB( GLuint index, GLdouble x, GLdouble y )
{
    struct qemu_glVertexAttrib2dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2DARB);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2dARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2dARB *c = (struct qemu_glVertexAttrib2dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2dARB( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2dNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2dNV( GLuint index, GLdouble x, GLdouble y )
{
    struct qemu_glVertexAttrib2dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2DNV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2dNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2dNV *c = (struct qemu_glVertexAttrib2dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2dNV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2dv *c = (struct qemu_glVertexAttrib2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2dvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2dvARB( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib2dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2DVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2dvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2dvARB *c = (struct qemu_glVertexAttrib2dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2dvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2dvNV( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib2dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2DVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2dvNV *c = (struct qemu_glVertexAttrib2dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2dvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2f
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2f( GLuint index, GLfloat x, GLfloat y )
{
    struct qemu_glVertexAttrib2f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2F);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2f(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2f *c = (struct qemu_glVertexAttrib2f *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2f( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2fARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2fARB( GLuint index, GLfloat x, GLfloat y )
{
    struct qemu_glVertexAttrib2fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2FARB);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2fARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2fARB *c = (struct qemu_glVertexAttrib2fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2fARB( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2fNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2fNV( GLuint index, GLfloat x, GLfloat y )
{
    struct qemu_glVertexAttrib2fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2FNV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2fNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2fNV *c = (struct qemu_glVertexAttrib2fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2fNV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2fv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2fv( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2FV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2fv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2fv *c = (struct qemu_glVertexAttrib2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2fv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2fvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2fvARB( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib2fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2FVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2fvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2fvARB *c = (struct qemu_glVertexAttrib2fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2fvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2fvNV( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib2fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2FVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2fvNV *c = (struct qemu_glVertexAttrib2fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2fvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2hNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2hNV( GLuint index, GLhalfNV x, GLhalfNV y )
{
    struct qemu_glVertexAttrib2hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2HNV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2hNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2hNV *c = (struct qemu_glVertexAttrib2hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2hNV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2hvNV( GLuint index, const GLhalfNV *v )
{
    struct qemu_glVertexAttrib2hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2HVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2hvNV *c = (struct qemu_glVertexAttrib2hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2hvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2s
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2s( GLuint index, GLshort x, GLshort y )
{
    struct qemu_glVertexAttrib2s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2S);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2s(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2s *c = (struct qemu_glVertexAttrib2s *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2s( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2sARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2sARB( GLuint index, GLshort x, GLshort y )
{
    struct qemu_glVertexAttrib2sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2SARB);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2sARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2sARB *c = (struct qemu_glVertexAttrib2sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2sARB( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2sNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2sNV( GLuint index, GLshort x, GLshort y )
{
    struct qemu_glVertexAttrib2sNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2SNV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2sNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2sNV *c = (struct qemu_glVertexAttrib2sNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2sNV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttrib2sv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2sv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib2sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2SV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2sv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2sv *c = (struct qemu_glVertexAttrib2sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2sv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2svARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2svARB( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib2svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2SVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2svARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2svARB *c = (struct qemu_glVertexAttrib2svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2svARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib2svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib2svNV( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib2svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB2SVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib2svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib2svNV *c = (struct qemu_glVertexAttrib2svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib2svNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3d( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexAttrib3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3D);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3d *c = (struct qemu_glVertexAttrib3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3d( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3dARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexAttrib3dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3DARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3dARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3dARB *c = (struct qemu_glVertexAttrib3dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3dARB( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3dNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3dNV( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexAttrib3dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3DNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3dNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3dNV *c = (struct qemu_glVertexAttrib3dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3dNV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3dv *c = (struct qemu_glVertexAttrib3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3dvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3dvARB( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib3dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3DVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3dvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3dvARB *c = (struct qemu_glVertexAttrib3dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3dvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3dvNV( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib3dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3DVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3dvNV *c = (struct qemu_glVertexAttrib3dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3dvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3f
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3f( GLuint index, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glVertexAttrib3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3F);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3f(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3f *c = (struct qemu_glVertexAttrib3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3f( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3fARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glVertexAttrib3fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3FARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3fARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3fARB *c = (struct qemu_glVertexAttrib3fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3fARB( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3fNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3fNV( GLuint index, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glVertexAttrib3fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3FNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3fNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3fNV *c = (struct qemu_glVertexAttrib3fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3fNV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3fv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3fv( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3FV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3fv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3fv *c = (struct qemu_glVertexAttrib3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3fv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3fvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3fvARB( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib3fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3FVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3fvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3fvARB *c = (struct qemu_glVertexAttrib3fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3fvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3fvNV( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib3fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3FVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3fvNV *c = (struct qemu_glVertexAttrib3fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3fvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3hNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3hNV( GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z )
{
    struct qemu_glVertexAttrib3hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3HNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3hNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3hNV *c = (struct qemu_glVertexAttrib3hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3hNV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3hvNV( GLuint index, const GLhalfNV *v )
{
    struct qemu_glVertexAttrib3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3HVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3hvNV *c = (struct qemu_glVertexAttrib3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3hvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3s
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3s( GLuint index, GLshort x, GLshort y, GLshort z )
{
    struct qemu_glVertexAttrib3s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3S);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3s(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3s *c = (struct qemu_glVertexAttrib3s *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3s( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3sARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3sARB( GLuint index, GLshort x, GLshort y, GLshort z )
{
    struct qemu_glVertexAttrib3sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3SARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3sARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3sARB *c = (struct qemu_glVertexAttrib3sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3sARB( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3sNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3sNV( GLuint index, GLshort x, GLshort y, GLshort z )
{
    struct qemu_glVertexAttrib3sNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3SNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3sNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3sNV *c = (struct qemu_glVertexAttrib3sNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3sNV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttrib3sv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3sv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib3sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3SV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3sv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3sv *c = (struct qemu_glVertexAttrib3sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3sv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3svARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3svARB( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib3svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3SVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3svARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3svARB *c = (struct qemu_glVertexAttrib3svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3svARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib3svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib3svNV( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib3svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB3SVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib3svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib3svNV *c = (struct qemu_glVertexAttrib3svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib3svNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Nbv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nbv( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttrib4Nbv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NBV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nbv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nbv *c = (struct qemu_glVertexAttrib4Nbv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nbv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NbvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NbvARB( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttrib4NbvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NBVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NbvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NbvARB *c = (struct qemu_glVertexAttrib4NbvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NbvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Niv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Niv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttrib4Niv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Niv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Niv *c = (struct qemu_glVertexAttrib4Niv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Niv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NivARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NivARB( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttrib4NivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NIVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NivARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NivARB *c = (struct qemu_glVertexAttrib4NivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NivARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Nsv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nsv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib4Nsv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NSV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nsv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nsv *c = (struct qemu_glVertexAttrib4Nsv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nsv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NsvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NsvARB( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib4NsvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NSVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NsvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NsvARB *c = (struct qemu_glVertexAttrib4NsvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NsvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Nub
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nub( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
{
    struct qemu_glVertexAttrib4Nub call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nub(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nub *c = (struct qemu_glVertexAttrib4Nub *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nub( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4NubARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NubARB( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
{
    struct qemu_glVertexAttrib4NubARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUBARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NubARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NubARB *c = (struct qemu_glVertexAttrib4NubARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NubARB( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4Nubv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nubv( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttrib4Nubv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUBV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nubv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nubv *c = (struct qemu_glVertexAttrib4Nubv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nubv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NubvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NubvARB( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttrib4NubvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUBVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NubvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NubvARB *c = (struct qemu_glVertexAttrib4NubvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NubvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Nuiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nuiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttrib4Nuiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nuiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nuiv *c = (struct qemu_glVertexAttrib4Nuiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nuiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NuivARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NuivARB( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttrib4NuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUIVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NuivARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NuivARB *c = (struct qemu_glVertexAttrib4NuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NuivARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4Nusv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4Nusv( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttrib4Nusv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUSV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4Nusv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4Nusv *c = (struct qemu_glVertexAttrib4Nusv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4Nusv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4NusvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4NusvARB( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttrib4NusvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4NUSVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4NusvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4NusvARB *c = (struct qemu_glVertexAttrib4NusvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4NusvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4bv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4bv( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttrib4bv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4BV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4bv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4bv *c = (struct qemu_glVertexAttrib4bv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4bv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4bvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4bvARB( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttrib4bvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4BVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4bvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4bvARB *c = (struct qemu_glVertexAttrib4bvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4bvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4d( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexAttrib4d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4D);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4d *c = (struct qemu_glVertexAttrib4d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4d( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4dARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexAttrib4dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4DARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4dARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4dARB *c = (struct qemu_glVertexAttrib4dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4dARB( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4dNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4dNV( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexAttrib4dNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4DNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4dNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4dNV *c = (struct qemu_glVertexAttrib4dNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4dNV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4dv *c = (struct qemu_glVertexAttrib4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4dvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4dvARB( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib4dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4DVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4dvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4dvARB *c = (struct qemu_glVertexAttrib4dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4dvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4dvNV( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttrib4dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4DVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4dvNV *c = (struct qemu_glVertexAttrib4dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4dvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4f
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4f( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glVertexAttrib4f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4F);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4f(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4f *c = (struct qemu_glVertexAttrib4f *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4f( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4fARB
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glVertexAttrib4fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4FARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4fARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4fARB *c = (struct qemu_glVertexAttrib4fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4fARB( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4fNV
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4fNV( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glVertexAttrib4fNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4FNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4fNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4fNV *c = (struct qemu_glVertexAttrib4fNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4fNV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4fv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4fv( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib4fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4FV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4fv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4fv *c = (struct qemu_glVertexAttrib4fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4fv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4fvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4fvARB( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib4fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4FVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4fvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4fvARB *c = (struct qemu_glVertexAttrib4fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4fvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4fvNV( GLuint index, const GLfloat *v )
{
    struct qemu_glVertexAttrib4fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4FVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4fvNV *c = (struct qemu_glVertexAttrib4fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4fvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4hNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4hNV( GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w )
{
    struct qemu_glVertexAttrib4hNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4HNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4hNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4hNV *c = (struct qemu_glVertexAttrib4hNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4hNV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4hvNV( GLuint index, const GLhalfNV *v )
{
    struct qemu_glVertexAttrib4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4HVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4hvNV *c = (struct qemu_glVertexAttrib4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4hvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4iv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4iv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttrib4iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4IV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4iv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4iv *c = (struct qemu_glVertexAttrib4iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4iv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4ivARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4ivARB( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttrib4ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4IVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4ivARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4ivARB *c = (struct qemu_glVertexAttrib4ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4ivARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4s
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4s( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
{
    struct qemu_glVertexAttrib4s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4S);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4s(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4s *c = (struct qemu_glVertexAttrib4s *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4s( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4sARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4sARB( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
{
    struct qemu_glVertexAttrib4sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4SARB);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4sARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4sARB *c = (struct qemu_glVertexAttrib4sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4sARB( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4sNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4sNV( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
{
    struct qemu_glVertexAttrib4sNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4SNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4sNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4sNV *c = (struct qemu_glVertexAttrib4sNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4sNV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4sv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4sv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib4sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4SV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4sv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4sv *c = (struct qemu_glVertexAttrib4sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4sv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4svARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4svARB( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib4svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4SVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4svARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4svARB *c = (struct qemu_glVertexAttrib4svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4svARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4svNV( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttrib4svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4SVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4svNV *c = (struct qemu_glVertexAttrib4svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4svNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4ubNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4ubNV( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
{
    struct qemu_glVertexAttrib4ubNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UBNV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4ubNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4ubNV *c = (struct qemu_glVertexAttrib4ubNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4ubNV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttrib4ubv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4ubv( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttrib4ubv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UBV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4ubv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4ubv *c = (struct qemu_glVertexAttrib4ubv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4ubv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4ubvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4ubvARB( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttrib4ubvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UBVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4ubvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4ubvARB *c = (struct qemu_glVertexAttrib4ubvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4ubvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4ubvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4ubvNV( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttrib4ubvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UBVNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4ubvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4ubvNV *c = (struct qemu_glVertexAttrib4ubvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4ubvNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4uiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttrib4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4uiv *c = (struct qemu_glVertexAttrib4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4uiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4uivARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4uivARB( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttrib4uivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4UIVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4uivARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4uivARB *c = (struct qemu_glVertexAttrib4uivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4uivARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4usv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4usv( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttrib4usv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4USV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4usv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4usv *c = (struct qemu_glVertexAttrib4usv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4usv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttrib4usvARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttrib4usvARB( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttrib4usvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIB4USVARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttrib4usvARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttrib4usvARB *c = (struct qemu_glVertexAttrib4usvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttrib4usvARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribArrayObjectATI
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t stride;
    uint64_t buffer;
    uint64_t offset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribArrayObjectATI( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset )
{
    struct qemu_glVertexAttribArrayObjectATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBARRAYOBJECTATI);
    call.index = index;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.stride = stride;
    call.buffer = buffer;
    call.offset = offset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribArrayObjectATI(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribArrayObjectATI *c = (struct qemu_glVertexAttribArrayObjectATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribArrayObjectATI( c->index, c->size, c->type, c->normalized, c->stride, c->buffer, c->offset ));
}

#endif

struct qemu_glVertexAttribBinding
{
    struct qemu_syscall super;
    uint64_t attribindex;
    uint64_t bindingindex;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribBinding( GLuint attribindex, GLuint bindingindex )
{
    struct qemu_glVertexAttribBinding call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBBINDING);
    call.attribindex = attribindex;
    call.bindingindex = bindingindex;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribBinding(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribBinding *c = (struct qemu_glVertexAttribBinding *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribBinding( c->attribindex, c->bindingindex ));
}

#endif

struct qemu_glVertexAttribDivisor
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribDivisor( GLuint index, GLuint divisor )
{
    struct qemu_glVertexAttribDivisor call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBDIVISOR);
    call.index = index;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribDivisor(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribDivisor *c = (struct qemu_glVertexAttribDivisor *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribDivisor( c->index, c->divisor ));
}

#endif

struct qemu_glVertexAttribDivisorARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribDivisorARB( GLuint index, GLuint divisor )
{
    struct qemu_glVertexAttribDivisorARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBDIVISORARB);
    call.index = index;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribDivisorARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribDivisorARB *c = (struct qemu_glVertexAttribDivisorARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribDivisorARB( c->index, c->divisor ));
}

#endif

struct qemu_glVertexAttribFormat
{
    struct qemu_syscall super;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribFormat( GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset )
{
    struct qemu_glVertexAttribFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBFORMAT);
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribFormat *c = (struct qemu_glVertexAttribFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribFormat( c->attribindex, c->size, c->type, c->normalized, c->relativeoffset ));
}

#endif

struct qemu_glVertexAttribFormatNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribFormatNV( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride )
{
    struct qemu_glVertexAttribFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBFORMATNV);
    call.index = index;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribFormatNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribFormatNV *c = (struct qemu_glVertexAttribFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribFormatNV( c->index, c->size, c->type, c->normalized, c->stride ));
}

#endif

struct qemu_glVertexAttribI1i
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1i( GLuint index, GLint x )
{
    struct qemu_glVertexAttribI1i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1I);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1i(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1i *c = (struct qemu_glVertexAttribI1i *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1i( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribI1iEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1iEXT( GLuint index, GLint x )
{
    struct qemu_glVertexAttribI1iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1IEXT);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1iEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1iEXT *c = (struct qemu_glVertexAttribI1iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1iEXT( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribI1iv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1iv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI1iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1IV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1iv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1iv *c = (struct qemu_glVertexAttribI1iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1iv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI1ivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1ivEXT( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI1ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1IVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1ivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1ivEXT *c = (struct qemu_glVertexAttribI1ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1ivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI1ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1ui( GLuint index, GLuint x )
{
    struct qemu_glVertexAttribI1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1UI);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1ui *c = (struct qemu_glVertexAttribI1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1ui( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribI1uiEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1uiEXT( GLuint index, GLuint x )
{
    struct qemu_glVertexAttribI1uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1UIEXT);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1uiEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1uiEXT *c = (struct qemu_glVertexAttribI1uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1uiEXT( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribI1uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1uiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1UIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1uiv *c = (struct qemu_glVertexAttribI1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1uiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI1uivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI1uivEXT( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI1uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI1UIVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI1uivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI1uivEXT *c = (struct qemu_glVertexAttribI1uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI1uivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI2i
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2i( GLuint index, GLint x, GLint y )
{
    struct qemu_glVertexAttribI2i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2I);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2i(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2i *c = (struct qemu_glVertexAttribI2i *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2i( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribI2iEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2iEXT( GLuint index, GLint x, GLint y )
{
    struct qemu_glVertexAttribI2iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2IEXT);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2iEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2iEXT *c = (struct qemu_glVertexAttribI2iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2iEXT( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribI2iv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2iv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI2iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2IV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2iv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2iv *c = (struct qemu_glVertexAttribI2iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2iv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI2ivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2ivEXT( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI2ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2IVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2ivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2ivEXT *c = (struct qemu_glVertexAttribI2ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2ivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI2ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2ui( GLuint index, GLuint x, GLuint y )
{
    struct qemu_glVertexAttribI2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2UI);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2ui *c = (struct qemu_glVertexAttribI2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2ui( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribI2uiEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2uiEXT( GLuint index, GLuint x, GLuint y )
{
    struct qemu_glVertexAttribI2uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2UIEXT);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2uiEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2uiEXT *c = (struct qemu_glVertexAttribI2uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2uiEXT( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribI2uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2uiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2UIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2uiv *c = (struct qemu_glVertexAttribI2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2uiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI2uivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI2uivEXT( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI2uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI2UIVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI2uivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI2uivEXT *c = (struct qemu_glVertexAttribI2uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI2uivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI3i
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3i( GLuint index, GLint x, GLint y, GLint z )
{
    struct qemu_glVertexAttribI3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3I);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3i(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3i *c = (struct qemu_glVertexAttribI3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3i( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribI3iEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3iEXT( GLuint index, GLint x, GLint y, GLint z )
{
    struct qemu_glVertexAttribI3iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3IEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3iEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3iEXT *c = (struct qemu_glVertexAttribI3iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3iEXT( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribI3iv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3iv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3IV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3iv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3iv *c = (struct qemu_glVertexAttribI3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3iv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI3ivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3ivEXT( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI3ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3IVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3ivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3ivEXT *c = (struct qemu_glVertexAttribI3ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3ivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI3ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3ui( GLuint index, GLuint x, GLuint y, GLuint z )
{
    struct qemu_glVertexAttribI3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3UI);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3ui *c = (struct qemu_glVertexAttribI3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3ui( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribI3uiEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3uiEXT( GLuint index, GLuint x, GLuint y, GLuint z )
{
    struct qemu_glVertexAttribI3uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3UIEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3uiEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3uiEXT *c = (struct qemu_glVertexAttribI3uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3uiEXT( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribI3uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3uiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3UIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3uiv *c = (struct qemu_glVertexAttribI3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3uiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI3uivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI3uivEXT( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI3uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI3UIVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI3uivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI3uivEXT *c = (struct qemu_glVertexAttribI3uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI3uivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4bv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4bv( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttribI4bv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4BV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4bv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4bv *c = (struct qemu_glVertexAttribI4bv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4bv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4bvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4bvEXT( GLuint index, const GLbyte *v )
{
    struct qemu_glVertexAttribI4bvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4BVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4bvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4bvEXT *c = (struct qemu_glVertexAttribI4bvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4bvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4i
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4i( GLuint index, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glVertexAttribI4i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4I);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4i(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4i *c = (struct qemu_glVertexAttribI4i *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4i( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribI4iEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4iEXT( GLuint index, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glVertexAttribI4iEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4IEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4iEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4iEXT *c = (struct qemu_glVertexAttribI4iEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4iEXT( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribI4iv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4iv( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI4iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4IV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4iv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4iv *c = (struct qemu_glVertexAttribI4iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4iv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4ivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4ivEXT( GLuint index, const GLint *v )
{
    struct qemu_glVertexAttribI4ivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4IVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4ivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4ivEXT *c = (struct qemu_glVertexAttribI4ivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4ivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4sv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4sv( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttribI4sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4SV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4sv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4sv *c = (struct qemu_glVertexAttribI4sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4sv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4svEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4svEXT( GLuint index, const GLshort *v )
{
    struct qemu_glVertexAttribI4svEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4SVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4svEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4svEXT *c = (struct qemu_glVertexAttribI4svEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4svEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4ubv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4ubv( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttribI4ubv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UBV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4ubv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4ubv *c = (struct qemu_glVertexAttribI4ubv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4ubv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4ubvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4ubvEXT( GLuint index, const GLubyte *v )
{
    struct qemu_glVertexAttribI4ubvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UBVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4ubvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4ubvEXT *c = (struct qemu_glVertexAttribI4ubvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4ubvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4ui( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
{
    struct qemu_glVertexAttribI4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UI);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4ui *c = (struct qemu_glVertexAttribI4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4ui( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribI4uiEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4uiEXT( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
{
    struct qemu_glVertexAttribI4uiEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UIEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4uiEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4uiEXT *c = (struct qemu_glVertexAttribI4uiEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4uiEXT( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribI4uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4uiv( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UIV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4uiv *c = (struct qemu_glVertexAttribI4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4uiv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4uivEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4uivEXT( GLuint index, const GLuint *v )
{
    struct qemu_glVertexAttribI4uivEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4UIVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4uivEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4uivEXT *c = (struct qemu_glVertexAttribI4uivEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4uivEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4usv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4usv( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttribI4usv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4USV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4usv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4usv *c = (struct qemu_glVertexAttribI4usv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4usv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribI4usvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribI4usvEXT( GLuint index, const GLushort *v )
{
    struct qemu_glVertexAttribI4usvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBI4USVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribI4usvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribI4usvEXT *c = (struct qemu_glVertexAttribI4usvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribI4usvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribIFormat
{
    struct qemu_syscall super;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribIFormat( GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexAttribIFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBIFORMAT);
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribIFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribIFormat *c = (struct qemu_glVertexAttribIFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribIFormat( c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexAttribIFormatNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribIFormatNV( GLuint index, GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glVertexAttribIFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBIFORMATNV);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribIFormatNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribIFormatNV *c = (struct qemu_glVertexAttribIFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribIFormatNV( c->index, c->size, c->type, c->stride ));
}

#endif

struct qemu_glVertexAttribIPointer
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribIPointer( GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribIPointer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBIPOINTER);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribIPointer(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribIPointer *c = (struct qemu_glVertexAttribIPointer *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribIPointer( c->index, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribIPointerEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribIPointerEXT( GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribIPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBIPOINTEREXT);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribIPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribIPointerEXT *c = (struct qemu_glVertexAttribIPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribIPointerEXT( c->index, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribL1d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1d( GLuint index, GLdouble x )
{
    struct qemu_glVertexAttribL1d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1D);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1d *c = (struct qemu_glVertexAttribL1d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1d( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribL1dEXT
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1dEXT( GLuint index, GLdouble x )
{
    struct qemu_glVertexAttribL1dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1DEXT);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1dEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1dEXT *c = (struct qemu_glVertexAttribL1dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1dEXT( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribL1dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL1dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1dv *c = (struct qemu_glVertexAttribL1dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL1dvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1dvEXT( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL1dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1DVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1dvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1dvEXT *c = (struct qemu_glVertexAttribL1dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1dvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL1i64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1i64NV( GLuint index, GLint64EXT x )
{
    struct qemu_glVertexAttribL1i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1I64NV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1i64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1i64NV *c = (struct qemu_glVertexAttribL1i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1i64NV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribL1i64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1i64vNV( GLuint index, const GLint64EXT *v )
{
    struct qemu_glVertexAttribL1i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1I64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1i64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1i64vNV *c = (struct qemu_glVertexAttribL1i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1i64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL1ui64ARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1ui64ARB( GLuint index, GLuint64EXT x )
{
    struct qemu_glVertexAttribL1ui64ARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1UI64ARB);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1ui64ARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1ui64ARB *c = (struct qemu_glVertexAttribL1ui64ARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1ui64ARB( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribL1ui64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1ui64NV( GLuint index, GLuint64EXT x )
{
    struct qemu_glVertexAttribL1ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1UI64NV);
    call.index = index;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1ui64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1ui64NV *c = (struct qemu_glVertexAttribL1ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1ui64NV( c->index, c->x ));
}

#endif

struct qemu_glVertexAttribL1ui64vARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1ui64vARB( GLuint index, const GLuint64EXT *v )
{
    struct qemu_glVertexAttribL1ui64vARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1UI64VARB);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1ui64vARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1ui64vARB *c = (struct qemu_glVertexAttribL1ui64vARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1ui64vARB( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL1ui64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL1ui64vNV( GLuint index, const GLuint64EXT *v )
{
    struct qemu_glVertexAttribL1ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL1UI64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL1ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL1ui64vNV *c = (struct qemu_glVertexAttribL1ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL1ui64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL2d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2d( GLuint index, GLdouble x, GLdouble y )
{
    struct qemu_glVertexAttribL2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2D);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2d *c = (struct qemu_glVertexAttribL2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2d( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribL2dEXT
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2dEXT( GLuint index, GLdouble x, GLdouble y )
{
    struct qemu_glVertexAttribL2dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2DEXT);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2dEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2dEXT *c = (struct qemu_glVertexAttribL2dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2dEXT( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribL2dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2dv *c = (struct qemu_glVertexAttribL2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL2dvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2dvEXT( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL2dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2DVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2dvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2dvEXT *c = (struct qemu_glVertexAttribL2dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2dvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL2i64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2i64NV( GLuint index, GLint64EXT x, GLint64EXT y )
{
    struct qemu_glVertexAttribL2i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2I64NV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2i64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2i64NV *c = (struct qemu_glVertexAttribL2i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2i64NV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribL2i64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2i64vNV( GLuint index, const GLint64EXT *v )
{
    struct qemu_glVertexAttribL2i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2I64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2i64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2i64vNV *c = (struct qemu_glVertexAttribL2i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2i64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL2ui64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2ui64NV( GLuint index, GLuint64EXT x, GLuint64EXT y )
{
    struct qemu_glVertexAttribL2ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2UI64NV);
    call.index = index;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2ui64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2ui64NV *c = (struct qemu_glVertexAttribL2ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2ui64NV( c->index, c->x, c->y ));
}

#endif

struct qemu_glVertexAttribL2ui64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL2ui64vNV( GLuint index, const GLuint64EXT *v )
{
    struct qemu_glVertexAttribL2ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL2UI64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL2ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL2ui64vNV *c = (struct qemu_glVertexAttribL2ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL2ui64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL3d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3d( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexAttribL3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3D);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3d *c = (struct qemu_glVertexAttribL3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3d( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribL3dEXT
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3dEXT( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexAttribL3dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3DEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3dEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3dEXT *c = (struct qemu_glVertexAttribL3dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3dEXT( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribL3dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3dv *c = (struct qemu_glVertexAttribL3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL3dvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3dvEXT( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL3dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3DVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3dvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3dvEXT *c = (struct qemu_glVertexAttribL3dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3dvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL3i64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3i64NV( GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z )
{
    struct qemu_glVertexAttribL3i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3I64NV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3i64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3i64NV *c = (struct qemu_glVertexAttribL3i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3i64NV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribL3i64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3i64vNV( GLuint index, const GLint64EXT *v )
{
    struct qemu_glVertexAttribL3i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3I64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3i64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3i64vNV *c = (struct qemu_glVertexAttribL3i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3i64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL3ui64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3ui64NV( GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z )
{
    struct qemu_glVertexAttribL3ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3UI64NV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3ui64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3ui64NV *c = (struct qemu_glVertexAttribL3ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3ui64NV( c->index, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexAttribL3ui64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL3ui64vNV( GLuint index, const GLuint64EXT *v )
{
    struct qemu_glVertexAttribL3ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL3UI64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL3ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL3ui64vNV *c = (struct qemu_glVertexAttribL3ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL3ui64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL4d
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4d( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexAttribL4d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4D);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4d(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4d *c = (struct qemu_glVertexAttribL4d *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4d( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribL4dEXT
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4dEXT( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexAttribL4dEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4DEXT);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4dEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4dEXT *c = (struct qemu_glVertexAttribL4dEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4dEXT( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribL4dv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4dv( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL4dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4DV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4dv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4dv *c = (struct qemu_glVertexAttribL4dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4dv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL4dvEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4dvEXT( GLuint index, const GLdouble *v )
{
    struct qemu_glVertexAttribL4dvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4DVEXT);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4dvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4dvEXT *c = (struct qemu_glVertexAttribL4dvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4dvEXT( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL4i64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4i64NV( GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w )
{
    struct qemu_glVertexAttribL4i64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4I64NV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4i64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4i64NV *c = (struct qemu_glVertexAttribL4i64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4i64NV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribL4i64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4i64vNV( GLuint index, const GLint64EXT *v )
{
    struct qemu_glVertexAttribL4i64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4I64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4i64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4i64vNV *c = (struct qemu_glVertexAttribL4i64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4i64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribL4ui64NV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4ui64NV( GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w )
{
    struct qemu_glVertexAttribL4ui64NV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4UI64NV);
    call.index = index;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4ui64NV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4ui64NV *c = (struct qemu_glVertexAttribL4ui64NV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4ui64NV( c->index, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexAttribL4ui64vNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribL4ui64vNV( GLuint index, const GLuint64EXT *v )
{
    struct qemu_glVertexAttribL4ui64vNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBL4UI64VNV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribL4ui64vNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribL4ui64vNV *c = (struct qemu_glVertexAttribL4ui64vNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribL4ui64vNV( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribLFormat
{
    struct qemu_syscall super;
    uint64_t attribindex;
    uint64_t size;
    uint64_t type;
    uint64_t relativeoffset;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribLFormat( GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset )
{
    struct qemu_glVertexAttribLFormat call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBLFORMAT);
    call.attribindex = attribindex;
    call.size = size;
    call.type = type;
    call.relativeoffset = relativeoffset;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribLFormat(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribLFormat *c = (struct qemu_glVertexAttribLFormat *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribLFormat( c->attribindex, c->size, c->type, c->relativeoffset ));
}

#endif

struct qemu_glVertexAttribLFormatNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribLFormatNV( GLuint index, GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glVertexAttribLFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBLFORMATNV);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribLFormatNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribLFormatNV *c = (struct qemu_glVertexAttribLFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribLFormatNV( c->index, c->size, c->type, c->stride ));
}

#endif

struct qemu_glVertexAttribLPointer
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribLPointer( GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribLPointer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBLPOINTER);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribLPointer(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribLPointer *c = (struct qemu_glVertexAttribLPointer *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribLPointer( c->index, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribLPointerEXT
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribLPointerEXT( GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribLPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBLPOINTEREXT);
    call.index = index;
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribLPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribLPointerEXT *c = (struct qemu_glVertexAttribLPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribLPointerEXT( c->index, c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribP1ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP1ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
{
    struct qemu_glVertexAttribP1ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP1UI);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP1ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP1ui *c = (struct qemu_glVertexAttribP1ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP1ui( c->index, c->type, c->normalized, c->value ));
}

#endif

struct qemu_glVertexAttribP1uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP1uiv( GLuint index, GLenum type, GLboolean normalized, const GLuint *value )
{
    struct qemu_glVertexAttribP1uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP1UIV);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP1uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP1uiv *c = (struct qemu_glVertexAttribP1uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP1uiv( c->index, c->type, c->normalized, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexAttribP2ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP2ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
{
    struct qemu_glVertexAttribP2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP2UI);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP2ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP2ui *c = (struct qemu_glVertexAttribP2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP2ui( c->index, c->type, c->normalized, c->value ));
}

#endif

struct qemu_glVertexAttribP2uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP2uiv( GLuint index, GLenum type, GLboolean normalized, const GLuint *value )
{
    struct qemu_glVertexAttribP2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP2UIV);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP2uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP2uiv *c = (struct qemu_glVertexAttribP2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP2uiv( c->index, c->type, c->normalized, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexAttribP3ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP3ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
{
    struct qemu_glVertexAttribP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP3UI);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP3ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP3ui *c = (struct qemu_glVertexAttribP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP3ui( c->index, c->type, c->normalized, c->value ));
}

#endif

struct qemu_glVertexAttribP3uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP3uiv( GLuint index, GLenum type, GLboolean normalized, const GLuint *value )
{
    struct qemu_glVertexAttribP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP3UIV);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP3uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP3uiv *c = (struct qemu_glVertexAttribP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP3uiv( c->index, c->type, c->normalized, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexAttribP4ui
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP4ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
{
    struct qemu_glVertexAttribP4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP4UI);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP4ui(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP4ui *c = (struct qemu_glVertexAttribP4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP4ui( c->index, c->type, c->normalized, c->value ));
}

#endif

struct qemu_glVertexAttribP4uiv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t type;
    uint64_t normalized;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribP4uiv( GLuint index, GLenum type, GLboolean normalized, const GLuint *value )
{
    struct qemu_glVertexAttribP4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBP4UIV);
    call.index = index;
    call.type = type;
    call.normalized = normalized;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribP4uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribP4uiv *c = (struct qemu_glVertexAttribP4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribP4uiv( c->index, c->type, c->normalized, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexAttribParameteriAMD
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribParameteriAMD( GLuint index, GLenum pname, GLint param )
{
    struct qemu_glVertexAttribParameteriAMD call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBPARAMETERIAMD);
    call.index = index;
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribParameteriAMD(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribParameteriAMD *c = (struct qemu_glVertexAttribParameteriAMD *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribParameteriAMD( c->index, c->pname, c->param ));
}

#endif

struct qemu_glVertexAttribPointer
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribPointer call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBPOINTER);
    call.index = index;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribPointer(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribPointer *c = (struct qemu_glVertexAttribPointer *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribPointer( c->index, c->size, c->type, c->normalized, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribPointerARB
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t size;
    uint64_t type;
    uint64_t normalized;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribPointerARB( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribPointerARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBPOINTERARB);
    call.index = index;
    call.size = size;
    call.type = type;
    call.normalized = normalized;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribPointerARB(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribPointerARB *c = (struct qemu_glVertexAttribPointerARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribPointerARB( c->index, c->size, c->type, c->normalized, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribPointerNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t fsize;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribPointerNV( GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexAttribPointerNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBPOINTERNV);
    call.index = index;
    call.fsize = fsize;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribPointerNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribPointerNV *c = (struct qemu_glVertexAttribPointerNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribPointerNV( c->index, c->fsize, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexAttribs1dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs1dvNV( GLuint index, GLsizei count, const GLdouble *v )
{
    struct qemu_glVertexAttribs1dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS1DVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs1dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs1dvNV *c = (struct qemu_glVertexAttribs1dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs1dvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs1fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs1fvNV( GLuint index, GLsizei count, const GLfloat *v )
{
    struct qemu_glVertexAttribs1fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS1FVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs1fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs1fvNV *c = (struct qemu_glVertexAttribs1fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs1fvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs1hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs1hvNV( GLuint index, GLsizei n, const GLhalfNV *v )
{
    struct qemu_glVertexAttribs1hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS1HVNV);
    call.index = index;
    call.n = n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs1hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs1hvNV *c = (struct qemu_glVertexAttribs1hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs1hvNV( c->index, c->n, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs1svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs1svNV( GLuint index, GLsizei count, const GLshort *v )
{
    struct qemu_glVertexAttribs1svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS1SVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs1svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs1svNV *c = (struct qemu_glVertexAttribs1svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs1svNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs2dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs2dvNV( GLuint index, GLsizei count, const GLdouble *v )
{
    struct qemu_glVertexAttribs2dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS2DVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs2dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs2dvNV *c = (struct qemu_glVertexAttribs2dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs2dvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs2fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs2fvNV( GLuint index, GLsizei count, const GLfloat *v )
{
    struct qemu_glVertexAttribs2fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS2FVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs2fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs2fvNV *c = (struct qemu_glVertexAttribs2fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs2fvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs2hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs2hvNV( GLuint index, GLsizei n, const GLhalfNV *v )
{
    struct qemu_glVertexAttribs2hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS2HVNV);
    call.index = index;
    call.n = n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs2hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs2hvNV *c = (struct qemu_glVertexAttribs2hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs2hvNV( c->index, c->n, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs2svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs2svNV( GLuint index, GLsizei count, const GLshort *v )
{
    struct qemu_glVertexAttribs2svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS2SVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs2svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs2svNV *c = (struct qemu_glVertexAttribs2svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs2svNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs3dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs3dvNV( GLuint index, GLsizei count, const GLdouble *v )
{
    struct qemu_glVertexAttribs3dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS3DVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs3dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs3dvNV *c = (struct qemu_glVertexAttribs3dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs3dvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs3fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs3fvNV( GLuint index, GLsizei count, const GLfloat *v )
{
    struct qemu_glVertexAttribs3fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS3FVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs3fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs3fvNV *c = (struct qemu_glVertexAttribs3fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs3fvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs3hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs3hvNV( GLuint index, GLsizei n, const GLhalfNV *v )
{
    struct qemu_glVertexAttribs3hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS3HVNV);
    call.index = index;
    call.n = n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs3hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs3hvNV *c = (struct qemu_glVertexAttribs3hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs3hvNV( c->index, c->n, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs3svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs3svNV( GLuint index, GLsizei count, const GLshort *v )
{
    struct qemu_glVertexAttribs3svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS3SVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs3svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs3svNV *c = (struct qemu_glVertexAttribs3svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs3svNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs4dvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs4dvNV( GLuint index, GLsizei count, const GLdouble *v )
{
    struct qemu_glVertexAttribs4dvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS4DVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs4dvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs4dvNV *c = (struct qemu_glVertexAttribs4dvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs4dvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs4fvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs4fvNV( GLuint index, GLsizei count, const GLfloat *v )
{
    struct qemu_glVertexAttribs4fvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS4FVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs4fvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs4fvNV *c = (struct qemu_glVertexAttribs4fvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs4fvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs4hvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t n;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs4hvNV( GLuint index, GLsizei n, const GLhalfNV *v )
{
    struct qemu_glVertexAttribs4hvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS4HVNV);
    call.index = index;
    call.n = n;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs4hvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs4hvNV *c = (struct qemu_glVertexAttribs4hvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs4hvNV( c->index, c->n, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs4svNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs4svNV( GLuint index, GLsizei count, const GLshort *v )
{
    struct qemu_glVertexAttribs4svNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS4SVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs4svNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs4svNV *c = (struct qemu_glVertexAttribs4svNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs4svNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexAttribs4ubvNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexAttribs4ubvNV( GLuint index, GLsizei count, const GLubyte *v )
{
    struct qemu_glVertexAttribs4ubvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXATTRIBS4UBVNV);
    call.index = index;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexAttribs4ubvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexAttribs4ubvNV *c = (struct qemu_glVertexAttribs4ubvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexAttribs4ubvNV( c->index, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glVertexBindingDivisor
{
    struct qemu_syscall super;
    uint64_t bindingindex;
    uint64_t divisor;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexBindingDivisor( GLuint bindingindex, GLuint divisor )
{
    struct qemu_glVertexBindingDivisor call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXBINDINGDIVISOR);
    call.bindingindex = bindingindex;
    call.divisor = divisor;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexBindingDivisor(struct qemu_syscall *call)
{
    struct qemu_glVertexBindingDivisor *c = (struct qemu_glVertexBindingDivisor *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexBindingDivisor( c->bindingindex, c->divisor ));
}

#endif

struct qemu_glVertexBlendARB
{
    struct qemu_syscall super;
    uint64_t count;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexBlendARB( GLint count )
{
    struct qemu_glVertexBlendARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXBLENDARB);
    call.count = count;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexBlendARB(struct qemu_syscall *call)
{
    struct qemu_glVertexBlendARB *c = (struct qemu_glVertexBlendARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexBlendARB( c->count ));
}

#endif

struct qemu_glVertexBlendEnvfATI
{
    struct qemu_syscall super;
    uint64_t pname;
    double param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexBlendEnvfATI( GLenum pname, GLfloat param )
{
    struct qemu_glVertexBlendEnvfATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXBLENDENVFATI);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexBlendEnvfATI(struct qemu_syscall *call)
{
    struct qemu_glVertexBlendEnvfATI *c = (struct qemu_glVertexBlendEnvfATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexBlendEnvfATI( c->pname, c->param ));
}

#endif

struct qemu_glVertexBlendEnviATI
{
    struct qemu_syscall super;
    uint64_t pname;
    uint64_t param;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexBlendEnviATI( GLenum pname, GLint param )
{
    struct qemu_glVertexBlendEnviATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXBLENDENVIATI);
    call.pname = pname;
    call.param = param;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexBlendEnviATI(struct qemu_syscall *call)
{
    struct qemu_glVertexBlendEnviATI *c = (struct qemu_glVertexBlendEnviATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexBlendEnviATI( c->pname, c->param ));
}

#endif

struct qemu_glVertexFormatNV
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexFormatNV( GLint size, GLenum type, GLsizei stride )
{
    struct qemu_glVertexFormatNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXFORMATNV);
    call.size = size;
    call.type = type;
    call.stride = stride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexFormatNV(struct qemu_syscall *call)
{
    struct qemu_glVertexFormatNV *c = (struct qemu_glVertexFormatNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexFormatNV( c->size, c->type, c->stride ));
}

#endif

struct qemu_glVertexP2ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP2ui( GLenum type, GLuint value )
{
    struct qemu_glVertexP2ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP2UI);
    call.type = type;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP2ui(struct qemu_syscall *call)
{
    struct qemu_glVertexP2ui *c = (struct qemu_glVertexP2ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP2ui( c->type, c->value ));
}

#endif

struct qemu_glVertexP2uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP2uiv( GLenum type, const GLuint *value )
{
    struct qemu_glVertexP2uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP2UIV);
    call.type = type;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP2uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexP2uiv *c = (struct qemu_glVertexP2uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP2uiv( c->type, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexP3ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP3ui( GLenum type, GLuint value )
{
    struct qemu_glVertexP3ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP3UI);
    call.type = type;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP3ui(struct qemu_syscall *call)
{
    struct qemu_glVertexP3ui *c = (struct qemu_glVertexP3ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP3ui( c->type, c->value ));
}

#endif

struct qemu_glVertexP3uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP3uiv( GLenum type, const GLuint *value )
{
    struct qemu_glVertexP3uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP3UIV);
    call.type = type;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP3uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexP3uiv *c = (struct qemu_glVertexP3uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP3uiv( c->type, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexP4ui
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP4ui( GLenum type, GLuint value )
{
    struct qemu_glVertexP4ui call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP4UI);
    call.type = type;
    call.value = value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP4ui(struct qemu_syscall *call)
{
    struct qemu_glVertexP4ui *c = (struct qemu_glVertexP4ui *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP4ui( c->type, c->value ));
}

#endif

struct qemu_glVertexP4uiv
{
    struct qemu_syscall super;
    uint64_t type;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexP4uiv( GLenum type, const GLuint *value )
{
    struct qemu_glVertexP4uiv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXP4UIV);
    call.type = type;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexP4uiv(struct qemu_syscall *call)
{
    struct qemu_glVertexP4uiv *c = (struct qemu_glVertexP4uiv *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexP4uiv( c->type, QEMU_G2H(c->value) ));
}

#endif

struct qemu_glVertexPointerEXT
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t count;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexPointerEXT( GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer )
{
    struct qemu_glVertexPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXPOINTEREXT);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.count = count;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexPointerEXT *c = (struct qemu_glVertexPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexPointerEXT( c->size, c->type, c->stride, c->count, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexPointerListIBM
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
    uint64_t ptrstride;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexPointerListIBM( GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride )
{
    struct qemu_glVertexPointerListIBM call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXPOINTERLISTIBM);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;
    call.ptrstride = ptrstride;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexPointerListIBM(struct qemu_syscall *call)
{
    struct qemu_glVertexPointerListIBM *c = (struct qemu_glVertexPointerListIBM *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexPointerListIBM( c->size, c->type, c->stride, QEMU_G2H(c->pointer), c->ptrstride ));
}

#endif

struct qemu_glVertexPointervINTEL
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexPointervINTEL( GLint size, GLenum type, const void **pointer )
{
    struct qemu_glVertexPointervINTEL call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXPOINTERVINTEL);
    call.size = size;
    call.type = type;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexPointervINTEL(struct qemu_syscall *call)
{
    struct qemu_glVertexPointervINTEL *c = (struct qemu_glVertexPointervINTEL *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexPointervINTEL( c->size, c->type, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexStream1dATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1dATI( GLenum stream, GLdouble x )
{
    struct qemu_glVertexStream1dATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1DATI);
    call.stream = stream;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1dATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1dATI *c = (struct qemu_glVertexStream1dATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1dATI( c->stream, c->x ));
}

#endif

struct qemu_glVertexStream1dvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1dvATI( GLenum stream, const GLdouble *coords )
{
    struct qemu_glVertexStream1dvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1DVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1dvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1dvATI *c = (struct qemu_glVertexStream1dvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1dvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream1fATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1fATI( GLenum stream, GLfloat x )
{
    struct qemu_glVertexStream1fATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1FATI);
    call.stream = stream;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1fATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1fATI *c = (struct qemu_glVertexStream1fATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1fATI( c->stream, c->x ));
}

#endif

struct qemu_glVertexStream1fvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1fvATI( GLenum stream, const GLfloat *coords )
{
    struct qemu_glVertexStream1fvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1FVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1fvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1fvATI *c = (struct qemu_glVertexStream1fvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1fvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream1iATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1iATI( GLenum stream, GLint x )
{
    struct qemu_glVertexStream1iATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1IATI);
    call.stream = stream;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1iATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1iATI *c = (struct qemu_glVertexStream1iATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1iATI( c->stream, c->x ));
}

#endif

struct qemu_glVertexStream1ivATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1ivATI( GLenum stream, const GLint *coords )
{
    struct qemu_glVertexStream1ivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1IVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1ivATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1ivATI *c = (struct qemu_glVertexStream1ivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1ivATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream1sATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1sATI( GLenum stream, GLshort x )
{
    struct qemu_glVertexStream1sATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1SATI);
    call.stream = stream;
    call.x = x;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1sATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1sATI *c = (struct qemu_glVertexStream1sATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1sATI( c->stream, c->x ));
}

#endif

struct qemu_glVertexStream1svATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream1svATI( GLenum stream, const GLshort *coords )
{
    struct qemu_glVertexStream1svATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM1SVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream1svATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream1svATI *c = (struct qemu_glVertexStream1svATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream1svATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream2dATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2dATI( GLenum stream, GLdouble x, GLdouble y )
{
    struct qemu_glVertexStream2dATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2DATI);
    call.stream = stream;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2dATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2dATI *c = (struct qemu_glVertexStream2dATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2dATI( c->stream, c->x, c->y ));
}

#endif

struct qemu_glVertexStream2dvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2dvATI( GLenum stream, const GLdouble *coords )
{
    struct qemu_glVertexStream2dvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2DVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2dvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2dvATI *c = (struct qemu_glVertexStream2dvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2dvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream2fATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2fATI( GLenum stream, GLfloat x, GLfloat y )
{
    struct qemu_glVertexStream2fATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2FATI);
    call.stream = stream;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2fATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2fATI *c = (struct qemu_glVertexStream2fATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2fATI( c->stream, c->x, c->y ));
}

#endif

struct qemu_glVertexStream2fvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2fvATI( GLenum stream, const GLfloat *coords )
{
    struct qemu_glVertexStream2fvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2FVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2fvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2fvATI *c = (struct qemu_glVertexStream2fvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2fvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream2iATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2iATI( GLenum stream, GLint x, GLint y )
{
    struct qemu_glVertexStream2iATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2IATI);
    call.stream = stream;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2iATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2iATI *c = (struct qemu_glVertexStream2iATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2iATI( c->stream, c->x, c->y ));
}

#endif

struct qemu_glVertexStream2ivATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2ivATI( GLenum stream, const GLint *coords )
{
    struct qemu_glVertexStream2ivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2IVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2ivATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2ivATI *c = (struct qemu_glVertexStream2ivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2ivATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream2sATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2sATI( GLenum stream, GLshort x, GLshort y )
{
    struct qemu_glVertexStream2sATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2SATI);
    call.stream = stream;
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2sATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2sATI *c = (struct qemu_glVertexStream2sATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2sATI( c->stream, c->x, c->y ));
}

#endif

struct qemu_glVertexStream2svATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream2svATI( GLenum stream, const GLshort *coords )
{
    struct qemu_glVertexStream2svATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM2SVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream2svATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream2svATI *c = (struct qemu_glVertexStream2svATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream2svATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream3dATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3dATI( GLenum stream, GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glVertexStream3dATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3DATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3dATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3dATI *c = (struct qemu_glVertexStream3dATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3dATI( c->stream, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexStream3dvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3dvATI( GLenum stream, const GLdouble *coords )
{
    struct qemu_glVertexStream3dvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3DVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3dvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3dvATI *c = (struct qemu_glVertexStream3dvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3dvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream3fATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3fATI( GLenum stream, GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glVertexStream3fATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3FATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3fATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3fATI *c = (struct qemu_glVertexStream3fATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3fATI( c->stream, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexStream3fvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3fvATI( GLenum stream, const GLfloat *coords )
{
    struct qemu_glVertexStream3fvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3FVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3fvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3fvATI *c = (struct qemu_glVertexStream3fvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3fvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream3iATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3iATI( GLenum stream, GLint x, GLint y, GLint z )
{
    struct qemu_glVertexStream3iATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3IATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3iATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3iATI *c = (struct qemu_glVertexStream3iATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3iATI( c->stream, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexStream3ivATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3ivATI( GLenum stream, const GLint *coords )
{
    struct qemu_glVertexStream3ivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3IVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3ivATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3ivATI *c = (struct qemu_glVertexStream3ivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3ivATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream3sATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3sATI( GLenum stream, GLshort x, GLshort y, GLshort z )
{
    struct qemu_glVertexStream3sATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3SATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3sATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3sATI *c = (struct qemu_glVertexStream3sATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3sATI( c->stream, c->x, c->y, c->z ));
}

#endif

struct qemu_glVertexStream3svATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream3svATI( GLenum stream, const GLshort *coords )
{
    struct qemu_glVertexStream3svATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM3SVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream3svATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream3svATI *c = (struct qemu_glVertexStream3svATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream3svATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream4dATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4dATI( GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glVertexStream4dATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4DATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4dATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4dATI *c = (struct qemu_glVertexStream4dATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4dATI( c->stream, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexStream4dvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4dvATI( GLenum stream, const GLdouble *coords )
{
    struct qemu_glVertexStream4dvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4DVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4dvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4dvATI *c = (struct qemu_glVertexStream4dvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4dvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream4fATI
{
    struct qemu_syscall super;
    uint64_t stream;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4fATI( GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glVertexStream4fATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4FATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4fATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4fATI *c = (struct qemu_glVertexStream4fATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4fATI( c->stream, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexStream4fvATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4fvATI( GLenum stream, const GLfloat *coords )
{
    struct qemu_glVertexStream4fvATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4FVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4fvATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4fvATI *c = (struct qemu_glVertexStream4fvATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4fvATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream4iATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4iATI( GLenum stream, GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glVertexStream4iATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4IATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4iATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4iATI *c = (struct qemu_glVertexStream4iATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4iATI( c->stream, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexStream4ivATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4ivATI( GLenum stream, const GLint *coords )
{
    struct qemu_glVertexStream4ivATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4IVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4ivATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4ivATI *c = (struct qemu_glVertexStream4ivATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4ivATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexStream4sATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4sATI( GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w )
{
    struct qemu_glVertexStream4sATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4SATI);
    call.stream = stream;
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4sATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4sATI *c = (struct qemu_glVertexStream4sATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4sATI( c->stream, c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glVertexStream4svATI
{
    struct qemu_syscall super;
    uint64_t stream;
    uint64_t coords;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexStream4svATI( GLenum stream, const GLshort *coords )
{
    struct qemu_glVertexStream4svATI call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXSTREAM4SVATI);
    call.stream = stream;
    call.coords = (ULONG_PTR)coords;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexStream4svATI(struct qemu_syscall *call)
{
    struct qemu_glVertexStream4svATI *c = (struct qemu_glVertexStream4svATI *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexStream4svATI( c->stream, QEMU_G2H(c->coords) ));
}

#endif

struct qemu_glVertexWeightPointerEXT
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexWeightPointerEXT( GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glVertexWeightPointerEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXWEIGHTPOINTEREXT);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexWeightPointerEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexWeightPointerEXT *c = (struct qemu_glVertexWeightPointerEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexWeightPointerEXT( c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glVertexWeightfEXT
{
    struct qemu_syscall super;
    double weight;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexWeightfEXT( GLfloat weight )
{
    struct qemu_glVertexWeightfEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXWEIGHTFEXT);
    call.weight = weight;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexWeightfEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexWeightfEXT *c = (struct qemu_glVertexWeightfEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexWeightfEXT( c->weight ));
}

#endif

struct qemu_glVertexWeightfvEXT
{
    struct qemu_syscall super;
    uint64_t weight;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexWeightfvEXT( const GLfloat *weight )
{
    struct qemu_glVertexWeightfvEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXWEIGHTFVEXT);
    call.weight = (ULONG_PTR)weight;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexWeightfvEXT(struct qemu_syscall *call)
{
    struct qemu_glVertexWeightfvEXT *c = (struct qemu_glVertexWeightfvEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexWeightfvEXT( QEMU_G2H(c->weight) ));
}

#endif

struct qemu_glVertexWeighthNV
{
    struct qemu_syscall super;
    uint64_t weight;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexWeighthNV( GLhalfNV weight )
{
    struct qemu_glVertexWeighthNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXWEIGHTHNV);
    call.weight = weight;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexWeighthNV(struct qemu_syscall *call)
{
    struct qemu_glVertexWeighthNV *c = (struct qemu_glVertexWeighthNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexWeighthNV( c->weight ));
}

#endif

struct qemu_glVertexWeighthvNV
{
    struct qemu_syscall super;
    uint64_t weight;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVertexWeighthvNV( const GLhalfNV *weight )
{
    struct qemu_glVertexWeighthvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVERTEXWEIGHTHVNV);
    call.weight = (ULONG_PTR)weight;

    qemu_syscall(&call.super);
}

#else

void qemu_glVertexWeighthvNV(struct qemu_syscall *call)
{
    struct qemu_glVertexWeighthvNV *c = (struct qemu_glVertexWeighthvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVertexWeighthvNV( QEMU_G2H(c->weight) ));
}

#endif

struct qemu_glVideoCaptureNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t sequence_num;
    uint64_t capture_time;
};

#ifdef QEMU_DLL_GUEST

GLenum WINAPI glVideoCaptureNV( GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time )
{
    struct qemu_glVideoCaptureNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIDEOCAPTURENV);
    call.video_capture_slot = video_capture_slot;
    call.sequence_num = (ULONG_PTR)sequence_num;
    call.capture_time = (ULONG_PTR)capture_time;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_glVideoCaptureNV(struct qemu_syscall *call)
{
    struct qemu_glVideoCaptureNV *c = (struct qemu_glVideoCaptureNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_glVideoCaptureNV( c->video_capture_slot, QEMU_G2H(c->sequence_num), QEMU_G2H(c->capture_time) ));
}

#endif

struct qemu_glVideoCaptureStreamParameterdvNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVideoCaptureStreamParameterdvNV( GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params )
{
    struct qemu_glVideoCaptureStreamParameterdvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIDEOCAPTURESTREAMPARAMETERDVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glVideoCaptureStreamParameterdvNV(struct qemu_syscall *call)
{
    struct qemu_glVideoCaptureStreamParameterdvNV *c = (struct qemu_glVideoCaptureStreamParameterdvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVideoCaptureStreamParameterdvNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glVideoCaptureStreamParameterfvNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVideoCaptureStreamParameterfvNV( GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params )
{
    struct qemu_glVideoCaptureStreamParameterfvNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIDEOCAPTURESTREAMPARAMETERFVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glVideoCaptureStreamParameterfvNV(struct qemu_syscall *call)
{
    struct qemu_glVideoCaptureStreamParameterfvNV *c = (struct qemu_glVideoCaptureStreamParameterfvNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVideoCaptureStreamParameterfvNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glVideoCaptureStreamParameterivNV
{
    struct qemu_syscall super;
    uint64_t video_capture_slot;
    uint64_t stream;
    uint64_t pname;
    uint64_t params;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glVideoCaptureStreamParameterivNV( GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params )
{
    struct qemu_glVideoCaptureStreamParameterivNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIDEOCAPTURESTREAMPARAMETERIVNV);
    call.video_capture_slot = video_capture_slot;
    call.stream = stream;
    call.pname = pname;
    call.params = (ULONG_PTR)params;

    qemu_syscall(&call.super);
}

#else

void qemu_glVideoCaptureStreamParameterivNV(struct qemu_syscall *call)
{
    struct qemu_glVideoCaptureStreamParameterivNV *c = (struct qemu_glVideoCaptureStreamParameterivNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glVideoCaptureStreamParameterivNV( c->video_capture_slot, c->stream, c->pname, QEMU_G2H(c->params) ));
}

#endif

struct qemu_glViewportArrayv
{
    struct qemu_syscall super;
    uint64_t first;
    uint64_t count;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glViewportArrayv( GLuint first, GLsizei count, const GLfloat *v )
{
    struct qemu_glViewportArrayv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIEWPORTARRAYV);
    call.first = first;
    call.count = count;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glViewportArrayv(struct qemu_syscall *call)
{
    struct qemu_glViewportArrayv *c = (struct qemu_glViewportArrayv *)call;
    WINE_FIXME("Unverified\n");
    (p_glViewportArrayv( c->first, c->count, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glViewportIndexedf
{
    struct qemu_syscall super;
    uint64_t index;
    double x;
    double y;
    double w;
    double h;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glViewportIndexedf( GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h )
{
    struct qemu_glViewportIndexedf call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIEWPORTINDEXEDF);
    call.index = index;
    call.x = x;
    call.y = y;
    call.w = w;
    call.h = h;

    qemu_syscall(&call.super);
}

#else

void qemu_glViewportIndexedf(struct qemu_syscall *call)
{
    struct qemu_glViewportIndexedf *c = (struct qemu_glViewportIndexedf *)call;
    WINE_FIXME("Unverified\n");
    (p_glViewportIndexedf( c->index, c->x, c->y, c->w, c->h ));
}

#endif

struct qemu_glViewportIndexedfv
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glViewportIndexedfv( GLuint index, const GLfloat *v )
{
    struct qemu_glViewportIndexedfv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIEWPORTINDEXEDFV);
    call.index = index;
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glViewportIndexedfv(struct qemu_syscall *call)
{
    struct qemu_glViewportIndexedfv *c = (struct qemu_glViewportIndexedfv *)call;
    WINE_FIXME("Unverified\n");
    (p_glViewportIndexedfv( c->index, QEMU_G2H(c->v) ));
}

#endif

struct qemu_glViewportPositionWScaleNV
{
    struct qemu_syscall super;
    uint64_t index;
    double xcoeff;
    double ycoeff;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glViewportPositionWScaleNV( GLuint index, GLfloat xcoeff, GLfloat ycoeff )
{
    struct qemu_glViewportPositionWScaleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIEWPORTPOSITIONWSCALENV);
    call.index = index;
    call.xcoeff = xcoeff;
    call.ycoeff = ycoeff;

    qemu_syscall(&call.super);
}

#else

void qemu_glViewportPositionWScaleNV(struct qemu_syscall *call)
{
    struct qemu_glViewportPositionWScaleNV *c = (struct qemu_glViewportPositionWScaleNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glViewportPositionWScaleNV( c->index, c->xcoeff, c->ycoeff ));
}

#endif

struct qemu_glViewportSwizzleNV
{
    struct qemu_syscall super;
    uint64_t index;
    uint64_t swizzlex;
    uint64_t swizzley;
    uint64_t swizzlez;
    uint64_t swizzlew;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glViewportSwizzleNV( GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew )
{
    struct qemu_glViewportSwizzleNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLVIEWPORTSWIZZLENV);
    call.index = index;
    call.swizzlex = swizzlex;
    call.swizzley = swizzley;
    call.swizzlez = swizzlez;
    call.swizzlew = swizzlew;

    qemu_syscall(&call.super);
}

#else

void qemu_glViewportSwizzleNV(struct qemu_syscall *call)
{
    struct qemu_glViewportSwizzleNV *c = (struct qemu_glViewportSwizzleNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glViewportSwizzleNV( c->index, c->swizzlex, c->swizzley, c->swizzlez, c->swizzlew ));
}

#endif

struct qemu_glWaitSemaphoreEXT
{
    struct qemu_syscall super;
    uint64_t semaphore;
    uint64_t numBufferBarriers;
    uint64_t buffers;
    uint64_t numTextureBarriers;
    uint64_t textures;
    uint64_t srcLayouts;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWaitSemaphoreEXT( GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts )
{
    struct qemu_glWaitSemaphoreEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWAITSEMAPHOREEXT);
    call.semaphore = semaphore;
    call.numBufferBarriers = numBufferBarriers;
    call.buffers = (ULONG_PTR)buffers;
    call.numTextureBarriers = numTextureBarriers;
    call.textures = (ULONG_PTR)textures;
    call.srcLayouts = (ULONG_PTR)srcLayouts;

    qemu_syscall(&call.super);
}

#else

void qemu_glWaitSemaphoreEXT(struct qemu_syscall *call)
{
    struct qemu_glWaitSemaphoreEXT *c = (struct qemu_glWaitSemaphoreEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glWaitSemaphoreEXT( c->semaphore, c->numBufferBarriers, QEMU_G2H(c->buffers), c->numTextureBarriers, QEMU_G2H(c->textures), QEMU_G2H(c->srcLayouts) ));
}

#endif

struct qemu_glWaitSemaphoreui64NVX
{
    struct qemu_syscall super;
    uint64_t waitGpu;
    uint64_t fenceObjectCount;
    uint64_t semaphoreArray;
    uint64_t fenceValueArray;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWaitSemaphoreui64NVX( GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray )
{
    struct qemu_glWaitSemaphoreui64NVX call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWAITSEMAPHOREUI64NVX);
    call.waitGpu = waitGpu;
    call.fenceObjectCount = fenceObjectCount;
    call.semaphoreArray = (ULONG_PTR)semaphoreArray;
    call.fenceValueArray = (ULONG_PTR)fenceValueArray;

    qemu_syscall(&call.super);
}

#else

void qemu_glWaitSemaphoreui64NVX(struct qemu_syscall *call)
{
    struct qemu_glWaitSemaphoreui64NVX *c = (struct qemu_glWaitSemaphoreui64NVX *)call;
    WINE_FIXME("Unverified\n");
    (p_glWaitSemaphoreui64NVX( c->waitGpu, c->fenceObjectCount, QEMU_G2H(c->semaphoreArray), QEMU_G2H(c->fenceValueArray) ));
}

#endif

struct qemu_glWaitSync
{
    struct qemu_syscall super;
    uint64_t sync;
    uint64_t flags;
    uint64_t timeout;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWaitSync( GLsync sync, GLbitfield flags, GLuint64 timeout )
{
    struct qemu_glWaitSync call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWAITSYNC);
    call.sync = (ULONG_PTR)sync;
    call.flags = flags;
    call.timeout = timeout;

    qemu_syscall(&call.super);
}

#else

void qemu_glWaitSync(struct qemu_syscall *call)
{
    struct qemu_glWaitSync *c = (struct qemu_glWaitSync *)call;
    WINE_FIXME("Unverified\n");
    (p_glWaitSync( QEMU_G2H(c->sync), c->flags, c->timeout ));
}

#endif

struct qemu_glWaitVkSemaphoreNV
{
    struct qemu_syscall super;
    uint64_t vkSemaphore;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWaitVkSemaphoreNV( GLuint64 vkSemaphore )
{
    struct qemu_glWaitVkSemaphoreNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWAITVKSEMAPHORENV);
    call.vkSemaphore = vkSemaphore;

    qemu_syscall(&call.super);
}

#else

void qemu_glWaitVkSemaphoreNV(struct qemu_syscall *call)
{
    struct qemu_glWaitVkSemaphoreNV *c = (struct qemu_glWaitVkSemaphoreNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glWaitVkSemaphoreNV( c->vkSemaphore ));
}

#endif

struct qemu_glWeightPathsNV
{
    struct qemu_syscall super;
    uint64_t resultPath;
    uint64_t numPaths;
    uint64_t paths;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightPathsNV( GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights )
{
    struct qemu_glWeightPathsNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTPATHSNV);
    call.resultPath = resultPath;
    call.numPaths = numPaths;
    call.paths = (ULONG_PTR)paths;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightPathsNV(struct qemu_syscall *call)
{
    struct qemu_glWeightPathsNV *c = (struct qemu_glWeightPathsNV *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightPathsNV( c->resultPath, c->numPaths, QEMU_G2H(c->paths), QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightPointerARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t type;
    uint64_t stride;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightPointerARB( GLint size, GLenum type, GLsizei stride, const void *pointer )
{
    struct qemu_glWeightPointerARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTPOINTERARB);
    call.size = size;
    call.type = type;
    call.stride = stride;
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightPointerARB(struct qemu_syscall *call)
{
    struct qemu_glWeightPointerARB *c = (struct qemu_glWeightPointerARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightPointerARB( c->size, c->type, c->stride, QEMU_G2H(c->pointer) ));
}

#endif

struct qemu_glWeightbvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightbvARB( GLint size, const GLbyte *weights )
{
    struct qemu_glWeightbvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTBVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightbvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightbvARB *c = (struct qemu_glWeightbvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightbvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightdvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightdvARB( GLint size, const GLdouble *weights )
{
    struct qemu_glWeightdvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTDVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightdvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightdvARB *c = (struct qemu_glWeightdvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightdvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightfvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightfvARB( GLint size, const GLfloat *weights )
{
    struct qemu_glWeightfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTFVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightfvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightfvARB *c = (struct qemu_glWeightfvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightfvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightivARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightivARB( GLint size, const GLint *weights )
{
    struct qemu_glWeightivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTIVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightivARB(struct qemu_syscall *call)
{
    struct qemu_glWeightivARB *c = (struct qemu_glWeightivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightivARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightsvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightsvARB( GLint size, const GLshort *weights )
{
    struct qemu_glWeightsvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTSVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightsvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightsvARB *c = (struct qemu_glWeightsvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightsvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightubvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightubvARB( GLint size, const GLubyte *weights )
{
    struct qemu_glWeightubvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTUBVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightubvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightubvARB *c = (struct qemu_glWeightubvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightubvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightuivARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightuivARB( GLint size, const GLuint *weights )
{
    struct qemu_glWeightuivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTUIVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightuivARB(struct qemu_syscall *call)
{
    struct qemu_glWeightuivARB *c = (struct qemu_glWeightuivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightuivARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWeightusvARB
{
    struct qemu_syscall super;
    uint64_t size;
    uint64_t weights;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWeightusvARB( GLint size, const GLushort *weights )
{
    struct qemu_glWeightusvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWEIGHTUSVARB);
    call.size = size;
    call.weights = (ULONG_PTR)weights;

    qemu_syscall(&call.super);
}

#else

void qemu_glWeightusvARB(struct qemu_syscall *call)
{
    struct qemu_glWeightusvARB *c = (struct qemu_glWeightusvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWeightusvARB( c->size, QEMU_G2H(c->weights) ));
}

#endif

struct qemu_glWindowPos2d
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2d( GLdouble x, GLdouble y )
{
    struct qemu_glWindowPos2d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2D);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2d(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2d *c = (struct qemu_glWindowPos2d *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2d( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2dARB
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2dARB( GLdouble x, GLdouble y )
{
    struct qemu_glWindowPos2dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2DARB);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2dARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2dARB *c = (struct qemu_glWindowPos2dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2dARB( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2dMESA
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2dMESA( GLdouble x, GLdouble y )
{
    struct qemu_glWindowPos2dMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2DMESA);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2dMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2dMESA *c = (struct qemu_glWindowPos2dMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2dMESA( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2dv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2dv( const GLdouble *v )
{
    struct qemu_glWindowPos2dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2DV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2dv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2dv *c = (struct qemu_glWindowPos2dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2dv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2dvARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2dvARB( const GLdouble *v )
{
    struct qemu_glWindowPos2dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2DVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2dvARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2dvARB *c = (struct qemu_glWindowPos2dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2dvARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2dvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2dvMESA( const GLdouble *v )
{
    struct qemu_glWindowPos2dvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2DVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2dvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2dvMESA *c = (struct qemu_glWindowPos2dvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2dvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2f
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2f( GLfloat x, GLfloat y )
{
    struct qemu_glWindowPos2f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2F);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2f(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2f *c = (struct qemu_glWindowPos2f *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2f( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2fARB
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2fARB( GLfloat x, GLfloat y )
{
    struct qemu_glWindowPos2fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2FARB);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2fARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2fARB *c = (struct qemu_glWindowPos2fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2fARB( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2fMESA
{
    struct qemu_syscall super;
    double x;
    double y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2fMESA( GLfloat x, GLfloat y )
{
    struct qemu_glWindowPos2fMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2FMESA);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2fMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2fMESA *c = (struct qemu_glWindowPos2fMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2fMESA( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2fv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2fv( const GLfloat *v )
{
    struct qemu_glWindowPos2fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2FV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2fv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2fv *c = (struct qemu_glWindowPos2fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2fv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2fvARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2fvARB( const GLfloat *v )
{
    struct qemu_glWindowPos2fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2FVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2fvARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2fvARB *c = (struct qemu_glWindowPos2fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2fvARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2fvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2fvMESA( const GLfloat *v )
{
    struct qemu_glWindowPos2fvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2FVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2fvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2fvMESA *c = (struct qemu_glWindowPos2fvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2fvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2i
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2i( GLint x, GLint y )
{
    struct qemu_glWindowPos2i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2I);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2i(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2i *c = (struct qemu_glWindowPos2i *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2i( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2iARB
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2iARB( GLint x, GLint y )
{
    struct qemu_glWindowPos2iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2IARB);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2iARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2iARB *c = (struct qemu_glWindowPos2iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2iARB( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2iMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2iMESA( GLint x, GLint y )
{
    struct qemu_glWindowPos2iMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2IMESA);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2iMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2iMESA *c = (struct qemu_glWindowPos2iMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2iMESA( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2iv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2iv( const GLint *v )
{
    struct qemu_glWindowPos2iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2IV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2iv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2iv *c = (struct qemu_glWindowPos2iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2iv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2ivARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2ivARB( const GLint *v )
{
    struct qemu_glWindowPos2ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2IVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2ivARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2ivARB *c = (struct qemu_glWindowPos2ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2ivARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2ivMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2ivMESA( const GLint *v )
{
    struct qemu_glWindowPos2ivMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2IVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2ivMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2ivMESA *c = (struct qemu_glWindowPos2ivMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2ivMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2s
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2s( GLshort x, GLshort y )
{
    struct qemu_glWindowPos2s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2S);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2s(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2s *c = (struct qemu_glWindowPos2s *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2s( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2sARB
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2sARB( GLshort x, GLshort y )
{
    struct qemu_glWindowPos2sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2SARB);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2sARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2sARB *c = (struct qemu_glWindowPos2sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2sARB( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2sMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2sMESA( GLshort x, GLshort y )
{
    struct qemu_glWindowPos2sMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2SMESA);
    call.x = x;
    call.y = y;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2sMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2sMESA *c = (struct qemu_glWindowPos2sMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2sMESA( c->x, c->y ));
}

#endif

struct qemu_glWindowPos2sv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2sv( const GLshort *v )
{
    struct qemu_glWindowPos2sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2SV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2sv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2sv *c = (struct qemu_glWindowPos2sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2sv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2svARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2svARB( const GLshort *v )
{
    struct qemu_glWindowPos2svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2SVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2svARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2svARB *c = (struct qemu_glWindowPos2svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2svARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos2svMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos2svMESA( const GLshort *v )
{
    struct qemu_glWindowPos2svMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS2SVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos2svMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos2svMESA *c = (struct qemu_glWindowPos2svMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos2svMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3d
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3d( GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glWindowPos3d call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3D);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3d(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3d *c = (struct qemu_glWindowPos3d *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3d( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3dARB
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3dARB( GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glWindowPos3dARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3DARB);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3dARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3dARB *c = (struct qemu_glWindowPos3dARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3dARB( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3dMESA
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3dMESA( GLdouble x, GLdouble y, GLdouble z )
{
    struct qemu_glWindowPos3dMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3DMESA);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3dMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3dMESA *c = (struct qemu_glWindowPos3dMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3dMESA( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3dv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3dv( const GLdouble *v )
{
    struct qemu_glWindowPos3dv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3DV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3dv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3dv *c = (struct qemu_glWindowPos3dv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3dv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3dvARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3dvARB( const GLdouble *v )
{
    struct qemu_glWindowPos3dvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3DVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3dvARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3dvARB *c = (struct qemu_glWindowPos3dvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3dvARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3dvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3dvMESA( const GLdouble *v )
{
    struct qemu_glWindowPos3dvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3DVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3dvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3dvMESA *c = (struct qemu_glWindowPos3dvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3dvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3f
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3f( GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glWindowPos3f call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3F);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3f(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3f *c = (struct qemu_glWindowPos3f *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3f( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3fARB
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3fARB( GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glWindowPos3fARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3FARB);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3fARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3fARB *c = (struct qemu_glWindowPos3fARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3fARB( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3fMESA
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3fMESA( GLfloat x, GLfloat y, GLfloat z )
{
    struct qemu_glWindowPos3fMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3FMESA);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3fMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3fMESA *c = (struct qemu_glWindowPos3fMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3fMESA( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3fv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3fv( const GLfloat *v )
{
    struct qemu_glWindowPos3fv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3FV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3fv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3fv *c = (struct qemu_glWindowPos3fv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3fv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3fvARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3fvARB( const GLfloat *v )
{
    struct qemu_glWindowPos3fvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3FVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3fvARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3fvARB *c = (struct qemu_glWindowPos3fvARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3fvARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3fvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3fvMESA( const GLfloat *v )
{
    struct qemu_glWindowPos3fvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3FVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3fvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3fvMESA *c = (struct qemu_glWindowPos3fvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3fvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3i
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3i( GLint x, GLint y, GLint z )
{
    struct qemu_glWindowPos3i call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3I);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3i(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3i *c = (struct qemu_glWindowPos3i *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3i( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3iARB
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3iARB( GLint x, GLint y, GLint z )
{
    struct qemu_glWindowPos3iARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3IARB);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3iARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3iARB *c = (struct qemu_glWindowPos3iARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3iARB( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3iMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3iMESA( GLint x, GLint y, GLint z )
{
    struct qemu_glWindowPos3iMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3IMESA);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3iMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3iMESA *c = (struct qemu_glWindowPos3iMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3iMESA( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3iv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3iv( const GLint *v )
{
    struct qemu_glWindowPos3iv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3IV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3iv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3iv *c = (struct qemu_glWindowPos3iv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3iv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3ivARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3ivARB( const GLint *v )
{
    struct qemu_glWindowPos3ivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3IVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3ivARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3ivARB *c = (struct qemu_glWindowPos3ivARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3ivARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3ivMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3ivMESA( const GLint *v )
{
    struct qemu_glWindowPos3ivMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3IVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3ivMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3ivMESA *c = (struct qemu_glWindowPos3ivMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3ivMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3s
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3s( GLshort x, GLshort y, GLshort z )
{
    struct qemu_glWindowPos3s call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3S);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3s(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3s *c = (struct qemu_glWindowPos3s *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3s( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3sARB
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3sARB( GLshort x, GLshort y, GLshort z )
{
    struct qemu_glWindowPos3sARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3SARB);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3sARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3sARB *c = (struct qemu_glWindowPos3sARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3sARB( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3sMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3sMESA( GLshort x, GLshort y, GLshort z )
{
    struct qemu_glWindowPos3sMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3SMESA);
    call.x = x;
    call.y = y;
    call.z = z;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3sMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3sMESA *c = (struct qemu_glWindowPos3sMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3sMESA( c->x, c->y, c->z ));
}

#endif

struct qemu_glWindowPos3sv
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3sv( const GLshort *v )
{
    struct qemu_glWindowPos3sv call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3SV);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3sv(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3sv *c = (struct qemu_glWindowPos3sv *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3sv( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3svARB
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3svARB( const GLshort *v )
{
    struct qemu_glWindowPos3svARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3SVARB);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3svARB(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3svARB *c = (struct qemu_glWindowPos3svARB *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3svARB( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos3svMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos3svMESA( const GLshort *v )
{
    struct qemu_glWindowPos3svMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS3SVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos3svMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos3svMESA *c = (struct qemu_glWindowPos3svMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos3svMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos4dMESA
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4dMESA( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
    struct qemu_glWindowPos4dMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4DMESA);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4dMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4dMESA *c = (struct qemu_glWindowPos4dMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4dMESA( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glWindowPos4dvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4dvMESA( const GLdouble *v )
{
    struct qemu_glWindowPos4dvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4DVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4dvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4dvMESA *c = (struct qemu_glWindowPos4dvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4dvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos4fMESA
{
    struct qemu_syscall super;
    double x;
    double y;
    double z;
    double w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4fMESA( GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
    struct qemu_glWindowPos4fMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4FMESA);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4fMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4fMESA *c = (struct qemu_glWindowPos4fMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4fMESA( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glWindowPos4fvMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4fvMESA( const GLfloat *v )
{
    struct qemu_glWindowPos4fvMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4FVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4fvMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4fvMESA *c = (struct qemu_glWindowPos4fvMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4fvMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos4iMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4iMESA( GLint x, GLint y, GLint z, GLint w )
{
    struct qemu_glWindowPos4iMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4IMESA);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4iMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4iMESA *c = (struct qemu_glWindowPos4iMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4iMESA( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glWindowPos4ivMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4ivMESA( const GLint *v )
{
    struct qemu_glWindowPos4ivMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4IVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4ivMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4ivMESA *c = (struct qemu_glWindowPos4ivMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4ivMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowPos4sMESA
{
    struct qemu_syscall super;
    uint64_t x;
    uint64_t y;
    uint64_t z;
    uint64_t w;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4sMESA( GLshort x, GLshort y, GLshort z, GLshort w )
{
    struct qemu_glWindowPos4sMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4SMESA);
    call.x = x;
    call.y = y;
    call.z = z;
    call.w = w;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4sMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4sMESA *c = (struct qemu_glWindowPos4sMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4sMESA( c->x, c->y, c->z, c->w ));
}

#endif

struct qemu_glWindowPos4svMESA
{
    struct qemu_syscall super;
    uint64_t v;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowPos4svMESA( const GLshort *v )
{
    struct qemu_glWindowPos4svMESA call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWPOS4SVMESA);
    call.v = (ULONG_PTR)v;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowPos4svMESA(struct qemu_syscall *call)
{
    struct qemu_glWindowPos4svMESA *c = (struct qemu_glWindowPos4svMESA *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowPos4svMESA( QEMU_G2H(c->v) ));
}

#endif

struct qemu_glWindowRectanglesEXT
{
    struct qemu_syscall super;
    uint64_t mode;
    uint64_t count;
    uint64_t box;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWindowRectanglesEXT( GLenum mode, GLsizei count, const GLint *box )
{
    struct qemu_glWindowRectanglesEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWINDOWRECTANGLESEXT);
    call.mode = mode;
    call.count = count;
    call.box = (ULONG_PTR)box;

    qemu_syscall(&call.super);
}

#else

void qemu_glWindowRectanglesEXT(struct qemu_syscall *call)
{
    struct qemu_glWindowRectanglesEXT *c = (struct qemu_glWindowRectanglesEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glWindowRectanglesEXT( c->mode, c->count, QEMU_G2H(c->box) ));
}

#endif

struct qemu_glWriteMaskEXT
{
    struct qemu_syscall super;
    uint64_t res;
    uint64_t in;
    uint64_t outX;
    uint64_t outY;
    uint64_t outZ;
    uint64_t outW;
};

#ifdef QEMU_DLL_GUEST

void WINAPI glWriteMaskEXT( GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW )
{
    struct qemu_glWriteMaskEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_GLWRITEMASKEXT);
    call.res = res;
    call.in = in;
    call.outX = outX;
    call.outY = outY;
    call.outZ = outZ;
    call.outW = outW;

    qemu_syscall(&call.super);
}

#else

void qemu_glWriteMaskEXT(struct qemu_syscall *call)
{
    struct qemu_glWriteMaskEXT *c = (struct qemu_glWriteMaskEXT *)call;
    WINE_FIXME("Unverified\n");
    (p_glWriteMaskEXT( c->res, c->in, c->outX, c->outY, c->outZ, c->outW ));
}

#endif

struct qemu_wglAllocateMemoryNV
{
    struct qemu_syscall super;
    uint64_t size;
    double readfreq;
    double writefreq;
    double priority;
};

#ifdef QEMU_DLL_GUEST

void * WINAPI wglAllocateMemoryNV( GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority )
{
    struct qemu_wglAllocateMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLALLOCATEMEMORYNV);
    call.size = size;
    call.readfreq = readfreq;
    call.writefreq = writefreq;
    call.priority = priority;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_wglAllocateMemoryNV(struct qemu_syscall *call)
{
    struct qemu_wglAllocateMemoryNV *c = (struct qemu_wglAllocateMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_wglAllocateMemoryNV( c->size, c->readfreq, c->writefreq, c->priority ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglChoosePixelFormatARB
{
    struct qemu_syscall super;
    uint64_t hdc;
    uint64_t piAttribIList;
    uint64_t pfAttribFList;
    uint64_t nMaxFormats;
    uint64_t piFormats;
    uint64_t nNumFormats;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglChoosePixelFormatARB( HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats )
{
    struct qemu_wglChoosePixelFormatARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLCHOOSEPIXELFORMATARB);
    call.hdc = (ULONG_PTR)hdc;
    call.piAttribIList = (ULONG_PTR)piAttribIList;
    call.pfAttribFList = (ULONG_PTR)pfAttribFList;
    call.nMaxFormats = nMaxFormats;
    call.piFormats = (ULONG_PTR)piFormats;
    call.nNumFormats = (ULONG_PTR)nNumFormats;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglChoosePixelFormatARB(struct qemu_syscall *call)
{
    struct qemu_wglChoosePixelFormatARB *c = (struct qemu_wglChoosePixelFormatARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglChoosePixelFormatARB( QEMU_G2H(c->hdc), QEMU_G2H(c->piAttribIList), QEMU_G2H(c->pfAttribFList), c->nMaxFormats, QEMU_G2H(c->piFormats), QEMU_G2H(c->nNumFormats) ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglFreeMemoryNV
{
    struct qemu_syscall super;
    uint64_t pointer;
};

#ifdef QEMU_DLL_GUEST

void WINAPI wglFreeMemoryNV( void *pointer )
{
    struct qemu_wglFreeMemoryNV call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLFREEMEMORYNV);
    call.pointer = (ULONG_PTR)pointer;

    qemu_syscall(&call.super);
}

#else

void qemu_wglFreeMemoryNV(struct qemu_syscall *call)
{
    struct qemu_wglFreeMemoryNV *c = (struct qemu_wglFreeMemoryNV *)call;
    WINE_FIXME("Unverified\n");
    (p_wglFreeMemoryNV( QEMU_G2H(c->pointer) ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglGetExtensionsStringARB
{
    struct qemu_syscall super;
    uint64_t hdc;
};

#ifdef QEMU_DLL_GUEST

const char * WINAPI wglGetExtensionsStringARB( HDC hdc )
{
    struct qemu_wglGetExtensionsStringARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLGETEXTENSIONSSTRINGARB);
    call.hdc = (ULONG_PTR)hdc;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_wglGetExtensionsStringARB(struct qemu_syscall *call)
{
    struct qemu_wglGetExtensionsStringARB *c = (struct qemu_wglGetExtensionsStringARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_wglGetExtensionsStringARB( QEMU_G2H(c->hdc) ));
}

#endif

struct qemu_wglGetExtensionsStringEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

const char * WINAPI wglGetExtensionsStringEXT(void)
{
    struct qemu_wglGetExtensionsStringEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLGETEXTENSIONSSTRINGEXT);

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_wglGetExtensionsStringEXT(struct qemu_syscall *call)
{
    struct qemu_wglGetExtensionsStringEXT *c = (struct qemu_wglGetExtensionsStringEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_wglGetExtensionsStringEXT());
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglGetPixelFormatAttribfvARB
{
    struct qemu_syscall super;
    uint64_t hdc;
    uint64_t iPixelFormat;
    uint64_t iLayerPlane;
    uint64_t nAttributes;
    uint64_t piAttributes;
    uint64_t pfValues;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglGetPixelFormatAttribfvARB( HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues )
{
    struct qemu_wglGetPixelFormatAttribfvARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLGETPIXELFORMATATTRIBFVARB);
    call.hdc = (ULONG_PTR)hdc;
    call.iPixelFormat = iPixelFormat;
    call.iLayerPlane = iLayerPlane;
    call.nAttributes = nAttributes;
    call.piAttributes = (ULONG_PTR)piAttributes;
    call.pfValues = (ULONG_PTR)pfValues;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglGetPixelFormatAttribfvARB(struct qemu_syscall *call)
{
    struct qemu_wglGetPixelFormatAttribfvARB *c = (struct qemu_wglGetPixelFormatAttribfvARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglGetPixelFormatAttribfvARB( QEMU_G2H(c->hdc), c->iPixelFormat, c->iLayerPlane, c->nAttributes, QEMU_G2H(c->piAttributes), QEMU_G2H(c->pfValues) ));
}

#endif

struct qemu_wglGetPixelFormatAttribivARB
{
    struct qemu_syscall super;
    uint64_t hdc;
    uint64_t iPixelFormat;
    uint64_t iLayerPlane;
    uint64_t nAttributes;
    uint64_t piAttributes;
    uint64_t piValues;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglGetPixelFormatAttribivARB( HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues )
{
    struct qemu_wglGetPixelFormatAttribivARB call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLGETPIXELFORMATATTRIBIVARB);
    call.hdc = (ULONG_PTR)hdc;
    call.iPixelFormat = iPixelFormat;
    call.iLayerPlane = iLayerPlane;
    call.nAttributes = nAttributes;
    call.piAttributes = (ULONG_PTR)piAttributes;
    call.piValues = (ULONG_PTR)piValues;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglGetPixelFormatAttribivARB(struct qemu_syscall *call)
{
    struct qemu_wglGetPixelFormatAttribivARB *c = (struct qemu_wglGetPixelFormatAttribivARB *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglGetPixelFormatAttribivARB( QEMU_G2H(c->hdc), c->iPixelFormat, c->iLayerPlane, c->nAttributes, QEMU_G2H(c->piAttributes), QEMU_G2H(c->piValues) ));
}

#endif

struct qemu_wglGetSwapIntervalEXT
{
    struct qemu_syscall super;
};

#ifdef QEMU_DLL_GUEST

int WINAPI wglGetSwapIntervalEXT(void)
{
    struct qemu_wglGetSwapIntervalEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLGETSWAPINTERVALEXT);

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglGetSwapIntervalEXT(struct qemu_syscall *call)
{
    struct qemu_wglGetSwapIntervalEXT *c = (struct qemu_wglGetSwapIntervalEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglGetSwapIntervalEXT());
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglQueryCurrentRendererIntegerWINE
{
    struct qemu_syscall super;
    uint64_t attribute;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglQueryCurrentRendererIntegerWINE( GLenum attribute, GLuint *value )
{
    struct qemu_wglQueryCurrentRendererIntegerWINE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLQUERYCURRENTRENDERERINTEGERWINE);
    call.attribute = attribute;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglQueryCurrentRendererIntegerWINE(struct qemu_syscall *call)
{
    struct qemu_wglQueryCurrentRendererIntegerWINE *c = (struct qemu_wglQueryCurrentRendererIntegerWINE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglQueryCurrentRendererIntegerWINE( c->attribute, QEMU_G2H(c->value) ));
}

#endif

struct qemu_wglQueryCurrentRendererStringWINE
{
    struct qemu_syscall super;
    uint64_t attribute;
};

#ifdef QEMU_DLL_GUEST

const GLchar * WINAPI wglQueryCurrentRendererStringWINE( GLenum attribute )
{
    struct qemu_wglQueryCurrentRendererStringWINE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLQUERYCURRENTRENDERERSTRINGWINE);
    call.attribute = attribute;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_wglQueryCurrentRendererStringWINE(struct qemu_syscall *call)
{
    struct qemu_wglQueryCurrentRendererStringWINE *c = (struct qemu_wglQueryCurrentRendererStringWINE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_wglQueryCurrentRendererStringWINE( c->attribute ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglQueryRendererIntegerWINE
{
    struct qemu_syscall super;
    uint64_t dc;
    uint64_t renderer;
    uint64_t attribute;
    uint64_t value;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglQueryRendererIntegerWINE( HDC dc, GLint renderer, GLenum attribute, GLuint *value )
{
    struct qemu_wglQueryRendererIntegerWINE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLQUERYRENDERERINTEGERWINE);
    call.dc = (ULONG_PTR)dc;
    call.renderer = renderer;
    call.attribute = attribute;
    call.value = (ULONG_PTR)value;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglQueryRendererIntegerWINE(struct qemu_syscall *call)
{
    struct qemu_wglQueryRendererIntegerWINE *c = (struct qemu_wglQueryRendererIntegerWINE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglQueryRendererIntegerWINE( QEMU_G2H(c->dc), c->renderer, c->attribute, QEMU_G2H(c->value) ));
}

#endif

struct qemu_wglQueryRendererStringWINE
{
    struct qemu_syscall super;
    uint64_t dc;
    uint64_t renderer;
    uint64_t attribute;
};

#ifdef QEMU_DLL_GUEST

const GLchar * WINAPI wglQueryRendererStringWINE( HDC dc, GLint renderer, GLenum attribute )
{
    struct qemu_wglQueryRendererStringWINE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLQUERYRENDERERSTRINGWINE);
    call.dc = (ULONG_PTR)dc;
    call.renderer = renderer;
    call.attribute = attribute;

    qemu_syscall(&call.super);

    return (void *)(ULONG_PTR)call.super.iret;
}

#else

void qemu_wglQueryRendererStringWINE(struct qemu_syscall *call)
{
    struct qemu_wglQueryRendererStringWINE *c = (struct qemu_wglQueryRendererStringWINE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = QEMU_H2G(p_wglQueryRendererStringWINE( QEMU_G2H(c->dc), c->renderer, c->attribute ));
}

#endif

#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
#ifdef QEMU_DLL_GUEST
#endif /* QEMU_DLL_GUEST */
struct qemu_wglSetPixelFormatWINE
{
    struct qemu_syscall super;
    uint64_t hdc;
    uint64_t format;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglSetPixelFormatWINE( HDC hdc, int format )
{
    struct qemu_wglSetPixelFormatWINE call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLSETPIXELFORMATWINE);
    call.hdc = (ULONG_PTR)hdc;
    call.format = format;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglSetPixelFormatWINE(struct qemu_syscall *call)
{
    struct qemu_wglSetPixelFormatWINE *c = (struct qemu_wglSetPixelFormatWINE *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglSetPixelFormatWINE( QEMU_G2H(c->hdc), c->format ));
}

#endif

struct qemu_wglSwapIntervalEXT
{
    struct qemu_syscall super;
    uint64_t interval;
};

#ifdef QEMU_DLL_GUEST

BOOL WINAPI wglSwapIntervalEXT( int interval )
{
    struct qemu_wglSwapIntervalEXT call;
    call.super.id = QEMU_SYSCALL_ID(CALL_WGLSWAPINTERVALEXT);
    call.interval = interval;

    qemu_syscall(&call.super);

    return call.super.iret;
}

#else

void qemu_wglSwapIntervalEXT(struct qemu_syscall *call)
{
    struct qemu_wglSwapIntervalEXT *c = (struct qemu_wglSwapIntervalEXT *)call;
    WINE_FIXME("Unverified\n");
    c->super.iret = (p_wglSwapIntervalEXT( c->interval ));
}

#endif

extern void WINAPI glDebugMessageCallback( GLDEBUGPROC callback, const void *userParam );
extern void WINAPI glDebugMessageCallbackAMD( GLDEBUGPROCAMD callback, void *userParam );
extern void WINAPI glDebugMessageCallbackARB( GLDEBUGPROCARB callback, const void *userParam );
extern const GLubyte * WINAPI glGetStringi( GLenum name, GLuint index );
extern BOOL WINAPI wglBindTexImageARB( HPBUFFERARB hPbuffer, int iBuffer );
extern HGLRC WINAPI wglCreateContextAttribsARB( HDC hDC, HGLRC hShareContext, const int *attribList );
extern HPBUFFERARB WINAPI wglCreatePbufferARB( HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList );
extern BOOL WINAPI wglDestroyPbufferARB( HPBUFFERARB hPbuffer );
extern HDC WINAPI wglGetCurrentReadDCARB(void);
extern HDC WINAPI wglGetPbufferDCARB( HPBUFFERARB hPbuffer );
extern BOOL WINAPI wglMakeContextCurrentARB( HDC hDrawDC, HDC hReadDC, HGLRC hglrc );
extern BOOL WINAPI wglQueryPbufferARB( HPBUFFERARB hPbuffer, int iAttribute, int *piValue );
extern int WINAPI wglReleasePbufferDCARB( HPBUFFERARB hPbuffer, HDC hDC );
extern BOOL WINAPI wglReleaseTexImageARB( HPBUFFERARB hPbuffer, int iBuffer );
extern BOOL WINAPI wglSetPbufferAttribARB( HPBUFFERARB hPbuffer, const int *piAttribList );
#ifdef QEMU_DLL_GUEST

const OpenGL_extension extension_registry[2694] = {
  { "glAccumxOES", "GL_OES_fixed_point", glAccumxOES },
  { "glAcquireKeyedMutexWin32EXT", "GL_EXT_win32_keyed_mutex", glAcquireKeyedMutexWin32EXT },
  { "glActiveProgramEXT", "GL_EXT_separate_shader_objects", glActiveProgramEXT },
  { "glActiveShaderProgram", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glActiveShaderProgram },
  { "glActiveStencilFaceEXT", "GL_EXT_stencil_two_side", glActiveStencilFaceEXT },
  { "glActiveTexture", "GL_VERSION_1_3", glActiveTexture },
  { "glActiveTextureARB", "GL_ARB_multitexture", glActiveTextureARB },
  { "glActiveVaryingNV", "GL_NV_transform_feedback", glActiveVaryingNV },
  { "glAlphaFragmentOp1ATI", "GL_ATI_fragment_shader", glAlphaFragmentOp1ATI },
  { "glAlphaFragmentOp2ATI", "GL_ATI_fragment_shader", glAlphaFragmentOp2ATI },
  { "glAlphaFragmentOp3ATI", "GL_ATI_fragment_shader", glAlphaFragmentOp3ATI },
  { "glAlphaFuncxOES", "GL_OES_fixed_point", glAlphaFuncxOES },
  { "glAlphaToCoverageDitherControlNV", "GL_NV_alpha_to_coverage_dither_control", glAlphaToCoverageDitherControlNV },
  { "glApplyFramebufferAttachmentCMAAINTEL", "GL_INTEL_framebuffer_CMAA", glApplyFramebufferAttachmentCMAAINTEL },
  { "glApplyTextureEXT", "GL_EXT_light_texture", glApplyTextureEXT },
  { "glAreProgramsResidentNV", "GL_NV_vertex_program", glAreProgramsResidentNV },
  { "glAreTexturesResidentEXT", "GL_EXT_texture_object", glAreTexturesResidentEXT },
  { "glArrayElementEXT", "GL_EXT_vertex_array", glArrayElementEXT },
  { "glArrayObjectATI", "GL_ATI_vertex_array_object", glArrayObjectATI },
  { "glAsyncCopyBufferSubDataNVX", "GL_NVX_gpu_multicast2", glAsyncCopyBufferSubDataNVX },
  { "glAsyncCopyImageSubDataNVX", "GL_NVX_gpu_multicast2", glAsyncCopyImageSubDataNVX },
  { "glAsyncMarkerSGIX", "GL_SGIX_async", glAsyncMarkerSGIX },
  { "glAttachObjectARB", "GL_ARB_shader_objects", glAttachObjectARB },
  { "glAttachShader", "GL_VERSION_2_0", glAttachShader },
  { "glBeginConditionalRender", "GL_VERSION_3_0", glBeginConditionalRender },
  { "glBeginConditionalRenderNV", "GL_NV_conditional_render", glBeginConditionalRenderNV },
  { "glBeginConditionalRenderNVX", "GL_NVX_conditional_render", glBeginConditionalRenderNVX },
  { "glBeginFragmentShaderATI", "GL_ATI_fragment_shader", glBeginFragmentShaderATI },
  { "glBeginOcclusionQueryNV", "GL_NV_occlusion_query", glBeginOcclusionQueryNV },
  { "glBeginPerfMonitorAMD", "GL_AMD_performance_monitor", glBeginPerfMonitorAMD },
  { "glBeginPerfQueryINTEL", "GL_INTEL_performance_query", glBeginPerfQueryINTEL },
  { "glBeginQuery", "GL_VERSION_1_5", glBeginQuery },
  { "glBeginQueryARB", "GL_ARB_occlusion_query", glBeginQueryARB },
  { "glBeginQueryIndexed", "GL_ARB_transform_feedback3 GL_VERSION_4_0", glBeginQueryIndexed },
  { "glBeginTransformFeedback", "GL_VERSION_3_0", glBeginTransformFeedback },
  { "glBeginTransformFeedbackEXT", "GL_EXT_transform_feedback", glBeginTransformFeedbackEXT },
  { "glBeginTransformFeedbackNV", "GL_NV_transform_feedback", glBeginTransformFeedbackNV },
  { "glBeginVertexShaderEXT", "GL_EXT_vertex_shader", glBeginVertexShaderEXT },
  { "glBeginVideoCaptureNV", "GL_NV_video_capture", glBeginVideoCaptureNV },
  { "glBindAttribLocation", "GL_VERSION_2_0", glBindAttribLocation },
  { "glBindAttribLocationARB", "GL_ARB_vertex_shader", glBindAttribLocationARB },
  { "glBindBuffer", "GL_VERSION_1_5", glBindBuffer },
  { "glBindBufferARB", "GL_ARB_vertex_buffer_object", glBindBufferARB },
  { "glBindBufferBase", "GL_ARB_uniform_buffer_object GL_VERSION_3_0", glBindBufferBase },
  { "glBindBufferBaseEXT", "GL_EXT_transform_feedback", glBindBufferBaseEXT },
  { "glBindBufferBaseNV", "GL_NV_transform_feedback", glBindBufferBaseNV },
  { "glBindBufferOffsetEXT", "GL_EXT_transform_feedback", glBindBufferOffsetEXT },
  { "glBindBufferOffsetNV", "GL_NV_transform_feedback", glBindBufferOffsetNV },
  { "glBindBufferRange", "GL_ARB_uniform_buffer_object GL_VERSION_3_0", glBindBufferRange },
  { "glBindBufferRangeEXT", "GL_EXT_transform_feedback", glBindBufferRangeEXT },
  { "glBindBufferRangeNV", "GL_NV_transform_feedback", glBindBufferRangeNV },
  { "glBindBuffersBase", "GL_ARB_multi_bind GL_VERSION_4_4", glBindBuffersBase },
  { "glBindBuffersRange", "GL_ARB_multi_bind GL_VERSION_4_4", glBindBuffersRange },
  { "glBindFragDataLocation", "GL_VERSION_3_0", glBindFragDataLocation },
  { "glBindFragDataLocationEXT", "GL_EXT_gpu_shader4", glBindFragDataLocationEXT },
  { "glBindFragDataLocationIndexed", "GL_ARB_blend_func_extended GL_VERSION_3_3", glBindFragDataLocationIndexed },
  { "glBindFragmentShaderATI", "GL_ATI_fragment_shader", glBindFragmentShaderATI },
  { "glBindFramebuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glBindFramebuffer },
  { "glBindFramebufferEXT", "GL_EXT_framebuffer_object", glBindFramebufferEXT },
  { "glBindImageTexture", "GL_ARB_shader_image_load_store GL_VERSION_4_2", glBindImageTexture },
  { "glBindImageTextureEXT", "GL_EXT_shader_image_load_store", glBindImageTextureEXT },
  { "glBindImageTextures", "GL_ARB_multi_bind GL_VERSION_4_4", glBindImageTextures },
  { "glBindLightParameterEXT", "GL_EXT_vertex_shader", glBindLightParameterEXT },
  { "glBindMaterialParameterEXT", "GL_EXT_vertex_shader", glBindMaterialParameterEXT },
  { "glBindMultiTextureEXT", "GL_EXT_direct_state_access", glBindMultiTextureEXT },
  { "glBindParameterEXT", "GL_EXT_vertex_shader", glBindParameterEXT },
  { "glBindProgramARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glBindProgramARB },
  { "glBindProgramNV", "GL_NV_vertex_program", glBindProgramNV },
  { "glBindProgramPipeline", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glBindProgramPipeline },
  { "glBindRenderbuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glBindRenderbuffer },
  { "glBindRenderbufferEXT", "GL_EXT_framebuffer_object", glBindRenderbufferEXT },
  { "glBindSampler", "GL_ARB_sampler_objects GL_VERSION_3_3", glBindSampler },
  { "glBindSamplers", "GL_ARB_multi_bind GL_VERSION_4_4", glBindSamplers },
  { "glBindShadingRateImageNV", "GL_NV_shading_rate_image", glBindShadingRateImageNV },
  { "glBindTexGenParameterEXT", "GL_EXT_vertex_shader", glBindTexGenParameterEXT },
  { "glBindTextureEXT", "GL_EXT_texture_object", glBindTextureEXT },
  { "glBindTextureUnit", "GL_ARB_direct_state_access GL_VERSION_4_5", glBindTextureUnit },
  { "glBindTextureUnitParameterEXT", "GL_EXT_vertex_shader", glBindTextureUnitParameterEXT },
  { "glBindTextures", "GL_ARB_multi_bind GL_VERSION_4_4", glBindTextures },
  { "glBindTransformFeedback", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glBindTransformFeedback },
  { "glBindTransformFeedbackNV", "GL_NV_transform_feedback2", glBindTransformFeedbackNV },
  { "glBindVertexArray", "GL_ARB_vertex_array_object GL_VERSION_3_0", glBindVertexArray },
  { "glBindVertexArrayAPPLE", "GL_APPLE_vertex_array_object", glBindVertexArrayAPPLE },
  { "glBindVertexBuffer", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glBindVertexBuffer },
  { "glBindVertexBuffers", "GL_ARB_multi_bind GL_VERSION_4_4", glBindVertexBuffers },
  { "glBindVertexShaderEXT", "GL_EXT_vertex_shader", glBindVertexShaderEXT },
  { "glBindVideoCaptureStreamBufferNV", "GL_NV_video_capture", glBindVideoCaptureStreamBufferNV },
  { "glBindVideoCaptureStreamTextureNV", "GL_NV_video_capture", glBindVideoCaptureStreamTextureNV },
  { "glBinormal3bEXT", "GL_EXT_coordinate_frame", glBinormal3bEXT },
  { "glBinormal3bvEXT", "GL_EXT_coordinate_frame", glBinormal3bvEXT },
  { "glBinormal3dEXT", "GL_EXT_coordinate_frame", glBinormal3dEXT },
  { "glBinormal3dvEXT", "GL_EXT_coordinate_frame", glBinormal3dvEXT },
  { "glBinormal3fEXT", "GL_EXT_coordinate_frame", glBinormal3fEXT },
  { "glBinormal3fvEXT", "GL_EXT_coordinate_frame", glBinormal3fvEXT },
  { "glBinormal3iEXT", "GL_EXT_coordinate_frame", glBinormal3iEXT },
  { "glBinormal3ivEXT", "GL_EXT_coordinate_frame", glBinormal3ivEXT },
  { "glBinormal3sEXT", "GL_EXT_coordinate_frame", glBinormal3sEXT },
  { "glBinormal3svEXT", "GL_EXT_coordinate_frame", glBinormal3svEXT },
  { "glBinormalPointerEXT", "GL_EXT_coordinate_frame", glBinormalPointerEXT },
  { "glBitmapxOES", "GL_OES_fixed_point", glBitmapxOES },
  { "glBlendBarrierKHR", "GL_KHR_blend_equation_advanced", glBlendBarrierKHR },
  { "glBlendBarrierNV", "GL_NV_blend_equation_advanced", glBlendBarrierNV },
  { "glBlendColor", "GL_ARB_imaging GL_VERSION_1_4", glBlendColor },
  { "glBlendColorEXT", "GL_EXT_blend_color", glBlendColorEXT },
  { "glBlendColorxOES", "GL_OES_fixed_point", glBlendColorxOES },
  { "glBlendEquation", "GL_ARB_imaging GL_VERSION_1_4", glBlendEquation },
  { "glBlendEquationEXT", "GL_EXT_blend_minmax", glBlendEquationEXT },
  { "glBlendEquationIndexedAMD", "GL_AMD_draw_buffers_blend", glBlendEquationIndexedAMD },
  { "glBlendEquationSeparate", "GL_VERSION_2_0", glBlendEquationSeparate },
  { "glBlendEquationSeparateEXT", "GL_EXT_blend_equation_separate", glBlendEquationSeparateEXT },
  { "glBlendEquationSeparateIndexedAMD", "GL_AMD_draw_buffers_blend", glBlendEquationSeparateIndexedAMD },
  { "glBlendEquationSeparatei", "GL_VERSION_4_0", glBlendEquationSeparatei },
  { "glBlendEquationSeparateiARB", "GL_ARB_draw_buffers_blend", glBlendEquationSeparateiARB },
  { "glBlendEquationi", "GL_VERSION_4_0", glBlendEquationi },
  { "glBlendEquationiARB", "GL_ARB_draw_buffers_blend", glBlendEquationiARB },
  { "glBlendFuncIndexedAMD", "GL_AMD_draw_buffers_blend", glBlendFuncIndexedAMD },
  { "glBlendFuncSeparate", "GL_VERSION_1_4", glBlendFuncSeparate },
  { "glBlendFuncSeparateEXT", "GL_EXT_blend_func_separate", glBlendFuncSeparateEXT },
  { "glBlendFuncSeparateINGR", "GL_INGR_blend_func_separate", glBlendFuncSeparateINGR },
  { "glBlendFuncSeparateIndexedAMD", "GL_AMD_draw_buffers_blend", glBlendFuncSeparateIndexedAMD },
  { "glBlendFuncSeparatei", "GL_VERSION_4_0", glBlendFuncSeparatei },
  { "glBlendFuncSeparateiARB", "GL_ARB_draw_buffers_blend", glBlendFuncSeparateiARB },
  { "glBlendFunci", "GL_VERSION_4_0", glBlendFunci },
  { "glBlendFunciARB", "GL_ARB_draw_buffers_blend", glBlendFunciARB },
  { "glBlendParameteriNV", "GL_NV_blend_equation_advanced", glBlendParameteriNV },
  { "glBlitFramebuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glBlitFramebuffer },
  { "glBlitFramebufferEXT", "GL_EXT_framebuffer_blit", glBlitFramebufferEXT },
  { "glBlitNamedFramebuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glBlitNamedFramebuffer },
  { "glBufferAddressRangeNV", "GL_NV_vertex_buffer_unified_memory", glBufferAddressRangeNV },
  { "glBufferAttachMemoryNV", "GL_NV_memory_attachment", glBufferAttachMemoryNV },
  { "glBufferData", "GL_VERSION_1_5", glBufferData },
  { "glBufferDataARB", "GL_ARB_vertex_buffer_object", glBufferDataARB },
  { "glBufferPageCommitmentARB", "GL_ARB_sparse_buffer", glBufferPageCommitmentARB },
  { "glBufferParameteriAPPLE", "GL_APPLE_flush_buffer_range", glBufferParameteriAPPLE },
  { "glBufferRegionEnabled", "GL_KTX_buffer_region", glBufferRegionEnabled },
  { "glBufferStorage", "GL_ARB_buffer_storage GL_VERSION_4_4", glBufferStorage },
  { "glBufferStorageExternalEXT", "GL_EXT_external_buffer", glBufferStorageExternalEXT },
  { "glBufferStorageMemEXT", "GL_EXT_memory_object", glBufferStorageMemEXT },
  { "glBufferSubData", "GL_VERSION_1_5", glBufferSubData },
  { "glBufferSubDataARB", "GL_ARB_vertex_buffer_object", glBufferSubDataARB },
  { "glCallCommandListNV", "GL_NV_command_list", glCallCommandListNV },
  { "glCheckFramebufferStatus", "GL_ARB_framebuffer_object GL_VERSION_3_0", glCheckFramebufferStatus },
  { "glCheckFramebufferStatusEXT", "GL_EXT_framebuffer_object", glCheckFramebufferStatusEXT },
  { "glCheckNamedFramebufferStatus", "GL_ARB_direct_state_access GL_VERSION_4_5", glCheckNamedFramebufferStatus },
  { "glCheckNamedFramebufferStatusEXT", "GL_EXT_direct_state_access", glCheckNamedFramebufferStatusEXT },
  { "glClampColor", "GL_VERSION_3_0", glClampColor },
  { "glClampColorARB", "GL_ARB_color_buffer_float", glClampColorARB },
  { "glClearAccumxOES", "GL_OES_fixed_point", glClearAccumxOES },
  { "glClearBufferData", "GL_ARB_clear_buffer_object GL_VERSION_4_3", glClearBufferData },
  { "glClearBufferSubData", "GL_ARB_clear_buffer_object GL_VERSION_4_3", glClearBufferSubData },
  { "glClearBufferfi", "GL_VERSION_3_0", glClearBufferfi },
  { "glClearBufferfv", "GL_VERSION_3_0", glClearBufferfv },
  { "glClearBufferiv", "GL_VERSION_3_0", glClearBufferiv },
  { "glClearBufferuiv", "GL_VERSION_3_0", glClearBufferuiv },
  { "glClearColorIiEXT", "GL_EXT_texture_integer", glClearColorIiEXT },
  { "glClearColorIuiEXT", "GL_EXT_texture_integer", glClearColorIuiEXT },
  { "glClearColorxOES", "GL_OES_fixed_point", glClearColorxOES },
  { "glClearDepthdNV", "GL_NV_depth_buffer_float", glClearDepthdNV },
  { "glClearDepthf", "GL_ARB_ES2_compatibility GL_VERSION_4_1", glClearDepthf },
  { "glClearDepthfOES", "GL_OES_single_precision", glClearDepthfOES },
  { "glClearDepthxOES", "GL_OES_fixed_point", glClearDepthxOES },
  { "glClearNamedBufferData", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedBufferData },
  { "glClearNamedBufferDataEXT", "GL_EXT_direct_state_access", glClearNamedBufferDataEXT },
  { "glClearNamedBufferSubData", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedBufferSubData },
  { "glClearNamedBufferSubDataEXT", "GL_EXT_direct_state_access", glClearNamedBufferSubDataEXT },
  { "glClearNamedFramebufferfi", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedFramebufferfi },
  { "glClearNamedFramebufferfv", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedFramebufferfv },
  { "glClearNamedFramebufferiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedFramebufferiv },
  { "glClearNamedFramebufferuiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glClearNamedFramebufferuiv },
  { "glClearTexImage", "GL_ARB_clear_texture GL_VERSION_4_4", glClearTexImage },
  { "glClearTexSubImage", "GL_ARB_clear_texture GL_VERSION_4_4", glClearTexSubImage },
  { "glClientActiveTexture", "GL_VERSION_1_3", glClientActiveTexture },
  { "glClientActiveTextureARB", "GL_ARB_multitexture", glClientActiveTextureARB },
  { "glClientActiveVertexStreamATI", "GL_ATI_vertex_streams", glClientActiveVertexStreamATI },
  { "glClientAttribDefaultEXT", "GL_EXT_direct_state_access", glClientAttribDefaultEXT },
  { "glClientWaitSemaphoreui64NVX", "GL_NVX_progress_fence", glClientWaitSemaphoreui64NVX },
  { "glClientWaitSync", "GL_ARB_sync GL_VERSION_3_2", glClientWaitSync },
  { "glClipControl", "GL_ARB_clip_control GL_VERSION_4_5", glClipControl },
  { "glClipPlanefOES", "GL_OES_single_precision", glClipPlanefOES },
  { "glClipPlanexOES", "GL_OES_fixed_point", glClipPlanexOES },
  { "glColor3fVertex3fSUN", "GL_SUN_vertex", glColor3fVertex3fSUN },
  { "glColor3fVertex3fvSUN", "GL_SUN_vertex", glColor3fVertex3fvSUN },
  { "glColor3hNV", "GL_NV_half_float", glColor3hNV },
  { "glColor3hvNV", "GL_NV_half_float", glColor3hvNV },
  { "glColor3xOES", "GL_OES_fixed_point", glColor3xOES },
  { "glColor3xvOES", "GL_OES_fixed_point", glColor3xvOES },
  { "glColor4fNormal3fVertex3fSUN", "GL_SUN_vertex", glColor4fNormal3fVertex3fSUN },
  { "glColor4fNormal3fVertex3fvSUN", "GL_SUN_vertex", glColor4fNormal3fVertex3fvSUN },
  { "glColor4hNV", "GL_NV_half_float", glColor4hNV },
  { "glColor4hvNV", "GL_NV_half_float", glColor4hvNV },
  { "glColor4ubVertex2fSUN", "GL_SUN_vertex", glColor4ubVertex2fSUN },
  { "glColor4ubVertex2fvSUN", "GL_SUN_vertex", glColor4ubVertex2fvSUN },
  { "glColor4ubVertex3fSUN", "GL_SUN_vertex", glColor4ubVertex3fSUN },
  { "glColor4ubVertex3fvSUN", "GL_SUN_vertex", glColor4ubVertex3fvSUN },
  { "glColor4xOES", "GL_OES_fixed_point", glColor4xOES },
  { "glColor4xvOES", "GL_OES_fixed_point", glColor4xvOES },
  { "glColorFormatNV", "GL_NV_vertex_buffer_unified_memory", glColorFormatNV },
  { "glColorFragmentOp1ATI", "GL_ATI_fragment_shader", glColorFragmentOp1ATI },
  { "glColorFragmentOp2ATI", "GL_ATI_fragment_shader", glColorFragmentOp2ATI },
  { "glColorFragmentOp3ATI", "GL_ATI_fragment_shader", glColorFragmentOp3ATI },
  { "glColorMaskIndexedEXT", "GL_EXT_draw_buffers2", glColorMaskIndexedEXT },
  { "glColorMaski", "GL_VERSION_3_0", glColorMaski },
  { "glColorP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glColorP3ui },
  { "glColorP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glColorP3uiv },
  { "glColorP4ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glColorP4ui },
  { "glColorP4uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glColorP4uiv },
  { "glColorPointerEXT", "GL_EXT_vertex_array", glColorPointerEXT },
  { "glColorPointerListIBM", "GL_IBM_vertex_array_lists", glColorPointerListIBM },
  { "glColorPointervINTEL", "GL_INTEL_parallel_arrays", glColorPointervINTEL },
  { "glColorSubTable", "GL_ARB_imaging", glColorSubTable },
  { "glColorSubTableEXT", "GL_EXT_color_subtable", glColorSubTableEXT },
  { "glColorTable", "GL_ARB_imaging", glColorTable },
  { "glColorTableEXT", "GL_EXT_paletted_texture", glColorTableEXT },
  { "glColorTableParameterfv", "GL_ARB_imaging", glColorTableParameterfv },
  { "glColorTableParameterfvSGI", "GL_SGI_color_table", glColorTableParameterfvSGI },
  { "glColorTableParameteriv", "GL_ARB_imaging", glColorTableParameteriv },
  { "glColorTableParameterivSGI", "GL_SGI_color_table", glColorTableParameterivSGI },
  { "glColorTableSGI", "GL_SGI_color_table", glColorTableSGI },
  { "glCombinerInputNV", "GL_NV_register_combiners", glCombinerInputNV },
  { "glCombinerOutputNV", "GL_NV_register_combiners", glCombinerOutputNV },
  { "glCombinerParameterfNV", "GL_NV_register_combiners", glCombinerParameterfNV },
  { "glCombinerParameterfvNV", "GL_NV_register_combiners", glCombinerParameterfvNV },
  { "glCombinerParameteriNV", "GL_NV_register_combiners", glCombinerParameteriNV },
  { "glCombinerParameterivNV", "GL_NV_register_combiners", glCombinerParameterivNV },
  { "glCombinerStageParameterfvNV", "GL_NV_register_combiners2", glCombinerStageParameterfvNV },
  { "glCommandListSegmentsNV", "GL_NV_command_list", glCommandListSegmentsNV },
  { "glCompileCommandListNV", "GL_NV_command_list", glCompileCommandListNV },
  { "glCompileShader", "GL_VERSION_2_0", glCompileShader },
  { "glCompileShaderARB", "GL_ARB_shader_objects", glCompileShaderARB },
  { "glCompileShaderIncludeARB", "GL_ARB_shading_language_include", glCompileShaderIncludeARB },
  { "glCompressedMultiTexImage1DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexImage1DEXT },
  { "glCompressedMultiTexImage2DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexImage2DEXT },
  { "glCompressedMultiTexImage3DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexImage3DEXT },
  { "glCompressedMultiTexSubImage1DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexSubImage1DEXT },
  { "glCompressedMultiTexSubImage2DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexSubImage2DEXT },
  { "glCompressedMultiTexSubImage3DEXT", "GL_EXT_direct_state_access", glCompressedMultiTexSubImage3DEXT },
  { "glCompressedTexImage1D", "GL_VERSION_1_3", glCompressedTexImage1D },
  { "glCompressedTexImage1DARB", "GL_ARB_texture_compression", glCompressedTexImage1DARB },
  { "glCompressedTexImage2D", "GL_VERSION_1_3", glCompressedTexImage2D },
  { "glCompressedTexImage2DARB", "GL_ARB_texture_compression", glCompressedTexImage2DARB },
  { "glCompressedTexImage3D", "GL_VERSION_1_3", glCompressedTexImage3D },
  { "glCompressedTexImage3DARB", "GL_ARB_texture_compression", glCompressedTexImage3DARB },
  { "glCompressedTexSubImage1D", "GL_VERSION_1_3", glCompressedTexSubImage1D },
  { "glCompressedTexSubImage1DARB", "GL_ARB_texture_compression", glCompressedTexSubImage1DARB },
  { "glCompressedTexSubImage2D", "GL_VERSION_1_3", glCompressedTexSubImage2D },
  { "glCompressedTexSubImage2DARB", "GL_ARB_texture_compression", glCompressedTexSubImage2DARB },
  { "glCompressedTexSubImage3D", "GL_VERSION_1_3", glCompressedTexSubImage3D },
  { "glCompressedTexSubImage3DARB", "GL_ARB_texture_compression", glCompressedTexSubImage3DARB },
  { "glCompressedTextureImage1DEXT", "GL_EXT_direct_state_access", glCompressedTextureImage1DEXT },
  { "glCompressedTextureImage2DEXT", "GL_EXT_direct_state_access", glCompressedTextureImage2DEXT },
  { "glCompressedTextureImage3DEXT", "GL_EXT_direct_state_access", glCompressedTextureImage3DEXT },
  { "glCompressedTextureSubImage1D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCompressedTextureSubImage1D },
  { "glCompressedTextureSubImage1DEXT", "GL_EXT_direct_state_access", glCompressedTextureSubImage1DEXT },
  { "glCompressedTextureSubImage2D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCompressedTextureSubImage2D },
  { "glCompressedTextureSubImage2DEXT", "GL_EXT_direct_state_access", glCompressedTextureSubImage2DEXT },
  { "glCompressedTextureSubImage3D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCompressedTextureSubImage3D },
  { "glCompressedTextureSubImage3DEXT", "GL_EXT_direct_state_access", glCompressedTextureSubImage3DEXT },
  { "glConservativeRasterParameterfNV", "GL_NV_conservative_raster_dilate", glConservativeRasterParameterfNV },
  { "glConservativeRasterParameteriNV", "GL_NV_conservative_raster_pre_snap_triangles", glConservativeRasterParameteriNV },
  { "glConvolutionFilter1D", "GL_ARB_imaging", glConvolutionFilter1D },
  { "glConvolutionFilter1DEXT", "GL_EXT_convolution", glConvolutionFilter1DEXT },
  { "glConvolutionFilter2D", "GL_ARB_imaging", glConvolutionFilter2D },
  { "glConvolutionFilter2DEXT", "GL_EXT_convolution", glConvolutionFilter2DEXT },
  { "glConvolutionParameterf", "GL_ARB_imaging", glConvolutionParameterf },
  { "glConvolutionParameterfEXT", "GL_EXT_convolution", glConvolutionParameterfEXT },
  { "glConvolutionParameterfv", "GL_ARB_imaging", glConvolutionParameterfv },
  { "glConvolutionParameterfvEXT", "GL_EXT_convolution", glConvolutionParameterfvEXT },
  { "glConvolutionParameteri", "GL_ARB_imaging", glConvolutionParameteri },
  { "glConvolutionParameteriEXT", "GL_EXT_convolution", glConvolutionParameteriEXT },
  { "glConvolutionParameteriv", "GL_ARB_imaging", glConvolutionParameteriv },
  { "glConvolutionParameterivEXT", "GL_EXT_convolution", glConvolutionParameterivEXT },
  { "glConvolutionParameterxOES", "GL_OES_fixed_point", glConvolutionParameterxOES },
  { "glConvolutionParameterxvOES", "GL_OES_fixed_point", glConvolutionParameterxvOES },
  { "glCopyBufferSubData", "GL_ARB_copy_buffer GL_VERSION_3_1", glCopyBufferSubData },
  { "glCopyColorSubTable", "GL_ARB_imaging", glCopyColorSubTable },
  { "glCopyColorSubTableEXT", "GL_EXT_color_subtable", glCopyColorSubTableEXT },
  { "glCopyColorTable", "GL_ARB_imaging", glCopyColorTable },
  { "glCopyColorTableSGI", "GL_SGI_color_table", glCopyColorTableSGI },
  { "glCopyConvolutionFilter1D", "GL_ARB_imaging", glCopyConvolutionFilter1D },
  { "glCopyConvolutionFilter1DEXT", "GL_EXT_convolution", glCopyConvolutionFilter1DEXT },
  { "glCopyConvolutionFilter2D", "GL_ARB_imaging", glCopyConvolutionFilter2D },
  { "glCopyConvolutionFilter2DEXT", "GL_EXT_convolution", glCopyConvolutionFilter2DEXT },
  { "glCopyImageSubData", "GL_ARB_copy_image GL_VERSION_4_3", glCopyImageSubData },
  { "glCopyImageSubDataNV", "GL_NV_copy_image", glCopyImageSubDataNV },
  { "glCopyMultiTexImage1DEXT", "GL_EXT_direct_state_access", glCopyMultiTexImage1DEXT },
  { "glCopyMultiTexImage2DEXT", "GL_EXT_direct_state_access", glCopyMultiTexImage2DEXT },
  { "glCopyMultiTexSubImage1DEXT", "GL_EXT_direct_state_access", glCopyMultiTexSubImage1DEXT },
  { "glCopyMultiTexSubImage2DEXT", "GL_EXT_direct_state_access", glCopyMultiTexSubImage2DEXT },
  { "glCopyMultiTexSubImage3DEXT", "GL_EXT_direct_state_access", glCopyMultiTexSubImage3DEXT },
  { "glCopyNamedBufferSubData", "GL_ARB_direct_state_access GL_VERSION_4_5", glCopyNamedBufferSubData },
  { "glCopyPathNV", "GL_NV_path_rendering", glCopyPathNV },
  { "glCopyTexImage1DEXT", "GL_EXT_copy_texture", glCopyTexImage1DEXT },
  { "glCopyTexImage2DEXT", "GL_EXT_copy_texture", glCopyTexImage2DEXT },
  { "glCopyTexSubImage1DEXT", "GL_EXT_copy_texture", glCopyTexSubImage1DEXT },
  { "glCopyTexSubImage2DEXT", "GL_EXT_copy_texture", glCopyTexSubImage2DEXT },
  { "glCopyTexSubImage3D", "GL_VERSION_1_2", glCopyTexSubImage3D },
  { "glCopyTexSubImage3DEXT", "GL_EXT_copy_texture", glCopyTexSubImage3DEXT },
  { "glCopyTextureImage1DEXT", "GL_EXT_direct_state_access", glCopyTextureImage1DEXT },
  { "glCopyTextureImage2DEXT", "GL_EXT_direct_state_access", glCopyTextureImage2DEXT },
  { "glCopyTextureSubImage1D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCopyTextureSubImage1D },
  { "glCopyTextureSubImage1DEXT", "GL_EXT_direct_state_access", glCopyTextureSubImage1DEXT },
  { "glCopyTextureSubImage2D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCopyTextureSubImage2D },
  { "glCopyTextureSubImage2DEXT", "GL_EXT_direct_state_access", glCopyTextureSubImage2DEXT },
  { "glCopyTextureSubImage3D", "GL_ARB_direct_state_access GL_VERSION_4_5", glCopyTextureSubImage3D },
  { "glCopyTextureSubImage3DEXT", "GL_EXT_direct_state_access", glCopyTextureSubImage3DEXT },
  { "glCoverFillPathInstancedNV", "GL_NV_path_rendering", glCoverFillPathInstancedNV },
  { "glCoverFillPathNV", "GL_NV_path_rendering", glCoverFillPathNV },
  { "glCoverStrokePathInstancedNV", "GL_NV_path_rendering", glCoverStrokePathInstancedNV },
  { "glCoverStrokePathNV", "GL_NV_path_rendering", glCoverStrokePathNV },
  { "glCoverageModulationNV", "GL_NV_framebuffer_mixed_samples", glCoverageModulationNV },
  { "glCoverageModulationTableNV", "GL_NV_framebuffer_mixed_samples", glCoverageModulationTableNV },
  { "glCreateBuffers", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateBuffers },
  { "glCreateCommandListsNV", "GL_NV_command_list", glCreateCommandListsNV },
  { "glCreateFramebuffers", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateFramebuffers },
  { "glCreateMemoryObjectsEXT", "GL_EXT_memory_object", glCreateMemoryObjectsEXT },
  { "glCreatePerfQueryINTEL", "GL_INTEL_performance_query", glCreatePerfQueryINTEL },
  { "glCreateProgram", "GL_VERSION_2_0", glCreateProgram },
  { "glCreateProgramObjectARB", "GL_ARB_shader_objects", glCreateProgramObjectARB },
  { "glCreateProgramPipelines", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateProgramPipelines },
  { "glCreateProgressFenceNVX", "GL_NVX_progress_fence", glCreateProgressFenceNVX },
  { "glCreateQueries", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateQueries },
  { "glCreateRenderbuffers", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateRenderbuffers },
  { "glCreateSamplers", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateSamplers },
  { "glCreateShader", "GL_VERSION_2_0", glCreateShader },
  { "glCreateShaderObjectARB", "GL_ARB_shader_objects", glCreateShaderObjectARB },
  { "glCreateShaderProgramEXT", "GL_EXT_separate_shader_objects", glCreateShaderProgramEXT },
  { "glCreateShaderProgramv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glCreateShaderProgramv },
  { "glCreateStatesNV", "GL_NV_command_list", glCreateStatesNV },
  { "glCreateSyncFromCLeventARB", "GL_ARB_cl_event", glCreateSyncFromCLeventARB },
  { "glCreateTextures", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateTextures },
  { "glCreateTransformFeedbacks", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateTransformFeedbacks },
  { "glCreateVertexArrays", "GL_ARB_direct_state_access GL_VERSION_4_5", glCreateVertexArrays },
  { "glCullParameterdvEXT", "GL_EXT_cull_vertex", glCullParameterdvEXT },
  { "glCullParameterfvEXT", "GL_EXT_cull_vertex", glCullParameterfvEXT },
  { "glCurrentPaletteMatrixARB", "GL_ARB_matrix_palette", glCurrentPaletteMatrixARB },
  { "glDebugMessageCallback", "GL_KHR_debug GL_VERSION_4_3", glDebugMessageCallback },
  { "glDebugMessageCallbackAMD", "GL_AMD_debug_output", glDebugMessageCallbackAMD },
  { "glDebugMessageCallbackARB", "GL_ARB_debug_output", glDebugMessageCallbackARB },
  { "glDebugMessageControl", "GL_KHR_debug GL_VERSION_4_3", glDebugMessageControl },
  { "glDebugMessageControlARB", "GL_ARB_debug_output", glDebugMessageControlARB },
  { "glDebugMessageEnableAMD", "GL_AMD_debug_output", glDebugMessageEnableAMD },
  { "glDebugMessageInsert", "GL_KHR_debug GL_VERSION_4_3", glDebugMessageInsert },
  { "glDebugMessageInsertAMD", "GL_AMD_debug_output", glDebugMessageInsertAMD },
  { "glDebugMessageInsertARB", "GL_ARB_debug_output", glDebugMessageInsertARB },
  { "glDeformSGIX", "GL_SGIX_polynomial_ffd", glDeformSGIX },
  { "glDeformationMap3dSGIX", "GL_SGIX_polynomial_ffd", glDeformationMap3dSGIX },
  { "glDeformationMap3fSGIX", "GL_SGIX_polynomial_ffd", glDeformationMap3fSGIX },
  { "glDeleteAsyncMarkersSGIX", "GL_SGIX_async", glDeleteAsyncMarkersSGIX },
  { "glDeleteBufferRegion", "GL_KTX_buffer_region", glDeleteBufferRegion },
  { "glDeleteBuffers", "GL_VERSION_1_5", glDeleteBuffers },
  { "glDeleteBuffersARB", "GL_ARB_vertex_buffer_object", glDeleteBuffersARB },
  { "glDeleteCommandListsNV", "GL_NV_command_list", glDeleteCommandListsNV },
  { "glDeleteFencesAPPLE", "GL_APPLE_fence", glDeleteFencesAPPLE },
  { "glDeleteFencesNV", "GL_NV_fence", glDeleteFencesNV },
  { "glDeleteFragmentShaderATI", "GL_ATI_fragment_shader", glDeleteFragmentShaderATI },
  { "glDeleteFramebuffers", "GL_ARB_framebuffer_object GL_VERSION_3_0", glDeleteFramebuffers },
  { "glDeleteFramebuffersEXT", "GL_EXT_framebuffer_object", glDeleteFramebuffersEXT },
  { "glDeleteMemoryObjectsEXT", "GL_EXT_memory_object", glDeleteMemoryObjectsEXT },
  { "glDeleteNamedStringARB", "GL_ARB_shading_language_include", glDeleteNamedStringARB },
  { "glDeleteNamesAMD", "GL_AMD_name_gen_delete", glDeleteNamesAMD },
  { "glDeleteObjectARB", "GL_ARB_shader_objects", glDeleteObjectARB },
  { "glDeleteObjectBufferATI", "GL_ATI_vertex_array_object", glDeleteObjectBufferATI },
  { "glDeleteOcclusionQueriesNV", "GL_NV_occlusion_query", glDeleteOcclusionQueriesNV },
  { "glDeletePathsNV", "GL_NV_path_rendering", glDeletePathsNV },
  { "glDeletePerfMonitorsAMD", "GL_AMD_performance_monitor", glDeletePerfMonitorsAMD },
  { "glDeletePerfQueryINTEL", "GL_INTEL_performance_query", glDeletePerfQueryINTEL },
  { "glDeleteProgram", "GL_VERSION_2_0", glDeleteProgram },
  { "glDeleteProgramPipelines", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glDeleteProgramPipelines },
  { "glDeleteProgramsARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glDeleteProgramsARB },
  { "glDeleteProgramsNV", "GL_NV_vertex_program", glDeleteProgramsNV },
  { "glDeleteQueries", "GL_VERSION_1_5", glDeleteQueries },
  { "glDeleteQueriesARB", "GL_ARB_occlusion_query", glDeleteQueriesARB },
  { "glDeleteQueryResourceTagNV", "GL_NV_query_resource_tag", glDeleteQueryResourceTagNV },
  { "glDeleteRenderbuffers", "GL_ARB_framebuffer_object GL_VERSION_3_0", glDeleteRenderbuffers },
  { "glDeleteRenderbuffersEXT", "GL_EXT_framebuffer_object", glDeleteRenderbuffersEXT },
  { "glDeleteSamplers", "GL_ARB_sampler_objects GL_VERSION_3_3", glDeleteSamplers },
  { "glDeleteSemaphoresEXT", "GL_EXT_semaphore", glDeleteSemaphoresEXT },
  { "glDeleteShader", "GL_VERSION_2_0", glDeleteShader },
  { "glDeleteStatesNV", "GL_NV_command_list", glDeleteStatesNV },
  { "glDeleteSync", "GL_ARB_sync GL_VERSION_3_2", glDeleteSync },
  { "glDeleteTexturesEXT", "GL_EXT_texture_object", glDeleteTexturesEXT },
  { "glDeleteTransformFeedbacks", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glDeleteTransformFeedbacks },
  { "glDeleteTransformFeedbacksNV", "GL_NV_transform_feedback2", glDeleteTransformFeedbacksNV },
  { "glDeleteVertexArrays", "GL_ARB_vertex_array_object GL_VERSION_3_0", glDeleteVertexArrays },
  { "glDeleteVertexArraysAPPLE", "GL_APPLE_vertex_array_object", glDeleteVertexArraysAPPLE },
  { "glDeleteVertexShaderEXT", "GL_EXT_vertex_shader", glDeleteVertexShaderEXT },
  { "glDepthBoundsEXT", "GL_EXT_depth_bounds_test", glDepthBoundsEXT },
  { "glDepthBoundsdNV", "GL_NV_depth_buffer_float", glDepthBoundsdNV },
  { "glDepthRangeArraydvNV", "GL_ARB_viewport_array", glDepthRangeArraydvNV },
  { "glDepthRangeArrayv", "GL_ARB_viewport_array GL_VERSION_4_1", glDepthRangeArrayv },
  { "glDepthRangeIndexed", "GL_ARB_viewport_array GL_VERSION_4_1", glDepthRangeIndexed },
  { "glDepthRangeIndexeddNV", "GL_ARB_viewport_array", glDepthRangeIndexeddNV },
  { "glDepthRangedNV", "GL_NV_depth_buffer_float", glDepthRangedNV },
  { "glDepthRangef", "GL_ARB_ES2_compatibility GL_VERSION_4_1", glDepthRangef },
  { "glDepthRangefOES", "GL_OES_single_precision", glDepthRangefOES },
  { "glDepthRangexOES", "GL_OES_fixed_point", glDepthRangexOES },
  { "glDetachObjectARB", "GL_ARB_shader_objects", glDetachObjectARB },
  { "glDetachShader", "GL_VERSION_2_0", glDetachShader },
  { "glDetailTexFuncSGIS", "GL_SGIS_detail_texture", glDetailTexFuncSGIS },
  { "glDisableClientStateIndexedEXT", "GL_EXT_direct_state_access", glDisableClientStateIndexedEXT },
  { "glDisableClientStateiEXT", "GL_EXT_direct_state_access", glDisableClientStateiEXT },
  { "glDisableIndexedEXT", "GL_EXT_direct_state_access GL_EXT_draw_buffers2", glDisableIndexedEXT },
  { "glDisableVariantClientStateEXT", "GL_EXT_vertex_shader", glDisableVariantClientStateEXT },
  { "glDisableVertexArrayAttrib", "GL_ARB_direct_state_access GL_VERSION_4_5", glDisableVertexArrayAttrib },
  { "glDisableVertexArrayAttribEXT", "GL_EXT_direct_state_access", glDisableVertexArrayAttribEXT },
  { "glDisableVertexArrayEXT", "GL_EXT_direct_state_access", glDisableVertexArrayEXT },
  { "glDisableVertexAttribAPPLE", "GL_APPLE_vertex_program_evaluators", glDisableVertexAttribAPPLE },
  { "glDisableVertexAttribArray", "GL_VERSION_2_0", glDisableVertexAttribArray },
  { "glDisableVertexAttribArrayARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glDisableVertexAttribArrayARB },
  { "glDisablei", "GL_VERSION_3_0", glDisablei },
  { "glDispatchCompute", "GL_ARB_compute_shader GL_VERSION_4_3", glDispatchCompute },
  { "glDispatchComputeGroupSizeARB", "GL_ARB_compute_variable_group_size", glDispatchComputeGroupSizeARB },
  { "glDispatchComputeIndirect", "GL_ARB_compute_shader GL_VERSION_4_3", glDispatchComputeIndirect },
  { "glDrawArraysEXT", "GL_EXT_vertex_array", glDrawArraysEXT },
  { "glDrawArraysIndirect", "GL_ARB_draw_indirect GL_VERSION_4_0", glDrawArraysIndirect },
  { "glDrawArraysInstanced", "GL_VERSION_3_1", glDrawArraysInstanced },
  { "glDrawArraysInstancedARB", "GL_ARB_draw_instanced", glDrawArraysInstancedARB },
  { "glDrawArraysInstancedBaseInstance", "GL_ARB_base_instance GL_VERSION_4_2", glDrawArraysInstancedBaseInstance },
  { "glDrawArraysInstancedEXT", "GL_EXT_draw_instanced", glDrawArraysInstancedEXT },
  { "glDrawBufferRegion", "GL_KTX_buffer_region", glDrawBufferRegion },
  { "glDrawBuffers", "GL_VERSION_2_0", glDrawBuffers },
  { "glDrawBuffersARB", "GL_ARB_draw_buffers", glDrawBuffersARB },
  { "glDrawBuffersATI", "GL_ATI_draw_buffers", glDrawBuffersATI },
  { "glDrawCommandsAddressNV", "GL_NV_command_list", glDrawCommandsAddressNV },
  { "glDrawCommandsNV", "GL_NV_command_list", glDrawCommandsNV },
  { "glDrawCommandsStatesAddressNV", "GL_NV_command_list", glDrawCommandsStatesAddressNV },
  { "glDrawCommandsStatesNV", "GL_NV_command_list", glDrawCommandsStatesNV },
  { "glDrawElementArrayAPPLE", "GL_APPLE_element_array", glDrawElementArrayAPPLE },
  { "glDrawElementArrayATI", "GL_ATI_element_array", glDrawElementArrayATI },
  { "glDrawElementsBaseVertex", "GL_ARB_draw_elements_base_vertex GL_VERSION_3_2", glDrawElementsBaseVertex },
  { "glDrawElementsIndirect", "GL_ARB_draw_indirect GL_VERSION_4_0", glDrawElementsIndirect },
  { "glDrawElementsInstanced", "GL_VERSION_3_1", glDrawElementsInstanced },
  { "glDrawElementsInstancedARB", "GL_ARB_draw_instanced", glDrawElementsInstancedARB },
  { "glDrawElementsInstancedBaseInstance", "GL_ARB_base_instance GL_VERSION_4_2", glDrawElementsInstancedBaseInstance },
  { "glDrawElementsInstancedBaseVertex", "GL_ARB_draw_elements_base_vertex GL_VERSION_3_2", glDrawElementsInstancedBaseVertex },
  { "glDrawElementsInstancedBaseVertexBaseInstance", "GL_ARB_base_instance GL_VERSION_4_2", glDrawElementsInstancedBaseVertexBaseInstance },
  { "glDrawElementsInstancedEXT", "GL_EXT_draw_instanced", glDrawElementsInstancedEXT },
  { "glDrawMeshArraysSUN", "GL_SUN_mesh_array", glDrawMeshArraysSUN },
  { "glDrawMeshTasksIndirectNV", "GL_NV_mesh_shader", glDrawMeshTasksIndirectNV },
  { "glDrawMeshTasksNV", "GL_NV_mesh_shader", glDrawMeshTasksNV },
  { "glDrawRangeElementArrayAPPLE", "GL_APPLE_element_array", glDrawRangeElementArrayAPPLE },
  { "glDrawRangeElementArrayATI", "GL_ATI_element_array", glDrawRangeElementArrayATI },
  { "glDrawRangeElements", "GL_VERSION_1_2", glDrawRangeElements },
  { "glDrawRangeElementsBaseVertex", "GL_ARB_draw_elements_base_vertex GL_VERSION_3_2", glDrawRangeElementsBaseVertex },
  { "glDrawRangeElementsEXT", "GL_EXT_draw_range_elements", glDrawRangeElementsEXT },
  { "glDrawTextureNV", "GL_NV_draw_texture", glDrawTextureNV },
  { "glDrawTransformFeedback", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glDrawTransformFeedback },
  { "glDrawTransformFeedbackInstanced", "GL_ARB_transform_feedback_instanced GL_VERSION_4_2", glDrawTransformFeedbackInstanced },
  { "glDrawTransformFeedbackNV", "GL_NV_transform_feedback2", glDrawTransformFeedbackNV },
  { "glDrawTransformFeedbackStream", "GL_ARB_transform_feedback3 GL_VERSION_4_0", glDrawTransformFeedbackStream },
  { "glDrawTransformFeedbackStreamInstanced", "GL_ARB_transform_feedback_instanced GL_VERSION_4_2", glDrawTransformFeedbackStreamInstanced },
  { "glDrawVkImageNV", "GL_NV_draw_vulkan_image", glDrawVkImageNV },
  { "glEGLImageTargetTexStorageEXT", "GL_EXT_EGL_image_storage", glEGLImageTargetTexStorageEXT },
  { "glEGLImageTargetTextureStorageEXT", "GL_EXT_EGL_image_storage", glEGLImageTargetTextureStorageEXT },
  { "glEdgeFlagFormatNV", "GL_NV_vertex_buffer_unified_memory", glEdgeFlagFormatNV },
  { "glEdgeFlagPointerEXT", "GL_EXT_vertex_array", glEdgeFlagPointerEXT },
  { "glEdgeFlagPointerListIBM", "GL_IBM_vertex_array_lists", glEdgeFlagPointerListIBM },
  { "glElementPointerAPPLE", "GL_APPLE_element_array", glElementPointerAPPLE },
  { "glElementPointerATI", "GL_ATI_element_array", glElementPointerATI },
  { "glEnableClientStateIndexedEXT", "GL_EXT_direct_state_access", glEnableClientStateIndexedEXT },
  { "glEnableClientStateiEXT", "GL_EXT_direct_state_access", glEnableClientStateiEXT },
  { "glEnableIndexedEXT", "GL_EXT_direct_state_access GL_EXT_draw_buffers2", glEnableIndexedEXT },
  { "glEnableVariantClientStateEXT", "GL_EXT_vertex_shader", glEnableVariantClientStateEXT },
  { "glEnableVertexArrayAttrib", "GL_ARB_direct_state_access GL_VERSION_4_5", glEnableVertexArrayAttrib },
  { "glEnableVertexArrayAttribEXT", "GL_EXT_direct_state_access", glEnableVertexArrayAttribEXT },
  { "glEnableVertexArrayEXT", "GL_EXT_direct_state_access", glEnableVertexArrayEXT },
  { "glEnableVertexAttribAPPLE", "GL_APPLE_vertex_program_evaluators", glEnableVertexAttribAPPLE },
  { "glEnableVertexAttribArray", "GL_VERSION_2_0", glEnableVertexAttribArray },
  { "glEnableVertexAttribArrayARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glEnableVertexAttribArrayARB },
  { "glEnablei", "GL_VERSION_3_0", glEnablei },
  { "glEndConditionalRender", "GL_VERSION_3_0", glEndConditionalRender },
  { "glEndConditionalRenderNV", "GL_NV_conditional_render", glEndConditionalRenderNV },
  { "glEndConditionalRenderNVX", "GL_NVX_conditional_render", glEndConditionalRenderNVX },
  { "glEndFragmentShaderATI", "GL_ATI_fragment_shader", glEndFragmentShaderATI },
  { "glEndOcclusionQueryNV", "GL_NV_occlusion_query", glEndOcclusionQueryNV },
  { "glEndPerfMonitorAMD", "GL_AMD_performance_monitor", glEndPerfMonitorAMD },
  { "glEndPerfQueryINTEL", "GL_INTEL_performance_query", glEndPerfQueryINTEL },
  { "glEndQuery", "GL_VERSION_1_5", glEndQuery },
  { "glEndQueryARB", "GL_ARB_occlusion_query", glEndQueryARB },
  { "glEndQueryIndexed", "GL_ARB_transform_feedback3 GL_VERSION_4_0", glEndQueryIndexed },
  { "glEndTransformFeedback", "GL_VERSION_3_0", glEndTransformFeedback },
  { "glEndTransformFeedbackEXT", "GL_EXT_transform_feedback", glEndTransformFeedbackEXT },
  { "glEndTransformFeedbackNV", "GL_NV_transform_feedback", glEndTransformFeedbackNV },
  { "glEndVertexShaderEXT", "GL_EXT_vertex_shader", glEndVertexShaderEXT },
  { "glEndVideoCaptureNV", "GL_NV_video_capture", glEndVideoCaptureNV },
  { "glEvalCoord1xOES", "GL_OES_fixed_point", glEvalCoord1xOES },
  { "glEvalCoord1xvOES", "GL_OES_fixed_point", glEvalCoord1xvOES },
  { "glEvalCoord2xOES", "GL_OES_fixed_point", glEvalCoord2xOES },
  { "glEvalCoord2xvOES", "GL_OES_fixed_point", glEvalCoord2xvOES },
  { "glEvalMapsNV", "GL_NV_evaluators", glEvalMapsNV },
  { "glEvaluateDepthValuesARB", "GL_ARB_sample_locations", glEvaluateDepthValuesARB },
  { "glExecuteProgramNV", "GL_NV_vertex_program", glExecuteProgramNV },
  { "glExtractComponentEXT", "GL_EXT_vertex_shader", glExtractComponentEXT },
  { "glFeedbackBufferxOES", "GL_OES_fixed_point", glFeedbackBufferxOES },
  { "glFenceSync", "GL_ARB_sync GL_VERSION_3_2", glFenceSync },
  { "glFinalCombinerInputNV", "GL_NV_register_combiners", glFinalCombinerInputNV },
  { "glFinishAsyncSGIX", "GL_SGIX_async", glFinishAsyncSGIX },
  { "glFinishFenceAPPLE", "GL_APPLE_fence", glFinishFenceAPPLE },
  { "glFinishFenceNV", "GL_NV_fence", glFinishFenceNV },
  { "glFinishObjectAPPLE", "GL_APPLE_fence", glFinishObjectAPPLE },
  { "glFinishTextureSUNX", "GL_SUNX_constant_data", glFinishTextureSUNX },
  { "glFlushMappedBufferRange", "GL_ARB_map_buffer_range GL_VERSION_3_0", glFlushMappedBufferRange },
  { "glFlushMappedBufferRangeAPPLE", "GL_APPLE_flush_buffer_range", glFlushMappedBufferRangeAPPLE },
  { "glFlushMappedNamedBufferRange", "GL_ARB_direct_state_access GL_VERSION_4_5", glFlushMappedNamedBufferRange },
  { "glFlushMappedNamedBufferRangeEXT", "GL_EXT_direct_state_access", glFlushMappedNamedBufferRangeEXT },
  { "glFlushPixelDataRangeNV", "GL_NV_pixel_data_range", glFlushPixelDataRangeNV },
  { "glFlushRasterSGIX", "GL_SGIX_flush_raster", glFlushRasterSGIX },
  { "glFlushStaticDataIBM", "GL_IBM_static_data", glFlushStaticDataIBM },
  { "glFlushVertexArrayRangeAPPLE", "GL_APPLE_vertex_array_range", glFlushVertexArrayRangeAPPLE },
  { "glFlushVertexArrayRangeNV", "GL_NV_vertex_array_range", glFlushVertexArrayRangeNV },
  { "glFogCoordFormatNV", "GL_NV_vertex_buffer_unified_memory", glFogCoordFormatNV },
  { "glFogCoordPointer", "GL_VERSION_1_4", glFogCoordPointer },
  { "glFogCoordPointerEXT", "GL_EXT_fog_coord", glFogCoordPointerEXT },
  { "glFogCoordPointerListIBM", "GL_IBM_vertex_array_lists", glFogCoordPointerListIBM },
  { "glFogCoordd", "GL_VERSION_1_4", glFogCoordd },
  { "glFogCoorddEXT", "GL_EXT_fog_coord", glFogCoorddEXT },
  { "glFogCoorddv", "GL_VERSION_1_4", glFogCoorddv },
  { "glFogCoorddvEXT", "GL_EXT_fog_coord", glFogCoorddvEXT },
  { "glFogCoordf", "GL_VERSION_1_4", glFogCoordf },
  { "glFogCoordfEXT", "GL_EXT_fog_coord", glFogCoordfEXT },
  { "glFogCoordfv", "GL_VERSION_1_4", glFogCoordfv },
  { "glFogCoordfvEXT", "GL_EXT_fog_coord", glFogCoordfvEXT },
  { "glFogCoordhNV", "GL_NV_half_float", glFogCoordhNV },
  { "glFogCoordhvNV", "GL_NV_half_float", glFogCoordhvNV },
  { "glFogFuncSGIS", "GL_SGIS_fog_function", glFogFuncSGIS },
  { "glFogxOES", "GL_OES_fixed_point", glFogxOES },
  { "glFogxvOES", "GL_OES_fixed_point", glFogxvOES },
  { "glFragmentColorMaterialSGIX", "GL_SGIX_fragment_lighting", glFragmentColorMaterialSGIX },
  { "glFragmentCoverageColorNV", "GL_NV_fragment_coverage_to_color", glFragmentCoverageColorNV },
  { "glFragmentLightModelfSGIX", "GL_SGIX_fragment_lighting", glFragmentLightModelfSGIX },
  { "glFragmentLightModelfvSGIX", "GL_SGIX_fragment_lighting", glFragmentLightModelfvSGIX },
  { "glFragmentLightModeliSGIX", "GL_SGIX_fragment_lighting", glFragmentLightModeliSGIX },
  { "glFragmentLightModelivSGIX", "GL_SGIX_fragment_lighting", glFragmentLightModelivSGIX },
  { "glFragmentLightfSGIX", "GL_SGIX_fragment_lighting", glFragmentLightfSGIX },
  { "glFragmentLightfvSGIX", "GL_SGIX_fragment_lighting", glFragmentLightfvSGIX },
  { "glFragmentLightiSGIX", "GL_SGIX_fragment_lighting", glFragmentLightiSGIX },
  { "glFragmentLightivSGIX", "GL_SGIX_fragment_lighting", glFragmentLightivSGIX },
  { "glFragmentMaterialfSGIX", "GL_SGIX_fragment_lighting", glFragmentMaterialfSGIX },
  { "glFragmentMaterialfvSGIX", "GL_SGIX_fragment_lighting", glFragmentMaterialfvSGIX },
  { "glFragmentMaterialiSGIX", "GL_SGIX_fragment_lighting", glFragmentMaterialiSGIX },
  { "glFragmentMaterialivSGIX", "GL_SGIX_fragment_lighting", glFragmentMaterialivSGIX },
  { "glFrameTerminatorGREMEDY", "GL_GREMEDY_frame_terminator", glFrameTerminatorGREMEDY },
  { "glFrameZoomSGIX", "GL_SGIX_framezoom", glFrameZoomSGIX },
  { "glFramebufferDrawBufferEXT", "GL_EXT_direct_state_access", glFramebufferDrawBufferEXT },
  { "glFramebufferDrawBuffersEXT", "GL_EXT_direct_state_access", glFramebufferDrawBuffersEXT },
  { "glFramebufferFetchBarrierEXT", "GL_EXT_shader_framebuffer_fetch_non_coherent", glFramebufferFetchBarrierEXT },
  { "glFramebufferParameteri", "GL_ARB_framebuffer_no_attachments GL_VERSION_4_3", glFramebufferParameteri },
  { "glFramebufferParameteriMESA", "GL_MESA_framebuffer_flip_y", glFramebufferParameteriMESA },
  { "glFramebufferReadBufferEXT", "GL_EXT_direct_state_access", glFramebufferReadBufferEXT },
  { "glFramebufferRenderbuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glFramebufferRenderbuffer },
  { "glFramebufferRenderbufferEXT", "GL_EXT_framebuffer_object", glFramebufferRenderbufferEXT },
  { "glFramebufferSampleLocationsfvARB", "GL_ARB_sample_locations", glFramebufferSampleLocationsfvARB },
  { "glFramebufferSampleLocationsfvNV", "GL_NV_sample_locations", glFramebufferSampleLocationsfvNV },
  { "glFramebufferSamplePositionsfvAMD", "GL_AMD_framebuffer_sample_positions", glFramebufferSamplePositionsfvAMD },
  { "glFramebufferTexture", "GL_VERSION_3_2", glFramebufferTexture },
  { "glFramebufferTexture1D", "GL_ARB_framebuffer_object GL_VERSION_3_0", glFramebufferTexture1D },
  { "glFramebufferTexture1DEXT", "GL_EXT_framebuffer_object", glFramebufferTexture1DEXT },
  { "glFramebufferTexture2D", "GL_ARB_framebuffer_object GL_VERSION_3_0", glFramebufferTexture2D },
  { "glFramebufferTexture2DEXT", "GL_EXT_framebuffer_object", glFramebufferTexture2DEXT },
  { "glFramebufferTexture3D", "GL_ARB_framebuffer_object GL_VERSION_3_0", glFramebufferTexture3D },
  { "glFramebufferTexture3DEXT", "GL_EXT_framebuffer_object", glFramebufferTexture3DEXT },
  { "glFramebufferTextureARB", "GL_ARB_geometry_shader4", glFramebufferTextureARB },
  { "glFramebufferTextureEXT", "GL_NV_geometry_program4", glFramebufferTextureEXT },
  { "glFramebufferTextureFaceARB", "GL_ARB_geometry_shader4", glFramebufferTextureFaceARB },
  { "glFramebufferTextureFaceEXT", "GL_NV_geometry_program4", glFramebufferTextureFaceEXT },
  { "glFramebufferTextureLayer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glFramebufferTextureLayer },
  { "glFramebufferTextureLayerARB", "GL_ARB_geometry_shader4", glFramebufferTextureLayerARB },
  { "glFramebufferTextureLayerEXT", "GL_EXT_texture_array GL_NV_geometry_program4", glFramebufferTextureLayerEXT },
  { "glFramebufferTextureMultiviewOVR", "GL_OVR_multiview", glFramebufferTextureMultiviewOVR },
  { "glFreeObjectBufferATI", "GL_ATI_vertex_array_object", glFreeObjectBufferATI },
  { "glFrustumfOES", "GL_OES_single_precision", glFrustumfOES },
  { "glFrustumxOES", "GL_OES_fixed_point", glFrustumxOES },
  { "glGenAsyncMarkersSGIX", "GL_SGIX_async", glGenAsyncMarkersSGIX },
  { "glGenBuffers", "GL_VERSION_1_5", glGenBuffers },
  { "glGenBuffersARB", "GL_ARB_vertex_buffer_object", glGenBuffersARB },
  { "glGenFencesAPPLE", "GL_APPLE_fence", glGenFencesAPPLE },
  { "glGenFencesNV", "GL_NV_fence", glGenFencesNV },
  { "glGenFragmentShadersATI", "GL_ATI_fragment_shader", glGenFragmentShadersATI },
  { "glGenFramebuffers", "GL_ARB_framebuffer_object GL_VERSION_3_0", glGenFramebuffers },
  { "glGenFramebuffersEXT", "GL_EXT_framebuffer_object", glGenFramebuffersEXT },
  { "glGenNamesAMD", "GL_AMD_name_gen_delete", glGenNamesAMD },
  { "glGenOcclusionQueriesNV", "GL_NV_occlusion_query", glGenOcclusionQueriesNV },
  { "glGenPathsNV", "GL_NV_path_rendering", glGenPathsNV },
  { "glGenPerfMonitorsAMD", "GL_AMD_performance_monitor", glGenPerfMonitorsAMD },
  { "glGenProgramPipelines", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glGenProgramPipelines },
  { "glGenProgramsARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGenProgramsARB },
  { "glGenProgramsNV", "GL_NV_vertex_program", glGenProgramsNV },
  { "glGenQueries", "GL_VERSION_1_5", glGenQueries },
  { "glGenQueriesARB", "GL_ARB_occlusion_query", glGenQueriesARB },
  { "glGenQueryResourceTagNV", "GL_NV_query_resource_tag", glGenQueryResourceTagNV },
  { "glGenRenderbuffers", "GL_ARB_framebuffer_object GL_VERSION_3_0", glGenRenderbuffers },
  { "glGenRenderbuffersEXT", "GL_EXT_framebuffer_object", glGenRenderbuffersEXT },
  { "glGenSamplers", "GL_ARB_sampler_objects GL_VERSION_3_3", glGenSamplers },
  { "glGenSemaphoresEXT", "GL_EXT_semaphore", glGenSemaphoresEXT },
  { "glGenSymbolsEXT", "GL_EXT_vertex_shader", glGenSymbolsEXT },
  { "glGenTexturesEXT", "GL_EXT_texture_object", glGenTexturesEXT },
  { "glGenTransformFeedbacks", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glGenTransformFeedbacks },
  { "glGenTransformFeedbacksNV", "GL_NV_transform_feedback2", glGenTransformFeedbacksNV },
  { "glGenVertexArrays", "GL_ARB_vertex_array_object GL_VERSION_3_0", glGenVertexArrays },
  { "glGenVertexArraysAPPLE", "GL_APPLE_vertex_array_object", glGenVertexArraysAPPLE },
  { "glGenVertexShadersEXT", "GL_EXT_vertex_shader", glGenVertexShadersEXT },
  { "glGenerateMipmap", "GL_ARB_framebuffer_object GL_VERSION_3_0", glGenerateMipmap },
  { "glGenerateMipmapEXT", "GL_EXT_framebuffer_object", glGenerateMipmapEXT },
  { "glGenerateMultiTexMipmapEXT", "GL_EXT_direct_state_access", glGenerateMultiTexMipmapEXT },
  { "glGenerateTextureMipmap", "GL_ARB_direct_state_access GL_VERSION_4_5", glGenerateTextureMipmap },
  { "glGenerateTextureMipmapEXT", "GL_EXT_direct_state_access", glGenerateTextureMipmapEXT },
  { "glGetActiveAtomicCounterBufferiv", "GL_ARB_shader_atomic_counters GL_VERSION_4_2", glGetActiveAtomicCounterBufferiv },
  { "glGetActiveAttrib", "GL_VERSION_2_0", glGetActiveAttrib },
  { "glGetActiveAttribARB", "GL_ARB_vertex_shader", glGetActiveAttribARB },
  { "glGetActiveSubroutineName", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetActiveSubroutineName },
  { "glGetActiveSubroutineUniformName", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetActiveSubroutineUniformName },
  { "glGetActiveSubroutineUniformiv", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetActiveSubroutineUniformiv },
  { "glGetActiveUniform", "GL_VERSION_2_0", glGetActiveUniform },
  { "glGetActiveUniformARB", "GL_ARB_shader_objects", glGetActiveUniformARB },
  { "glGetActiveUniformBlockName", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetActiveUniformBlockName },
  { "glGetActiveUniformBlockiv", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetActiveUniformBlockiv },
  { "glGetActiveUniformName", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetActiveUniformName },
  { "glGetActiveUniformsiv", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetActiveUniformsiv },
  { "glGetActiveVaryingNV", "GL_NV_transform_feedback", glGetActiveVaryingNV },
  { "glGetArrayObjectfvATI", "GL_ATI_vertex_array_object", glGetArrayObjectfvATI },
  { "glGetArrayObjectivATI", "GL_ATI_vertex_array_object", glGetArrayObjectivATI },
  { "glGetAttachedObjectsARB", "GL_ARB_shader_objects", glGetAttachedObjectsARB },
  { "glGetAttachedShaders", "GL_VERSION_2_0", glGetAttachedShaders },
  { "glGetAttribLocation", "GL_VERSION_2_0", glGetAttribLocation },
  { "glGetAttribLocationARB", "GL_ARB_vertex_shader", glGetAttribLocationARB },
  { "glGetBooleanIndexedvEXT", "GL_EXT_direct_state_access GL_EXT_draw_buffers2", glGetBooleanIndexedvEXT },
  { "glGetBooleani_v", "GL_VERSION_3_0", glGetBooleani_v },
  { "glGetBufferParameteri64v", "GL_VERSION_3_2", glGetBufferParameteri64v },
  { "glGetBufferParameteriv", "GL_VERSION_1_5", glGetBufferParameteriv },
  { "glGetBufferParameterivARB", "GL_ARB_vertex_buffer_object", glGetBufferParameterivARB },
  { "glGetBufferParameterui64vNV", "GL_NV_shader_buffer_load", glGetBufferParameterui64vNV },
  { "glGetBufferPointerv", "GL_VERSION_1_5", glGetBufferPointerv },
  { "glGetBufferPointervARB", "GL_ARB_vertex_buffer_object", glGetBufferPointervARB },
  { "glGetBufferSubData", "GL_VERSION_1_5", glGetBufferSubData },
  { "glGetBufferSubDataARB", "GL_ARB_vertex_buffer_object", glGetBufferSubDataARB },
  { "glGetClipPlanefOES", "GL_OES_single_precision", glGetClipPlanefOES },
  { "glGetClipPlanexOES", "GL_OES_fixed_point", glGetClipPlanexOES },
  { "glGetColorTable", "GL_ARB_imaging", glGetColorTable },
  { "glGetColorTableEXT", "GL_EXT_paletted_texture", glGetColorTableEXT },
  { "glGetColorTableParameterfv", "GL_ARB_imaging", glGetColorTableParameterfv },
  { "glGetColorTableParameterfvEXT", "GL_EXT_paletted_texture", glGetColorTableParameterfvEXT },
  { "glGetColorTableParameterfvSGI", "GL_SGI_color_table", glGetColorTableParameterfvSGI },
  { "glGetColorTableParameteriv", "GL_ARB_imaging", glGetColorTableParameteriv },
  { "glGetColorTableParameterivEXT", "GL_EXT_paletted_texture", glGetColorTableParameterivEXT },
  { "glGetColorTableParameterivSGI", "GL_SGI_color_table", glGetColorTableParameterivSGI },
  { "glGetColorTableSGI", "GL_SGI_color_table", glGetColorTableSGI },
  { "glGetCombinerInputParameterfvNV", "GL_NV_register_combiners", glGetCombinerInputParameterfvNV },
  { "glGetCombinerInputParameterivNV", "GL_NV_register_combiners", glGetCombinerInputParameterivNV },
  { "glGetCombinerOutputParameterfvNV", "GL_NV_register_combiners", glGetCombinerOutputParameterfvNV },
  { "glGetCombinerOutputParameterivNV", "GL_NV_register_combiners", glGetCombinerOutputParameterivNV },
  { "glGetCombinerStageParameterfvNV", "GL_NV_register_combiners2", glGetCombinerStageParameterfvNV },
  { "glGetCommandHeaderNV", "GL_NV_command_list", glGetCommandHeaderNV },
  { "glGetCompressedMultiTexImageEXT", "GL_EXT_direct_state_access", glGetCompressedMultiTexImageEXT },
  { "glGetCompressedTexImage", "GL_VERSION_1_3", glGetCompressedTexImage },
  { "glGetCompressedTexImageARB", "GL_ARB_texture_compression", glGetCompressedTexImageARB },
  { "glGetCompressedTextureImage", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetCompressedTextureImage },
  { "glGetCompressedTextureImageEXT", "GL_EXT_direct_state_access", glGetCompressedTextureImageEXT },
  { "glGetCompressedTextureSubImage", "GL_ARB_get_texture_sub_image GL_VERSION_4_5", glGetCompressedTextureSubImage },
  { "glGetConvolutionFilter", "GL_ARB_imaging", glGetConvolutionFilter },
  { "glGetConvolutionFilterEXT", "GL_EXT_convolution", glGetConvolutionFilterEXT },
  { "glGetConvolutionParameterfv", "GL_ARB_imaging", glGetConvolutionParameterfv },
  { "glGetConvolutionParameterfvEXT", "GL_EXT_convolution", glGetConvolutionParameterfvEXT },
  { "glGetConvolutionParameteriv", "GL_ARB_imaging", glGetConvolutionParameteriv },
  { "glGetConvolutionParameterivEXT", "GL_EXT_convolution", glGetConvolutionParameterivEXT },
  { "glGetConvolutionParameterxvOES", "GL_OES_fixed_point", glGetConvolutionParameterxvOES },
  { "glGetCoverageModulationTableNV", "GL_NV_framebuffer_mixed_samples", glGetCoverageModulationTableNV },
  { "glGetDebugMessageLog", "GL_KHR_debug GL_VERSION_4_3", glGetDebugMessageLog },
  { "glGetDebugMessageLogAMD", "GL_AMD_debug_output", glGetDebugMessageLogAMD },
  { "glGetDebugMessageLogARB", "GL_ARB_debug_output", glGetDebugMessageLogARB },
  { "glGetDetailTexFuncSGIS", "GL_SGIS_detail_texture", glGetDetailTexFuncSGIS },
  { "glGetDoubleIndexedvEXT", "GL_EXT_direct_state_access", glGetDoubleIndexedvEXT },
  { "glGetDoublei_v", "GL_ARB_viewport_array GL_VERSION_4_1", glGetDoublei_v },
  { "glGetDoublei_vEXT", "GL_EXT_direct_state_access", glGetDoublei_vEXT },
  { "glGetFenceivNV", "GL_NV_fence", glGetFenceivNV },
  { "glGetFinalCombinerInputParameterfvNV", "GL_NV_register_combiners", glGetFinalCombinerInputParameterfvNV },
  { "glGetFinalCombinerInputParameterivNV", "GL_NV_register_combiners", glGetFinalCombinerInputParameterivNV },
  { "glGetFirstPerfQueryIdINTEL", "GL_INTEL_performance_query", glGetFirstPerfQueryIdINTEL },
  { "glGetFixedvOES", "GL_OES_fixed_point", glGetFixedvOES },
  { "glGetFloatIndexedvEXT", "GL_EXT_direct_state_access", glGetFloatIndexedvEXT },
  { "glGetFloati_v", "GL_ARB_viewport_array GL_VERSION_4_1", glGetFloati_v },
  { "glGetFloati_vEXT", "GL_EXT_direct_state_access", glGetFloati_vEXT },
  { "glGetFogFuncSGIS", "GL_SGIS_fog_function", glGetFogFuncSGIS },
  { "glGetFragDataIndex", "GL_ARB_blend_func_extended GL_VERSION_3_3", glGetFragDataIndex },
  { "glGetFragDataLocation", "GL_VERSION_3_0", glGetFragDataLocation },
  { "glGetFragDataLocationEXT", "GL_EXT_gpu_shader4", glGetFragDataLocationEXT },
  { "glGetFragmentLightfvSGIX", "GL_SGIX_fragment_lighting", glGetFragmentLightfvSGIX },
  { "glGetFragmentLightivSGIX", "GL_SGIX_fragment_lighting", glGetFragmentLightivSGIX },
  { "glGetFragmentMaterialfvSGIX", "GL_SGIX_fragment_lighting", glGetFragmentMaterialfvSGIX },
  { "glGetFragmentMaterialivSGIX", "GL_SGIX_fragment_lighting", glGetFragmentMaterialivSGIX },
  { "glGetFramebufferAttachmentParameteriv", "GL_ARB_framebuffer_object GL_VERSION_3_0", glGetFramebufferAttachmentParameteriv },
  { "glGetFramebufferAttachmentParameterivEXT", "GL_EXT_framebuffer_object", glGetFramebufferAttachmentParameterivEXT },
  { "glGetFramebufferParameterfvAMD", "GL_AMD_framebuffer_sample_positions", glGetFramebufferParameterfvAMD },
  { "glGetFramebufferParameteriv", "GL_ARB_framebuffer_no_attachments GL_VERSION_4_3", glGetFramebufferParameteriv },
  { "glGetFramebufferParameterivEXT", "GL_EXT_direct_state_access", glGetFramebufferParameterivEXT },
  { "glGetFramebufferParameterivMESA", "GL_MESA_framebuffer_flip_y", glGetFramebufferParameterivMESA },
  { "glGetGraphicsResetStatus", "GL_KHR_robustness GL_VERSION_4_5", glGetGraphicsResetStatus },
  { "glGetGraphicsResetStatusARB", "GL_ARB_robustness", glGetGraphicsResetStatusARB },
  { "glGetHandleARB", "GL_ARB_shader_objects", glGetHandleARB },
  { "glGetHistogram", "GL_ARB_imaging", glGetHistogram },
  { "glGetHistogramEXT", "GL_EXT_histogram", glGetHistogramEXT },
  { "glGetHistogramParameterfv", "GL_ARB_imaging", glGetHistogramParameterfv },
  { "glGetHistogramParameterfvEXT", "GL_EXT_histogram", glGetHistogramParameterfvEXT },
  { "glGetHistogramParameteriv", "GL_ARB_imaging", glGetHistogramParameteriv },
  { "glGetHistogramParameterivEXT", "GL_EXT_histogram", glGetHistogramParameterivEXT },
  { "glGetHistogramParameterxvOES", "GL_OES_fixed_point", glGetHistogramParameterxvOES },
  { "glGetImageHandleARB", "GL_ARB_bindless_texture", glGetImageHandleARB },
  { "glGetImageHandleNV", "GL_NV_bindless_texture", glGetImageHandleNV },
  { "glGetImageTransformParameterfvHP", "GL_HP_image_transform", glGetImageTransformParameterfvHP },
  { "glGetImageTransformParameterivHP", "GL_HP_image_transform", glGetImageTransformParameterivHP },
  { "glGetInfoLogARB", "GL_ARB_shader_objects", glGetInfoLogARB },
  { "glGetInstrumentsSGIX", "GL_SGIX_instruments", glGetInstrumentsSGIX },
  { "glGetInteger64i_v", "GL_VERSION_3_2", glGetInteger64i_v },
  { "glGetInteger64v", "GL_ARB_sync GL_VERSION_3_2", glGetInteger64v },
  { "glGetIntegerIndexedvEXT", "GL_EXT_direct_state_access GL_EXT_draw_buffers2", glGetIntegerIndexedvEXT },
  { "glGetIntegeri_v", "GL_ARB_uniform_buffer_object GL_VERSION_3_0", glGetIntegeri_v },
  { "glGetIntegerui64i_vNV", "GL_NV_vertex_buffer_unified_memory", glGetIntegerui64i_vNV },
  { "glGetIntegerui64vNV", "GL_NV_shader_buffer_load", glGetIntegerui64vNV },
  { "glGetInternalformatSampleivNV", "GL_NV_internalformat_sample_query", glGetInternalformatSampleivNV },
  { "glGetInternalformati64v", "GL_ARB_internalformat_query2 GL_VERSION_4_3", glGetInternalformati64v },
  { "glGetInternalformativ", "GL_ARB_internalformat_query GL_VERSION_4_2", glGetInternalformativ },
  { "glGetInvariantBooleanvEXT", "GL_EXT_vertex_shader", glGetInvariantBooleanvEXT },
  { "glGetInvariantFloatvEXT", "GL_EXT_vertex_shader", glGetInvariantFloatvEXT },
  { "glGetInvariantIntegervEXT", "GL_EXT_vertex_shader", glGetInvariantIntegervEXT },
  { "glGetLightxOES", "GL_OES_fixed_point", glGetLightxOES },
  { "glGetListParameterfvSGIX", "GL_SGIX_list_priority", glGetListParameterfvSGIX },
  { "glGetListParameterivSGIX", "GL_SGIX_list_priority", glGetListParameterivSGIX },
  { "glGetLocalConstantBooleanvEXT", "GL_EXT_vertex_shader", glGetLocalConstantBooleanvEXT },
  { "glGetLocalConstantFloatvEXT", "GL_EXT_vertex_shader", glGetLocalConstantFloatvEXT },
  { "glGetLocalConstantIntegervEXT", "GL_EXT_vertex_shader", glGetLocalConstantIntegervEXT },
  { "glGetMapAttribParameterfvNV", "GL_NV_evaluators", glGetMapAttribParameterfvNV },
  { "glGetMapAttribParameterivNV", "GL_NV_evaluators", glGetMapAttribParameterivNV },
  { "glGetMapControlPointsNV", "GL_NV_evaluators", glGetMapControlPointsNV },
  { "glGetMapParameterfvNV", "GL_NV_evaluators", glGetMapParameterfvNV },
  { "glGetMapParameterivNV", "GL_NV_evaluators", glGetMapParameterivNV },
  { "glGetMapxvOES", "GL_OES_fixed_point", glGetMapxvOES },
  { "glGetMaterialxOES", "GL_OES_fixed_point", glGetMaterialxOES },
  { "glGetMemoryObjectDetachedResourcesuivNV", "GL_NV_memory_attachment", glGetMemoryObjectDetachedResourcesuivNV },
  { "glGetMemoryObjectParameterivEXT", "GL_EXT_memory_object", glGetMemoryObjectParameterivEXT },
  { "glGetMinmax", "GL_ARB_imaging", glGetMinmax },
  { "glGetMinmaxEXT", "GL_EXT_histogram", glGetMinmaxEXT },
  { "glGetMinmaxParameterfv", "GL_ARB_imaging", glGetMinmaxParameterfv },
  { "glGetMinmaxParameterfvEXT", "GL_EXT_histogram", glGetMinmaxParameterfvEXT },
  { "glGetMinmaxParameteriv", "GL_ARB_imaging", glGetMinmaxParameteriv },
  { "glGetMinmaxParameterivEXT", "GL_EXT_histogram", glGetMinmaxParameterivEXT },
  { "glGetMultiTexEnvfvEXT", "GL_EXT_direct_state_access", glGetMultiTexEnvfvEXT },
  { "glGetMultiTexEnvivEXT", "GL_EXT_direct_state_access", glGetMultiTexEnvivEXT },
  { "glGetMultiTexGendvEXT", "GL_EXT_direct_state_access", glGetMultiTexGendvEXT },
  { "glGetMultiTexGenfvEXT", "GL_EXT_direct_state_access", glGetMultiTexGenfvEXT },
  { "glGetMultiTexGenivEXT", "GL_EXT_direct_state_access", glGetMultiTexGenivEXT },
  { "glGetMultiTexImageEXT", "GL_EXT_direct_state_access", glGetMultiTexImageEXT },
  { "glGetMultiTexLevelParameterfvEXT", "GL_EXT_direct_state_access", glGetMultiTexLevelParameterfvEXT },
  { "glGetMultiTexLevelParameterivEXT", "GL_EXT_direct_state_access", glGetMultiTexLevelParameterivEXT },
  { "glGetMultiTexParameterIivEXT", "GL_EXT_direct_state_access", glGetMultiTexParameterIivEXT },
  { "glGetMultiTexParameterIuivEXT", "GL_EXT_direct_state_access", glGetMultiTexParameterIuivEXT },
  { "glGetMultiTexParameterfvEXT", "GL_EXT_direct_state_access", glGetMultiTexParameterfvEXT },
  { "glGetMultiTexParameterivEXT", "GL_EXT_direct_state_access", glGetMultiTexParameterivEXT },
  { "glGetMultisamplefv", "GL_ARB_texture_multisample GL_VERSION_3_2", glGetMultisamplefv },
  { "glGetMultisamplefvNV", "GL_NV_explicit_multisample", glGetMultisamplefvNV },
  { "glGetNamedBufferParameteri64v", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedBufferParameteri64v },
  { "glGetNamedBufferParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedBufferParameteriv },
  { "glGetNamedBufferParameterivEXT", "GL_EXT_direct_state_access", glGetNamedBufferParameterivEXT },
  { "glGetNamedBufferParameterui64vNV", "GL_NV_shader_buffer_load", glGetNamedBufferParameterui64vNV },
  { "glGetNamedBufferPointerv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedBufferPointerv },
  { "glGetNamedBufferPointervEXT", "GL_EXT_direct_state_access", glGetNamedBufferPointervEXT },
  { "glGetNamedBufferSubData", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedBufferSubData },
  { "glGetNamedBufferSubDataEXT", "GL_EXT_direct_state_access", glGetNamedBufferSubDataEXT },
  { "glGetNamedFramebufferAttachmentParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedFramebufferAttachmentParameteriv },
  { "glGetNamedFramebufferAttachmentParameterivEXT", "GL_EXT_direct_state_access", glGetNamedFramebufferAttachmentParameterivEXT },
  { "glGetNamedFramebufferParameterfvAMD", "GL_AMD_framebuffer_sample_positions", glGetNamedFramebufferParameterfvAMD },
  { "glGetNamedFramebufferParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedFramebufferParameteriv },
  { "glGetNamedFramebufferParameterivEXT", "GL_EXT_direct_state_access", glGetNamedFramebufferParameterivEXT },
  { "glGetNamedProgramLocalParameterIivEXT", "GL_EXT_direct_state_access", glGetNamedProgramLocalParameterIivEXT },
  { "glGetNamedProgramLocalParameterIuivEXT", "GL_EXT_direct_state_access", glGetNamedProgramLocalParameterIuivEXT },
  { "glGetNamedProgramLocalParameterdvEXT", "GL_EXT_direct_state_access", glGetNamedProgramLocalParameterdvEXT },
  { "glGetNamedProgramLocalParameterfvEXT", "GL_EXT_direct_state_access", glGetNamedProgramLocalParameterfvEXT },
  { "glGetNamedProgramStringEXT", "GL_EXT_direct_state_access", glGetNamedProgramStringEXT },
  { "glGetNamedProgramivEXT", "GL_EXT_direct_state_access", glGetNamedProgramivEXT },
  { "glGetNamedRenderbufferParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetNamedRenderbufferParameteriv },
  { "glGetNamedRenderbufferParameterivEXT", "GL_EXT_direct_state_access", glGetNamedRenderbufferParameterivEXT },
  { "glGetNamedStringARB", "GL_ARB_shading_language_include", glGetNamedStringARB },
  { "glGetNamedStringivARB", "GL_ARB_shading_language_include", glGetNamedStringivARB },
  { "glGetNextPerfQueryIdINTEL", "GL_INTEL_performance_query", glGetNextPerfQueryIdINTEL },
  { "glGetObjectBufferfvATI", "GL_ATI_vertex_array_object", glGetObjectBufferfvATI },
  { "glGetObjectBufferivATI", "GL_ATI_vertex_array_object", glGetObjectBufferivATI },
  { "glGetObjectLabel", "GL_KHR_debug GL_VERSION_4_3", glGetObjectLabel },
  { "glGetObjectLabelEXT", "GL_EXT_debug_label", glGetObjectLabelEXT },
  { "glGetObjectParameterfvARB", "GL_ARB_shader_objects", glGetObjectParameterfvARB },
  { "glGetObjectParameterivAPPLE", "GL_APPLE_object_purgeable", glGetObjectParameterivAPPLE },
  { "glGetObjectParameterivARB", "GL_ARB_shader_objects", glGetObjectParameterivARB },
  { "glGetObjectPtrLabel", "GL_KHR_debug GL_VERSION_4_3", glGetObjectPtrLabel },
  { "glGetOcclusionQueryivNV", "GL_NV_occlusion_query", glGetOcclusionQueryivNV },
  { "glGetOcclusionQueryuivNV", "GL_NV_occlusion_query", glGetOcclusionQueryuivNV },
  { "glGetPathColorGenfvNV", "GL_NV_path_rendering", glGetPathColorGenfvNV },
  { "glGetPathColorGenivNV", "GL_NV_path_rendering", glGetPathColorGenivNV },
  { "glGetPathCommandsNV", "GL_NV_path_rendering", glGetPathCommandsNV },
  { "glGetPathCoordsNV", "GL_NV_path_rendering", glGetPathCoordsNV },
  { "glGetPathDashArrayNV", "GL_NV_path_rendering", glGetPathDashArrayNV },
  { "glGetPathLengthNV", "GL_NV_path_rendering", glGetPathLengthNV },
  { "glGetPathMetricRangeNV", "GL_NV_path_rendering", glGetPathMetricRangeNV },
  { "glGetPathMetricsNV", "GL_NV_path_rendering", glGetPathMetricsNV },
  { "glGetPathParameterfvNV", "GL_NV_path_rendering", glGetPathParameterfvNV },
  { "glGetPathParameterivNV", "GL_NV_path_rendering", glGetPathParameterivNV },
  { "glGetPathSpacingNV", "GL_NV_path_rendering", glGetPathSpacingNV },
  { "glGetPathTexGenfvNV", "GL_NV_path_rendering", glGetPathTexGenfvNV },
  { "glGetPathTexGenivNV", "GL_NV_path_rendering", glGetPathTexGenivNV },
  { "glGetPerfCounterInfoINTEL", "GL_INTEL_performance_query", glGetPerfCounterInfoINTEL },
  { "glGetPerfMonitorCounterDataAMD", "GL_AMD_performance_monitor", glGetPerfMonitorCounterDataAMD },
  { "glGetPerfMonitorCounterInfoAMD", "GL_AMD_performance_monitor", glGetPerfMonitorCounterInfoAMD },
  { "glGetPerfMonitorCounterStringAMD", "GL_AMD_performance_monitor", glGetPerfMonitorCounterStringAMD },
  { "glGetPerfMonitorCountersAMD", "GL_AMD_performance_monitor", glGetPerfMonitorCountersAMD },
  { "glGetPerfMonitorGroupStringAMD", "GL_AMD_performance_monitor", glGetPerfMonitorGroupStringAMD },
  { "glGetPerfMonitorGroupsAMD", "GL_AMD_performance_monitor", glGetPerfMonitorGroupsAMD },
  { "glGetPerfQueryDataINTEL", "GL_INTEL_performance_query", glGetPerfQueryDataINTEL },
  { "glGetPerfQueryIdByNameINTEL", "GL_INTEL_performance_query", glGetPerfQueryIdByNameINTEL },
  { "glGetPerfQueryInfoINTEL", "GL_INTEL_performance_query", glGetPerfQueryInfoINTEL },
  { "glGetPixelMapxv", "GL_OES_fixed_point", glGetPixelMapxv },
  { "glGetPixelTexGenParameterfvSGIS", "GL_SGIS_pixel_texture", glGetPixelTexGenParameterfvSGIS },
  { "glGetPixelTexGenParameterivSGIS", "GL_SGIS_pixel_texture", glGetPixelTexGenParameterivSGIS },
  { "glGetPixelTransformParameterfvEXT", "GL_EXT_pixel_transform", glGetPixelTransformParameterfvEXT },
  { "glGetPixelTransformParameterivEXT", "GL_EXT_pixel_transform", glGetPixelTransformParameterivEXT },
  { "glGetPointerIndexedvEXT", "GL_EXT_direct_state_access", glGetPointerIndexedvEXT },
  { "glGetPointeri_vEXT", "GL_EXT_direct_state_access", glGetPointeri_vEXT },
  { "glGetPointervEXT", "GL_EXT_vertex_array", glGetPointervEXT },
  { "glGetProgramBinary", "GL_ARB_get_program_binary GL_VERSION_4_1", glGetProgramBinary },
  { "glGetProgramEnvParameterIivNV", "GL_NV_gpu_program4", glGetProgramEnvParameterIivNV },
  { "glGetProgramEnvParameterIuivNV", "GL_NV_gpu_program4", glGetProgramEnvParameterIuivNV },
  { "glGetProgramEnvParameterdvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramEnvParameterdvARB },
  { "glGetProgramEnvParameterfvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramEnvParameterfvARB },
  { "glGetProgramInfoLog", "GL_VERSION_2_0", glGetProgramInfoLog },
  { "glGetProgramInterfaceiv", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramInterfaceiv },
  { "glGetProgramLocalParameterIivNV", "GL_NV_gpu_program4", glGetProgramLocalParameterIivNV },
  { "glGetProgramLocalParameterIuivNV", "GL_NV_gpu_program4", glGetProgramLocalParameterIuivNV },
  { "glGetProgramLocalParameterdvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramLocalParameterdvARB },
  { "glGetProgramLocalParameterfvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramLocalParameterfvARB },
  { "glGetProgramNamedParameterdvNV", "GL_NV_fragment_program", glGetProgramNamedParameterdvNV },
  { "glGetProgramNamedParameterfvNV", "GL_NV_fragment_program", glGetProgramNamedParameterfvNV },
  { "glGetProgramParameterdvNV", "GL_NV_vertex_program", glGetProgramParameterdvNV },
  { "glGetProgramParameterfvNV", "GL_NV_vertex_program", glGetProgramParameterfvNV },
  { "glGetProgramPipelineInfoLog", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glGetProgramPipelineInfoLog },
  { "glGetProgramPipelineiv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glGetProgramPipelineiv },
  { "glGetProgramResourceIndex", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramResourceIndex },
  { "glGetProgramResourceLocation", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramResourceLocation },
  { "glGetProgramResourceLocationIndex", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramResourceLocationIndex },
  { "glGetProgramResourceName", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramResourceName },
  { "glGetProgramResourcefvNV", "GL_NV_path_rendering", glGetProgramResourcefvNV },
  { "glGetProgramResourceiv", "GL_ARB_program_interface_query GL_VERSION_4_3", glGetProgramResourceiv },
  { "glGetProgramStageiv", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetProgramStageiv },
  { "glGetProgramStringARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramStringARB },
  { "glGetProgramStringNV", "GL_NV_vertex_program", glGetProgramStringNV },
  { "glGetProgramSubroutineParameteruivNV", "GL_NV_gpu_program5", glGetProgramSubroutineParameteruivNV },
  { "glGetProgramiv", "GL_VERSION_2_0", glGetProgramiv },
  { "glGetProgramivARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glGetProgramivARB },
  { "glGetProgramivNV", "GL_NV_vertex_program", glGetProgramivNV },
  { "glGetQueryBufferObjecti64v", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetQueryBufferObjecti64v },
  { "glGetQueryBufferObjectiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetQueryBufferObjectiv },
  { "glGetQueryBufferObjectui64v", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetQueryBufferObjectui64v },
  { "glGetQueryBufferObjectuiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetQueryBufferObjectuiv },
  { "glGetQueryIndexediv", "GL_ARB_transform_feedback3 GL_VERSION_4_0", glGetQueryIndexediv },
  { "glGetQueryObjecti64v", "GL_ARB_timer_query GL_VERSION_3_3", glGetQueryObjecti64v },
  { "glGetQueryObjecti64vEXT", "GL_EXT_timer_query", glGetQueryObjecti64vEXT },
  { "glGetQueryObjectiv", "GL_VERSION_1_5", glGetQueryObjectiv },
  { "glGetQueryObjectivARB", "GL_ARB_occlusion_query", glGetQueryObjectivARB },
  { "glGetQueryObjectui64v", "GL_ARB_timer_query GL_VERSION_3_3", glGetQueryObjectui64v },
  { "glGetQueryObjectui64vEXT", "GL_EXT_timer_query", glGetQueryObjectui64vEXT },
  { "glGetQueryObjectuiv", "GL_VERSION_1_5", glGetQueryObjectuiv },
  { "glGetQueryObjectuivARB", "GL_ARB_occlusion_query", glGetQueryObjectuivARB },
  { "glGetQueryiv", "GL_VERSION_1_5", glGetQueryiv },
  { "glGetQueryivARB", "GL_ARB_occlusion_query", glGetQueryivARB },
  { "glGetRenderbufferParameteriv", "GL_ARB_framebuffer_object GL_VERSION_3_0", glGetRenderbufferParameteriv },
  { "glGetRenderbufferParameterivEXT", "GL_EXT_framebuffer_object", glGetRenderbufferParameterivEXT },
  { "glGetSamplerParameterIiv", "GL_ARB_sampler_objects GL_VERSION_3_3", glGetSamplerParameterIiv },
  { "glGetSamplerParameterIuiv", "GL_ARB_sampler_objects GL_VERSION_3_3", glGetSamplerParameterIuiv },
  { "glGetSamplerParameterfv", "GL_ARB_sampler_objects GL_VERSION_3_3", glGetSamplerParameterfv },
  { "glGetSamplerParameteriv", "GL_ARB_sampler_objects GL_VERSION_3_3", glGetSamplerParameteriv },
  { "glGetSemaphoreParameterui64vEXT", "GL_EXT_semaphore", glGetSemaphoreParameterui64vEXT },
  { "glGetSeparableFilter", "GL_ARB_imaging", glGetSeparableFilter },
  { "glGetSeparableFilterEXT", "GL_EXT_convolution", glGetSeparableFilterEXT },
  { "glGetShaderInfoLog", "GL_VERSION_2_0", glGetShaderInfoLog },
  { "glGetShaderPrecisionFormat", "GL_ARB_ES2_compatibility GL_VERSION_4_1", glGetShaderPrecisionFormat },
  { "glGetShaderSource", "GL_VERSION_2_0", glGetShaderSource },
  { "glGetShaderSourceARB", "GL_ARB_shader_objects", glGetShaderSourceARB },
  { "glGetShaderiv", "GL_VERSION_2_0", glGetShaderiv },
  { "glGetShadingRateImagePaletteNV", "GL_NV_shading_rate_image", glGetShadingRateImagePaletteNV },
  { "glGetShadingRateSampleLocationivNV", "GL_NV_shading_rate_image", glGetShadingRateSampleLocationivNV },
  { "glGetSharpenTexFuncSGIS", "GL_SGIS_sharpen_texture", glGetSharpenTexFuncSGIS },
  { "glGetStageIndexNV", "GL_NV_command_list", glGetStageIndexNV },
  { "glGetStringi", "GL_VERSION_3_0", glGetStringi },
  { "glGetSubroutineIndex", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetSubroutineIndex },
  { "glGetSubroutineUniformLocation", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetSubroutineUniformLocation },
  { "glGetSynciv", "GL_ARB_sync GL_VERSION_3_2", glGetSynciv },
  { "glGetTexBumpParameterfvATI", "GL_ATI_envmap_bumpmap", glGetTexBumpParameterfvATI },
  { "glGetTexBumpParameterivATI", "GL_ATI_envmap_bumpmap", glGetTexBumpParameterivATI },
  { "glGetTexEnvxvOES", "GL_OES_fixed_point", glGetTexEnvxvOES },
  { "glGetTexFilterFuncSGIS", "GL_SGIS_texture_filter4", glGetTexFilterFuncSGIS },
  { "glGetTexGenxvOES", "GL_OES_fixed_point", glGetTexGenxvOES },
  { "glGetTexLevelParameterxvOES", "GL_OES_fixed_point", glGetTexLevelParameterxvOES },
  { "glGetTexParameterIiv", "GL_VERSION_3_0", glGetTexParameterIiv },
  { "glGetTexParameterIivEXT", "GL_EXT_texture_integer", glGetTexParameterIivEXT },
  { "glGetTexParameterIuiv", "GL_VERSION_3_0", glGetTexParameterIuiv },
  { "glGetTexParameterIuivEXT", "GL_EXT_texture_integer", glGetTexParameterIuivEXT },
  { "glGetTexParameterPointervAPPLE", "GL_APPLE_texture_range", glGetTexParameterPointervAPPLE },
  { "glGetTexParameterxvOES", "GL_OES_fixed_point", glGetTexParameterxvOES },
  { "glGetTextureHandleARB", "GL_ARB_bindless_texture", glGetTextureHandleARB },
  { "glGetTextureHandleNV", "GL_NV_bindless_texture", glGetTextureHandleNV },
  { "glGetTextureImage", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureImage },
  { "glGetTextureImageEXT", "GL_EXT_direct_state_access", glGetTextureImageEXT },
  { "glGetTextureLevelParameterfv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureLevelParameterfv },
  { "glGetTextureLevelParameterfvEXT", "GL_EXT_direct_state_access", glGetTextureLevelParameterfvEXT },
  { "glGetTextureLevelParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureLevelParameteriv },
  { "glGetTextureLevelParameterivEXT", "GL_EXT_direct_state_access", glGetTextureLevelParameterivEXT },
  { "glGetTextureParameterIiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureParameterIiv },
  { "glGetTextureParameterIivEXT", "GL_EXT_direct_state_access", glGetTextureParameterIivEXT },
  { "glGetTextureParameterIuiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureParameterIuiv },
  { "glGetTextureParameterIuivEXT", "GL_EXT_direct_state_access", glGetTextureParameterIuivEXT },
  { "glGetTextureParameterfv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureParameterfv },
  { "glGetTextureParameterfvEXT", "GL_EXT_direct_state_access", glGetTextureParameterfvEXT },
  { "glGetTextureParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTextureParameteriv },
  { "glGetTextureParameterivEXT", "GL_EXT_direct_state_access", glGetTextureParameterivEXT },
  { "glGetTextureSamplerHandleARB", "GL_ARB_bindless_texture", glGetTextureSamplerHandleARB },
  { "glGetTextureSamplerHandleNV", "GL_NV_bindless_texture", glGetTextureSamplerHandleNV },
  { "glGetTextureSubImage", "GL_ARB_get_texture_sub_image GL_VERSION_4_5", glGetTextureSubImage },
  { "glGetTrackMatrixivNV", "GL_NV_vertex_program", glGetTrackMatrixivNV },
  { "glGetTransformFeedbackVarying", "GL_VERSION_3_0", glGetTransformFeedbackVarying },
  { "glGetTransformFeedbackVaryingEXT", "GL_EXT_transform_feedback", glGetTransformFeedbackVaryingEXT },
  { "glGetTransformFeedbackVaryingNV", "GL_NV_transform_feedback", glGetTransformFeedbackVaryingNV },
  { "glGetTransformFeedbacki64_v", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTransformFeedbacki64_v },
  { "glGetTransformFeedbacki_v", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTransformFeedbacki_v },
  { "glGetTransformFeedbackiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetTransformFeedbackiv },
  { "glGetUniformBlockIndex", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetUniformBlockIndex },
  { "glGetUniformBufferSizeEXT", "GL_EXT_bindable_uniform", glGetUniformBufferSizeEXT },
  { "glGetUniformIndices", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glGetUniformIndices },
  { "glGetUniformLocation", "GL_VERSION_2_0", glGetUniformLocation },
  { "glGetUniformLocationARB", "GL_ARB_shader_objects", glGetUniformLocationARB },
  { "glGetUniformOffsetEXT", "GL_EXT_bindable_uniform", glGetUniformOffsetEXT },
  { "glGetUniformSubroutineuiv", "GL_ARB_shader_subroutine GL_VERSION_4_0", glGetUniformSubroutineuiv },
  { "glGetUniformdv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glGetUniformdv },
  { "glGetUniformfv", "GL_VERSION_2_0", glGetUniformfv },
  { "glGetUniformfvARB", "GL_ARB_shader_objects", glGetUniformfvARB },
  { "glGetUniformi64vARB", "GL_ARB_gpu_shader_int64", glGetUniformi64vARB },
  { "glGetUniformi64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glGetUniformi64vNV },
  { "glGetUniformiv", "GL_VERSION_2_0", glGetUniformiv },
  { "glGetUniformivARB", "GL_ARB_shader_objects", glGetUniformivARB },
  { "glGetUniformui64vARB", "GL_ARB_gpu_shader_int64", glGetUniformui64vARB },
  { "glGetUniformui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_shader_buffer_load", glGetUniformui64vNV },
  { "glGetUniformuiv", "GL_VERSION_3_0", glGetUniformuiv },
  { "glGetUniformuivEXT", "GL_EXT_gpu_shader4", glGetUniformuivEXT },
  { "glGetUnsignedBytei_vEXT", "GL_EXT_memory_object GL_EXT_semaphore", glGetUnsignedBytei_vEXT },
  { "glGetUnsignedBytevEXT", "GL_EXT_memory_object GL_EXT_semaphore", glGetUnsignedBytevEXT },
  { "glGetVariantArrayObjectfvATI", "GL_ATI_vertex_array_object", glGetVariantArrayObjectfvATI },
  { "glGetVariantArrayObjectivATI", "GL_ATI_vertex_array_object", glGetVariantArrayObjectivATI },
  { "glGetVariantBooleanvEXT", "GL_EXT_vertex_shader", glGetVariantBooleanvEXT },
  { "glGetVariantFloatvEXT", "GL_EXT_vertex_shader", glGetVariantFloatvEXT },
  { "glGetVariantIntegervEXT", "GL_EXT_vertex_shader", glGetVariantIntegervEXT },
  { "glGetVariantPointervEXT", "GL_EXT_vertex_shader", glGetVariantPointervEXT },
  { "glGetVaryingLocationNV", "GL_NV_transform_feedback", glGetVaryingLocationNV },
  { "glGetVertexArrayIndexed64iv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetVertexArrayIndexed64iv },
  { "glGetVertexArrayIndexediv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetVertexArrayIndexediv },
  { "glGetVertexArrayIntegeri_vEXT", "GL_EXT_direct_state_access", glGetVertexArrayIntegeri_vEXT },
  { "glGetVertexArrayIntegervEXT", "GL_EXT_direct_state_access", glGetVertexArrayIntegervEXT },
  { "glGetVertexArrayPointeri_vEXT", "GL_EXT_direct_state_access", glGetVertexArrayPointeri_vEXT },
  { "glGetVertexArrayPointervEXT", "GL_EXT_direct_state_access", glGetVertexArrayPointervEXT },
  { "glGetVertexArrayiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glGetVertexArrayiv },
  { "glGetVertexAttribArrayObjectfvATI", "GL_ATI_vertex_attrib_array_object", glGetVertexAttribArrayObjectfvATI },
  { "glGetVertexAttribArrayObjectivATI", "GL_ATI_vertex_attrib_array_object", glGetVertexAttribArrayObjectivATI },
  { "glGetVertexAttribIiv", "GL_VERSION_3_0", glGetVertexAttribIiv },
  { "glGetVertexAttribIivEXT", "GL_NV_vertex_program4", glGetVertexAttribIivEXT },
  { "glGetVertexAttribIuiv", "GL_VERSION_3_0", glGetVertexAttribIuiv },
  { "glGetVertexAttribIuivEXT", "GL_NV_vertex_program4", glGetVertexAttribIuivEXT },
  { "glGetVertexAttribLdv", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glGetVertexAttribLdv },
  { "glGetVertexAttribLdvEXT", "GL_EXT_vertex_attrib_64bit", glGetVertexAttribLdvEXT },
  { "glGetVertexAttribLi64vNV", "GL_NV_vertex_attrib_integer_64bit", glGetVertexAttribLi64vNV },
  { "glGetVertexAttribLui64vARB", "GL_ARB_bindless_texture", glGetVertexAttribLui64vARB },
  { "glGetVertexAttribLui64vNV", "GL_NV_vertex_attrib_integer_64bit", glGetVertexAttribLui64vNV },
  { "glGetVertexAttribPointerv", "GL_VERSION_2_0", glGetVertexAttribPointerv },
  { "glGetVertexAttribPointervARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glGetVertexAttribPointervARB },
  { "glGetVertexAttribPointervNV", "GL_NV_vertex_program", glGetVertexAttribPointervNV },
  { "glGetVertexAttribdv", "GL_VERSION_2_0", glGetVertexAttribdv },
  { "glGetVertexAttribdvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glGetVertexAttribdvARB },
  { "glGetVertexAttribdvNV", "GL_NV_vertex_program", glGetVertexAttribdvNV },
  { "glGetVertexAttribfv", "GL_VERSION_2_0", glGetVertexAttribfv },
  { "glGetVertexAttribfvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glGetVertexAttribfvARB },
  { "glGetVertexAttribfvNV", "GL_NV_vertex_program", glGetVertexAttribfvNV },
  { "glGetVertexAttribiv", "GL_VERSION_2_0", glGetVertexAttribiv },
  { "glGetVertexAttribivARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glGetVertexAttribivARB },
  { "glGetVertexAttribivNV", "GL_NV_vertex_program", glGetVertexAttribivNV },
  { "glGetVideoCaptureStreamdvNV", "GL_NV_video_capture", glGetVideoCaptureStreamdvNV },
  { "glGetVideoCaptureStreamfvNV", "GL_NV_video_capture", glGetVideoCaptureStreamfvNV },
  { "glGetVideoCaptureStreamivNV", "GL_NV_video_capture", glGetVideoCaptureStreamivNV },
  { "glGetVideoCaptureivNV", "GL_NV_video_capture", glGetVideoCaptureivNV },
  { "glGetVideoi64vNV", "GL_NV_present_video", glGetVideoi64vNV },
  { "glGetVideoivNV", "GL_NV_present_video", glGetVideoivNV },
  { "glGetVideoui64vNV", "GL_NV_present_video", glGetVideoui64vNV },
  { "glGetVideouivNV", "GL_NV_present_video", glGetVideouivNV },
  { "glGetVkProcAddrNV", "GL_NV_draw_vulkan_image", glGetVkProcAddrNV },
  { "glGetnColorTable", "GL_VERSION_4_5", glGetnColorTable },
  { "glGetnColorTableARB", "GL_ARB_robustness", glGetnColorTableARB },
  { "glGetnCompressedTexImage", "GL_VERSION_4_5", glGetnCompressedTexImage },
  { "glGetnCompressedTexImageARB", "GL_ARB_robustness", glGetnCompressedTexImageARB },
  { "glGetnConvolutionFilter", "GL_VERSION_4_5", glGetnConvolutionFilter },
  { "glGetnConvolutionFilterARB", "GL_ARB_robustness", glGetnConvolutionFilterARB },
  { "glGetnHistogram", "GL_VERSION_4_5", glGetnHistogram },
  { "glGetnHistogramARB", "GL_ARB_robustness", glGetnHistogramARB },
  { "glGetnMapdv", "GL_VERSION_4_5", glGetnMapdv },
  { "glGetnMapdvARB", "GL_ARB_robustness", glGetnMapdvARB },
  { "glGetnMapfv", "GL_VERSION_4_5", glGetnMapfv },
  { "glGetnMapfvARB", "GL_ARB_robustness", glGetnMapfvARB },
  { "glGetnMapiv", "GL_VERSION_4_5", glGetnMapiv },
  { "glGetnMapivARB", "GL_ARB_robustness", glGetnMapivARB },
  { "glGetnMinmax", "GL_VERSION_4_5", glGetnMinmax },
  { "glGetnMinmaxARB", "GL_ARB_robustness", glGetnMinmaxARB },
  { "glGetnPixelMapfv", "GL_VERSION_4_5", glGetnPixelMapfv },
  { "glGetnPixelMapfvARB", "GL_ARB_robustness", glGetnPixelMapfvARB },
  { "glGetnPixelMapuiv", "GL_VERSION_4_5", glGetnPixelMapuiv },
  { "glGetnPixelMapuivARB", "GL_ARB_robustness", glGetnPixelMapuivARB },
  { "glGetnPixelMapusv", "GL_VERSION_4_5", glGetnPixelMapusv },
  { "glGetnPixelMapusvARB", "GL_ARB_robustness", glGetnPixelMapusvARB },
  { "glGetnPolygonStipple", "GL_VERSION_4_5", glGetnPolygonStipple },
  { "glGetnPolygonStippleARB", "GL_ARB_robustness", glGetnPolygonStippleARB },
  { "glGetnSeparableFilter", "GL_VERSION_4_5", glGetnSeparableFilter },
  { "glGetnSeparableFilterARB", "GL_ARB_robustness", glGetnSeparableFilterARB },
  { "glGetnTexImage", "GL_VERSION_4_5", glGetnTexImage },
  { "glGetnTexImageARB", "GL_ARB_robustness", glGetnTexImageARB },
  { "glGetnUniformdv", "GL_VERSION_4_5", glGetnUniformdv },
  { "glGetnUniformdvARB", "GL_ARB_robustness", glGetnUniformdvARB },
  { "glGetnUniformfv", "GL_KHR_robustness GL_VERSION_4_5", glGetnUniformfv },
  { "glGetnUniformfvARB", "GL_ARB_robustness", glGetnUniformfvARB },
  { "glGetnUniformi64vARB", "GL_ARB_gpu_shader_int64", glGetnUniformi64vARB },
  { "glGetnUniformiv", "GL_KHR_robustness GL_VERSION_4_5", glGetnUniformiv },
  { "glGetnUniformivARB", "GL_ARB_robustness", glGetnUniformivARB },
  { "glGetnUniformui64vARB", "GL_ARB_gpu_shader_int64", glGetnUniformui64vARB },
  { "glGetnUniformuiv", "GL_KHR_robustness GL_VERSION_4_5", glGetnUniformuiv },
  { "glGetnUniformuivARB", "GL_ARB_robustness", glGetnUniformuivARB },
  { "glGlobalAlphaFactorbSUN", "GL_SUN_global_alpha", glGlobalAlphaFactorbSUN },
  { "glGlobalAlphaFactordSUN", "GL_SUN_global_alpha", glGlobalAlphaFactordSUN },
  { "glGlobalAlphaFactorfSUN", "GL_SUN_global_alpha", glGlobalAlphaFactorfSUN },
  { "glGlobalAlphaFactoriSUN", "GL_SUN_global_alpha", glGlobalAlphaFactoriSUN },
  { "glGlobalAlphaFactorsSUN", "GL_SUN_global_alpha", glGlobalAlphaFactorsSUN },
  { "glGlobalAlphaFactorubSUN", "GL_SUN_global_alpha", glGlobalAlphaFactorubSUN },
  { "glGlobalAlphaFactoruiSUN", "GL_SUN_global_alpha", glGlobalAlphaFactoruiSUN },
  { "glGlobalAlphaFactorusSUN", "GL_SUN_global_alpha", glGlobalAlphaFactorusSUN },
  { "glHintPGI", "GL_PGI_misc_hints", glHintPGI },
  { "glHistogram", "GL_ARB_imaging", glHistogram },
  { "glHistogramEXT", "GL_EXT_histogram", glHistogramEXT },
  { "glIglooInterfaceSGIX", "GL_SGIX_igloo_interface", glIglooInterfaceSGIX },
  { "glImageTransformParameterfHP", "GL_HP_image_transform", glImageTransformParameterfHP },
  { "glImageTransformParameterfvHP", "GL_HP_image_transform", glImageTransformParameterfvHP },
  { "glImageTransformParameteriHP", "GL_HP_image_transform", glImageTransformParameteriHP },
  { "glImageTransformParameterivHP", "GL_HP_image_transform", glImageTransformParameterivHP },
  { "glImportMemoryFdEXT", "GL_EXT_memory_object_fd", glImportMemoryFdEXT },
  { "glImportMemoryWin32HandleEXT", "GL_EXT_memory_object_win32", glImportMemoryWin32HandleEXT },
  { "glImportMemoryWin32NameEXT", "GL_EXT_memory_object_win32", glImportMemoryWin32NameEXT },
  { "glImportSemaphoreFdEXT", "GL_EXT_semaphore_fd", glImportSemaphoreFdEXT },
  { "glImportSemaphoreWin32HandleEXT", "GL_EXT_semaphore_win32", glImportSemaphoreWin32HandleEXT },
  { "glImportSemaphoreWin32NameEXT", "GL_EXT_semaphore_win32", glImportSemaphoreWin32NameEXT },
  { "glImportSyncEXT", "GL_EXT_x11_sync_object", glImportSyncEXT },
  { "glIndexFormatNV", "GL_NV_vertex_buffer_unified_memory", glIndexFormatNV },
  { "glIndexFuncEXT", "GL_EXT_index_func", glIndexFuncEXT },
  { "glIndexMaterialEXT", "GL_EXT_index_material", glIndexMaterialEXT },
  { "glIndexPointerEXT", "GL_EXT_vertex_array", glIndexPointerEXT },
  { "glIndexPointerListIBM", "GL_IBM_vertex_array_lists", glIndexPointerListIBM },
  { "glIndexxOES", "GL_OES_fixed_point", glIndexxOES },
  { "glIndexxvOES", "GL_OES_fixed_point", glIndexxvOES },
  { "glInsertComponentEXT", "GL_EXT_vertex_shader", glInsertComponentEXT },
  { "glInsertEventMarkerEXT", "GL_EXT_debug_marker", glInsertEventMarkerEXT },
  { "glInstrumentsBufferSGIX", "GL_SGIX_instruments", glInstrumentsBufferSGIX },
  { "glInterpolatePathsNV", "GL_NV_path_rendering", glInterpolatePathsNV },
  { "glInvalidateBufferData", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateBufferData },
  { "glInvalidateBufferSubData", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateBufferSubData },
  { "glInvalidateFramebuffer", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateFramebuffer },
  { "glInvalidateNamedFramebufferData", "GL_ARB_direct_state_access GL_VERSION_4_5", glInvalidateNamedFramebufferData },
  { "glInvalidateNamedFramebufferSubData", "GL_ARB_direct_state_access GL_VERSION_4_5", glInvalidateNamedFramebufferSubData },
  { "glInvalidateSubFramebuffer", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateSubFramebuffer },
  { "glInvalidateTexImage", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateTexImage },
  { "glInvalidateTexSubImage", "GL_ARB_invalidate_subdata GL_VERSION_4_3", glInvalidateTexSubImage },
  { "glIsAsyncMarkerSGIX", "GL_SGIX_async", glIsAsyncMarkerSGIX },
  { "glIsBuffer", "GL_VERSION_1_5", glIsBuffer },
  { "glIsBufferARB", "GL_ARB_vertex_buffer_object", glIsBufferARB },
  { "glIsBufferResidentNV", "GL_NV_shader_buffer_load", glIsBufferResidentNV },
  { "glIsCommandListNV", "GL_NV_command_list", glIsCommandListNV },
  { "glIsEnabledIndexedEXT", "GL_EXT_direct_state_access GL_EXT_draw_buffers2", glIsEnabledIndexedEXT },
  { "glIsEnabledi", "GL_VERSION_3_0", glIsEnabledi },
  { "glIsFenceAPPLE", "GL_APPLE_fence", glIsFenceAPPLE },
  { "glIsFenceNV", "GL_NV_fence", glIsFenceNV },
  { "glIsFramebuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glIsFramebuffer },
  { "glIsFramebufferEXT", "GL_EXT_framebuffer_object", glIsFramebufferEXT },
  { "glIsImageHandleResidentARB", "GL_ARB_bindless_texture", glIsImageHandleResidentARB },
  { "glIsImageHandleResidentNV", "GL_NV_bindless_texture", glIsImageHandleResidentNV },
  { "glIsMemoryObjectEXT", "GL_EXT_memory_object", glIsMemoryObjectEXT },
  { "glIsNameAMD", "GL_AMD_name_gen_delete", glIsNameAMD },
  { "glIsNamedBufferResidentNV", "GL_NV_shader_buffer_load", glIsNamedBufferResidentNV },
  { "glIsNamedStringARB", "GL_ARB_shading_language_include", glIsNamedStringARB },
  { "glIsObjectBufferATI", "GL_ATI_vertex_array_object", glIsObjectBufferATI },
  { "glIsOcclusionQueryNV", "GL_NV_occlusion_query", glIsOcclusionQueryNV },
  { "glIsPathNV", "GL_NV_path_rendering", glIsPathNV },
  { "glIsPointInFillPathNV", "GL_NV_path_rendering", glIsPointInFillPathNV },
  { "glIsPointInStrokePathNV", "GL_NV_path_rendering", glIsPointInStrokePathNV },
  { "glIsProgram", "GL_VERSION_2_0", glIsProgram },
  { "glIsProgramARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glIsProgramARB },
  { "glIsProgramNV", "GL_NV_vertex_program", glIsProgramNV },
  { "glIsProgramPipeline", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glIsProgramPipeline },
  { "glIsQuery", "GL_VERSION_1_5", glIsQuery },
  { "glIsQueryARB", "GL_ARB_occlusion_query", glIsQueryARB },
  { "glIsRenderbuffer", "GL_ARB_framebuffer_object GL_VERSION_3_0", glIsRenderbuffer },
  { "glIsRenderbufferEXT", "GL_EXT_framebuffer_object", glIsRenderbufferEXT },
  { "glIsSampler", "GL_ARB_sampler_objects GL_VERSION_3_3", glIsSampler },
  { "glIsSemaphoreEXT", "GL_EXT_semaphore", glIsSemaphoreEXT },
  { "glIsShader", "GL_VERSION_2_0", glIsShader },
  { "glIsStateNV", "GL_NV_command_list", glIsStateNV },
  { "glIsSync", "GL_ARB_sync GL_VERSION_3_2", glIsSync },
  { "glIsTextureEXT", "GL_EXT_texture_object", glIsTextureEXT },
  { "glIsTextureHandleResidentARB", "GL_ARB_bindless_texture", glIsTextureHandleResidentARB },
  { "glIsTextureHandleResidentNV", "GL_NV_bindless_texture", glIsTextureHandleResidentNV },
  { "glIsTransformFeedback", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glIsTransformFeedback },
  { "glIsTransformFeedbackNV", "GL_NV_transform_feedback2", glIsTransformFeedbackNV },
  { "glIsVariantEnabledEXT", "GL_EXT_vertex_shader", glIsVariantEnabledEXT },
  { "glIsVertexArray", "GL_ARB_vertex_array_object GL_VERSION_3_0", glIsVertexArray },
  { "glIsVertexArrayAPPLE", "GL_APPLE_vertex_array_object", glIsVertexArrayAPPLE },
  { "glIsVertexAttribEnabledAPPLE", "GL_APPLE_vertex_program_evaluators", glIsVertexAttribEnabledAPPLE },
  { "glLGPUCopyImageSubDataNVX", "GL_NVX_linked_gpu_multicast", glLGPUCopyImageSubDataNVX },
  { "glLGPUInterlockNVX", "GL_NVX_linked_gpu_multicast", glLGPUInterlockNVX },
  { "glLGPUNamedBufferSubDataNVX", "GL_NVX_linked_gpu_multicast", glLGPUNamedBufferSubDataNVX },
  { "glLabelObjectEXT", "GL_EXT_debug_label", glLabelObjectEXT },
  { "glLightEnviSGIX", "GL_SGIX_fragment_lighting", glLightEnviSGIX },
  { "glLightModelxOES", "GL_OES_fixed_point", glLightModelxOES },
  { "glLightModelxvOES", "GL_OES_fixed_point", glLightModelxvOES },
  { "glLightxOES", "GL_OES_fixed_point", glLightxOES },
  { "glLightxvOES", "GL_OES_fixed_point", glLightxvOES },
  { "glLineWidthxOES", "GL_OES_fixed_point", glLineWidthxOES },
  { "glLinkProgram", "GL_VERSION_2_0", glLinkProgram },
  { "glLinkProgramARB", "GL_ARB_shader_objects", glLinkProgramARB },
  { "glListDrawCommandsStatesClientNV", "GL_NV_command_list", glListDrawCommandsStatesClientNV },
  { "glListParameterfSGIX", "GL_SGIX_list_priority", glListParameterfSGIX },
  { "glListParameterfvSGIX", "GL_SGIX_list_priority", glListParameterfvSGIX },
  { "glListParameteriSGIX", "GL_SGIX_list_priority", glListParameteriSGIX },
  { "glListParameterivSGIX", "GL_SGIX_list_priority", glListParameterivSGIX },
  { "glLoadIdentityDeformationMapSGIX", "GL_SGIX_polynomial_ffd", glLoadIdentityDeformationMapSGIX },
  { "glLoadMatrixxOES", "GL_OES_fixed_point", glLoadMatrixxOES },
  { "glLoadProgramNV", "GL_NV_vertex_program", glLoadProgramNV },
  { "glLoadTransposeMatrixd", "GL_VERSION_1_3", glLoadTransposeMatrixd },
  { "glLoadTransposeMatrixdARB", "GL_ARB_transpose_matrix", glLoadTransposeMatrixdARB },
  { "glLoadTransposeMatrixf", "GL_VERSION_1_3", glLoadTransposeMatrixf },
  { "glLoadTransposeMatrixfARB", "GL_ARB_transpose_matrix", glLoadTransposeMatrixfARB },
  { "glLoadTransposeMatrixxOES", "GL_OES_fixed_point", glLoadTransposeMatrixxOES },
  { "glLockArraysEXT", "GL_EXT_compiled_vertex_array", glLockArraysEXT },
  { "glMTexCoord2fSGIS", "GL_SGIS_multitexture", glMTexCoord2fSGIS },
  { "glMTexCoord2fvSGIS", "GL_SGIS_multitexture", glMTexCoord2fvSGIS },
  { "glMakeBufferNonResidentNV", "GL_NV_shader_buffer_load", glMakeBufferNonResidentNV },
  { "glMakeBufferResidentNV", "GL_NV_shader_buffer_load", glMakeBufferResidentNV },
  { "glMakeImageHandleNonResidentARB", "GL_ARB_bindless_texture", glMakeImageHandleNonResidentARB },
  { "glMakeImageHandleNonResidentNV", "GL_NV_bindless_texture", glMakeImageHandleNonResidentNV },
  { "glMakeImageHandleResidentARB", "GL_ARB_bindless_texture", glMakeImageHandleResidentARB },
  { "glMakeImageHandleResidentNV", "GL_NV_bindless_texture", glMakeImageHandleResidentNV },
  { "glMakeNamedBufferNonResidentNV", "GL_NV_shader_buffer_load", glMakeNamedBufferNonResidentNV },
  { "glMakeNamedBufferResidentNV", "GL_NV_shader_buffer_load", glMakeNamedBufferResidentNV },
  { "glMakeTextureHandleNonResidentARB", "GL_ARB_bindless_texture", glMakeTextureHandleNonResidentARB },
  { "glMakeTextureHandleNonResidentNV", "GL_NV_bindless_texture", glMakeTextureHandleNonResidentNV },
  { "glMakeTextureHandleResidentARB", "GL_ARB_bindless_texture", glMakeTextureHandleResidentARB },
  { "glMakeTextureHandleResidentNV", "GL_NV_bindless_texture", glMakeTextureHandleResidentNV },
  { "glMap1xOES", "GL_OES_fixed_point", glMap1xOES },
  { "glMap2xOES", "GL_OES_fixed_point", glMap2xOES },
  { "glMapBuffer", "GL_VERSION_1_5", glMapBuffer },
  { "glMapBufferARB", "GL_ARB_vertex_buffer_object", glMapBufferARB },
  { "glMapBufferRange", "GL_ARB_map_buffer_range GL_VERSION_3_0", glMapBufferRange },
  { "glMapControlPointsNV", "GL_NV_evaluators", glMapControlPointsNV },
  { "glMapGrid1xOES", "GL_OES_fixed_point", glMapGrid1xOES },
  { "glMapGrid2xOES", "GL_OES_fixed_point", glMapGrid2xOES },
  { "glMapNamedBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glMapNamedBuffer },
  { "glMapNamedBufferEXT", "GL_EXT_direct_state_access", glMapNamedBufferEXT },
  { "glMapNamedBufferRange", "GL_ARB_direct_state_access GL_VERSION_4_5", glMapNamedBufferRange },
  { "glMapNamedBufferRangeEXT", "GL_EXT_direct_state_access", glMapNamedBufferRangeEXT },
  { "glMapObjectBufferATI", "GL_ATI_map_object_buffer", glMapObjectBufferATI },
  { "glMapParameterfvNV", "GL_NV_evaluators", glMapParameterfvNV },
  { "glMapParameterivNV", "GL_NV_evaluators", glMapParameterivNV },
  { "glMapTexture2DINTEL", "GL_INTEL_map_texture", glMapTexture2DINTEL },
  { "glMapVertexAttrib1dAPPLE", "GL_APPLE_vertex_program_evaluators", glMapVertexAttrib1dAPPLE },
  { "glMapVertexAttrib1fAPPLE", "GL_APPLE_vertex_program_evaluators", glMapVertexAttrib1fAPPLE },
  { "glMapVertexAttrib2dAPPLE", "GL_APPLE_vertex_program_evaluators", glMapVertexAttrib2dAPPLE },
  { "glMapVertexAttrib2fAPPLE", "GL_APPLE_vertex_program_evaluators", glMapVertexAttrib2fAPPLE },
  { "glMaterialxOES", "GL_OES_fixed_point", glMaterialxOES },
  { "glMaterialxvOES", "GL_OES_fixed_point", glMaterialxvOES },
  { "glMatrixFrustumEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixFrustumEXT },
  { "glMatrixIndexPointerARB", "GL_ARB_matrix_palette", glMatrixIndexPointerARB },
  { "glMatrixIndexubvARB", "GL_ARB_matrix_palette", glMatrixIndexubvARB },
  { "glMatrixIndexuivARB", "GL_ARB_matrix_palette", glMatrixIndexuivARB },
  { "glMatrixIndexusvARB", "GL_ARB_matrix_palette", glMatrixIndexusvARB },
  { "glMatrixLoad3x2fNV", "GL_NV_path_rendering", glMatrixLoad3x2fNV },
  { "glMatrixLoad3x3fNV", "GL_NV_path_rendering", glMatrixLoad3x3fNV },
  { "glMatrixLoadIdentityEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixLoadIdentityEXT },
  { "glMatrixLoadTranspose3x3fNV", "GL_NV_path_rendering", glMatrixLoadTranspose3x3fNV },
  { "glMatrixLoadTransposedEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixLoadTransposedEXT },
  { "glMatrixLoadTransposefEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixLoadTransposefEXT },
  { "glMatrixLoaddEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixLoaddEXT },
  { "glMatrixLoadfEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixLoadfEXT },
  { "glMatrixMult3x2fNV", "GL_NV_path_rendering", glMatrixMult3x2fNV },
  { "glMatrixMult3x3fNV", "GL_NV_path_rendering", glMatrixMult3x3fNV },
  { "glMatrixMultTranspose3x3fNV", "GL_NV_path_rendering", glMatrixMultTranspose3x3fNV },
  { "glMatrixMultTransposedEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixMultTransposedEXT },
  { "glMatrixMultTransposefEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixMultTransposefEXT },
  { "glMatrixMultdEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixMultdEXT },
  { "glMatrixMultfEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixMultfEXT },
  { "glMatrixOrthoEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixOrthoEXT },
  { "glMatrixPopEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixPopEXT },
  { "glMatrixPushEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixPushEXT },
  { "glMatrixRotatedEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixRotatedEXT },
  { "glMatrixRotatefEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixRotatefEXT },
  { "glMatrixScaledEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixScaledEXT },
  { "glMatrixScalefEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixScalefEXT },
  { "glMatrixTranslatedEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixTranslatedEXT },
  { "glMatrixTranslatefEXT", "GL_EXT_direct_state_access GL_NV_path_rendering", glMatrixTranslatefEXT },
  { "glMaxShaderCompilerThreadsARB", "GL_ARB_parallel_shader_compile", glMaxShaderCompilerThreadsARB },
  { "glMaxShaderCompilerThreadsKHR", "GL_KHR_parallel_shader_compile", glMaxShaderCompilerThreadsKHR },
  { "glMemoryBarrier", "GL_ARB_shader_image_load_store GL_VERSION_4_2", glMemoryBarrier },
  { "glMemoryBarrierByRegion", "GL_ARB_ES3_1_compatibility GL_VERSION_4_5", glMemoryBarrierByRegion },
  { "glMemoryBarrierEXT", "GL_EXT_shader_image_load_store", glMemoryBarrierEXT },
  { "glMemoryObjectParameterivEXT", "GL_EXT_memory_object", glMemoryObjectParameterivEXT },
  { "glMinSampleShading", "GL_VERSION_4_0", glMinSampleShading },
  { "glMinSampleShadingARB", "GL_ARB_sample_shading", glMinSampleShadingARB },
  { "glMinmax", "GL_ARB_imaging", glMinmax },
  { "glMinmaxEXT", "GL_EXT_histogram", glMinmaxEXT },
  { "glMultMatrixxOES", "GL_OES_fixed_point", glMultMatrixxOES },
  { "glMultTransposeMatrixd", "GL_VERSION_1_3", glMultTransposeMatrixd },
  { "glMultTransposeMatrixdARB", "GL_ARB_transpose_matrix", glMultTransposeMatrixdARB },
  { "glMultTransposeMatrixf", "GL_VERSION_1_3", glMultTransposeMatrixf },
  { "glMultTransposeMatrixfARB", "GL_ARB_transpose_matrix", glMultTransposeMatrixfARB },
  { "glMultTransposeMatrixxOES", "GL_OES_fixed_point", glMultTransposeMatrixxOES },
  { "glMultiDrawArrays", "GL_VERSION_1_4", glMultiDrawArrays },
  { "glMultiDrawArraysEXT", "GL_EXT_multi_draw_arrays", glMultiDrawArraysEXT },
  { "glMultiDrawArraysIndirect", "GL_ARB_multi_draw_indirect GL_VERSION_4_3", glMultiDrawArraysIndirect },
  { "glMultiDrawArraysIndirectAMD", "GL_AMD_multi_draw_indirect", glMultiDrawArraysIndirectAMD },
  { "glMultiDrawArraysIndirectBindlessCountNV", "GL_NV_bindless_multi_draw_indirect_count", glMultiDrawArraysIndirectBindlessCountNV },
  { "glMultiDrawArraysIndirectBindlessNV", "GL_NV_bindless_multi_draw_indirect", glMultiDrawArraysIndirectBindlessNV },
  { "glMultiDrawArraysIndirectCount", "GL_VERSION_4_6", glMultiDrawArraysIndirectCount },
  { "glMultiDrawArraysIndirectCountARB", "GL_ARB_indirect_parameters", glMultiDrawArraysIndirectCountARB },
  { "glMultiDrawElementArrayAPPLE", "GL_APPLE_element_array", glMultiDrawElementArrayAPPLE },
  { "glMultiDrawElements", "GL_VERSION_1_4", glMultiDrawElements },
  { "glMultiDrawElementsBaseVertex", "GL_ARB_draw_elements_base_vertex GL_VERSION_3_2", glMultiDrawElementsBaseVertex },
  { "glMultiDrawElementsEXT", "GL_EXT_multi_draw_arrays", glMultiDrawElementsEXT },
  { "glMultiDrawElementsIndirect", "GL_ARB_multi_draw_indirect GL_VERSION_4_3", glMultiDrawElementsIndirect },
  { "glMultiDrawElementsIndirectAMD", "GL_AMD_multi_draw_indirect", glMultiDrawElementsIndirectAMD },
  { "glMultiDrawElementsIndirectBindlessCountNV", "GL_NV_bindless_multi_draw_indirect_count", glMultiDrawElementsIndirectBindlessCountNV },
  { "glMultiDrawElementsIndirectBindlessNV", "GL_NV_bindless_multi_draw_indirect", glMultiDrawElementsIndirectBindlessNV },
  { "glMultiDrawElementsIndirectCount", "GL_VERSION_4_6", glMultiDrawElementsIndirectCount },
  { "glMultiDrawElementsIndirectCountARB", "GL_ARB_indirect_parameters", glMultiDrawElementsIndirectCountARB },
  { "glMultiDrawMeshTasksIndirectCountNV", "GL_NV_mesh_shader", glMultiDrawMeshTasksIndirectCountNV },
  { "glMultiDrawMeshTasksIndirectNV", "GL_NV_mesh_shader", glMultiDrawMeshTasksIndirectNV },
  { "glMultiDrawRangeElementArrayAPPLE", "GL_APPLE_element_array", glMultiDrawRangeElementArrayAPPLE },
  { "glMultiModeDrawArraysIBM", "GL_IBM_multimode_draw_arrays", glMultiModeDrawArraysIBM },
  { "glMultiModeDrawElementsIBM", "GL_IBM_multimode_draw_arrays", glMultiModeDrawElementsIBM },
  { "glMultiTexBufferEXT", "GL_EXT_direct_state_access", glMultiTexBufferEXT },
  { "glMultiTexCoord1bOES", "GL_OES_byte_coordinates", glMultiTexCoord1bOES },
  { "glMultiTexCoord1bvOES", "GL_OES_byte_coordinates", glMultiTexCoord1bvOES },
  { "glMultiTexCoord1d", "GL_VERSION_1_3", glMultiTexCoord1d },
  { "glMultiTexCoord1dARB", "GL_ARB_multitexture", glMultiTexCoord1dARB },
  { "glMultiTexCoord1dSGIS", "GL_SGIS_multitexture", glMultiTexCoord1dSGIS },
  { "glMultiTexCoord1dv", "GL_VERSION_1_3", glMultiTexCoord1dv },
  { "glMultiTexCoord1dvARB", "GL_ARB_multitexture", glMultiTexCoord1dvARB },
  { "glMultiTexCoord1dvSGIS", "GL_SGIS_multitexture", glMultiTexCoord1dvSGIS },
  { "glMultiTexCoord1f", "GL_VERSION_1_3", glMultiTexCoord1f },
  { "glMultiTexCoord1fARB", "GL_ARB_multitexture", glMultiTexCoord1fARB },
  { "glMultiTexCoord1fSGIS", "GL_SGIS_multitexture", glMultiTexCoord1fSGIS },
  { "glMultiTexCoord1fv", "GL_VERSION_1_3", glMultiTexCoord1fv },
  { "glMultiTexCoord1fvARB", "GL_ARB_multitexture", glMultiTexCoord1fvARB },
  { "glMultiTexCoord1fvSGIS", "GL_SGIS_multitexture", glMultiTexCoord1fvSGIS },
  { "glMultiTexCoord1hNV", "GL_NV_half_float", glMultiTexCoord1hNV },
  { "glMultiTexCoord1hvNV", "GL_NV_half_float", glMultiTexCoord1hvNV },
  { "glMultiTexCoord1i", "GL_VERSION_1_3", glMultiTexCoord1i },
  { "glMultiTexCoord1iARB", "GL_ARB_multitexture", glMultiTexCoord1iARB },
  { "glMultiTexCoord1iSGIS", "GL_SGIS_multitexture", glMultiTexCoord1iSGIS },
  { "glMultiTexCoord1iv", "GL_VERSION_1_3", glMultiTexCoord1iv },
  { "glMultiTexCoord1ivARB", "GL_ARB_multitexture", glMultiTexCoord1ivARB },
  { "glMultiTexCoord1ivSGIS", "GL_SGIS_multitexture", glMultiTexCoord1ivSGIS },
  { "glMultiTexCoord1s", "GL_VERSION_1_3", glMultiTexCoord1s },
  { "glMultiTexCoord1sARB", "GL_ARB_multitexture", glMultiTexCoord1sARB },
  { "glMultiTexCoord1sSGIS", "GL_SGIS_multitexture", glMultiTexCoord1sSGIS },
  { "glMultiTexCoord1sv", "GL_VERSION_1_3", glMultiTexCoord1sv },
  { "glMultiTexCoord1svARB", "GL_ARB_multitexture", glMultiTexCoord1svARB },
  { "glMultiTexCoord1svSGIS", "GL_SGIS_multitexture", glMultiTexCoord1svSGIS },
  { "glMultiTexCoord1xOES", "GL_OES_fixed_point", glMultiTexCoord1xOES },
  { "glMultiTexCoord1xvOES", "GL_OES_fixed_point", glMultiTexCoord1xvOES },
  { "glMultiTexCoord2bOES", "GL_OES_byte_coordinates", glMultiTexCoord2bOES },
  { "glMultiTexCoord2bvOES", "GL_OES_byte_coordinates", glMultiTexCoord2bvOES },
  { "glMultiTexCoord2d", "GL_VERSION_1_3", glMultiTexCoord2d },
  { "glMultiTexCoord2dARB", "GL_ARB_multitexture", glMultiTexCoord2dARB },
  { "glMultiTexCoord2dSGIS", "GL_SGIS_multitexture", glMultiTexCoord2dSGIS },
  { "glMultiTexCoord2dv", "GL_VERSION_1_3", glMultiTexCoord2dv },
  { "glMultiTexCoord2dvARB", "GL_ARB_multitexture", glMultiTexCoord2dvARB },
  { "glMultiTexCoord2dvSGIS", "GL_SGIS_multitexture", glMultiTexCoord2dvSGIS },
  { "glMultiTexCoord2f", "GL_VERSION_1_3", glMultiTexCoord2f },
  { "glMultiTexCoord2fARB", "GL_ARB_multitexture", glMultiTexCoord2fARB },
  { "glMultiTexCoord2fSGIS", "GL_SGIS_multitexture", glMultiTexCoord2fSGIS },
  { "glMultiTexCoord2fv", "GL_VERSION_1_3", glMultiTexCoord2fv },
  { "glMultiTexCoord2fvARB", "GL_ARB_multitexture", glMultiTexCoord2fvARB },
  { "glMultiTexCoord2fvSGIS", "GL_SGIS_multitexture", glMultiTexCoord2fvSGIS },
  { "glMultiTexCoord2hNV", "GL_NV_half_float", glMultiTexCoord2hNV },
  { "glMultiTexCoord2hvNV", "GL_NV_half_float", glMultiTexCoord2hvNV },
  { "glMultiTexCoord2i", "GL_VERSION_1_3", glMultiTexCoord2i },
  { "glMultiTexCoord2iARB", "GL_ARB_multitexture", glMultiTexCoord2iARB },
  { "glMultiTexCoord2iSGIS", "GL_SGIS_multitexture", glMultiTexCoord2iSGIS },
  { "glMultiTexCoord2iv", "GL_VERSION_1_3", glMultiTexCoord2iv },
  { "glMultiTexCoord2ivARB", "GL_ARB_multitexture", glMultiTexCoord2ivARB },
  { "glMultiTexCoord2ivSGIS", "GL_SGIS_multitexture", glMultiTexCoord2ivSGIS },
  { "glMultiTexCoord2s", "GL_VERSION_1_3", glMultiTexCoord2s },
  { "glMultiTexCoord2sARB", "GL_ARB_multitexture", glMultiTexCoord2sARB },
  { "glMultiTexCoord2sSGIS", "GL_SGIS_multitexture", glMultiTexCoord2sSGIS },
  { "glMultiTexCoord2sv", "GL_VERSION_1_3", glMultiTexCoord2sv },
  { "glMultiTexCoord2svARB", "GL_ARB_multitexture", glMultiTexCoord2svARB },
  { "glMultiTexCoord2svSGIS", "GL_SGIS_multitexture", glMultiTexCoord2svSGIS },
  { "glMultiTexCoord2xOES", "GL_OES_fixed_point", glMultiTexCoord2xOES },
  { "glMultiTexCoord2xvOES", "GL_OES_fixed_point", glMultiTexCoord2xvOES },
  { "glMultiTexCoord3bOES", "GL_OES_byte_coordinates", glMultiTexCoord3bOES },
  { "glMultiTexCoord3bvOES", "GL_OES_byte_coordinates", glMultiTexCoord3bvOES },
  { "glMultiTexCoord3d", "GL_VERSION_1_3", glMultiTexCoord3d },
  { "glMultiTexCoord3dARB", "GL_ARB_multitexture", glMultiTexCoord3dARB },
  { "glMultiTexCoord3dSGIS", "GL_SGIS_multitexture", glMultiTexCoord3dSGIS },
  { "glMultiTexCoord3dv", "GL_VERSION_1_3", glMultiTexCoord3dv },
  { "glMultiTexCoord3dvARB", "GL_ARB_multitexture", glMultiTexCoord3dvARB },
  { "glMultiTexCoord3dvSGIS", "GL_SGIS_multitexture", glMultiTexCoord3dvSGIS },
  { "glMultiTexCoord3f", "GL_VERSION_1_3", glMultiTexCoord3f },
  { "glMultiTexCoord3fARB", "GL_ARB_multitexture", glMultiTexCoord3fARB },
  { "glMultiTexCoord3fSGIS", "GL_SGIS_multitexture", glMultiTexCoord3fSGIS },
  { "glMultiTexCoord3fv", "GL_VERSION_1_3", glMultiTexCoord3fv },
  { "glMultiTexCoord3fvARB", "GL_ARB_multitexture", glMultiTexCoord3fvARB },
  { "glMultiTexCoord3fvSGIS", "GL_SGIS_multitexture", glMultiTexCoord3fvSGIS },
  { "glMultiTexCoord3hNV", "GL_NV_half_float", glMultiTexCoord3hNV },
  { "glMultiTexCoord3hvNV", "GL_NV_half_float", glMultiTexCoord3hvNV },
  { "glMultiTexCoord3i", "GL_VERSION_1_3", glMultiTexCoord3i },
  { "glMultiTexCoord3iARB", "GL_ARB_multitexture", glMultiTexCoord3iARB },
  { "glMultiTexCoord3iSGIS", "GL_SGIS_multitexture", glMultiTexCoord3iSGIS },
  { "glMultiTexCoord3iv", "GL_VERSION_1_3", glMultiTexCoord3iv },
  { "glMultiTexCoord3ivARB", "GL_ARB_multitexture", glMultiTexCoord3ivARB },
  { "glMultiTexCoord3ivSGIS", "GL_SGIS_multitexture", glMultiTexCoord3ivSGIS },
  { "glMultiTexCoord3s", "GL_VERSION_1_3", glMultiTexCoord3s },
  { "glMultiTexCoord3sARB", "GL_ARB_multitexture", glMultiTexCoord3sARB },
  { "glMultiTexCoord3sSGIS", "GL_SGIS_multitexture", glMultiTexCoord3sSGIS },
  { "glMultiTexCoord3sv", "GL_VERSION_1_3", glMultiTexCoord3sv },
  { "glMultiTexCoord3svARB", "GL_ARB_multitexture", glMultiTexCoord3svARB },
  { "glMultiTexCoord3svSGIS", "GL_SGIS_multitexture", glMultiTexCoord3svSGIS },
  { "glMultiTexCoord3xOES", "GL_OES_fixed_point", glMultiTexCoord3xOES },
  { "glMultiTexCoord3xvOES", "GL_OES_fixed_point", glMultiTexCoord3xvOES },
  { "glMultiTexCoord4bOES", "GL_OES_byte_coordinates", glMultiTexCoord4bOES },
  { "glMultiTexCoord4bvOES", "GL_OES_byte_coordinates", glMultiTexCoord4bvOES },
  { "glMultiTexCoord4d", "GL_VERSION_1_3", glMultiTexCoord4d },
  { "glMultiTexCoord4dARB", "GL_ARB_multitexture", glMultiTexCoord4dARB },
  { "glMultiTexCoord4dSGIS", "GL_SGIS_multitexture", glMultiTexCoord4dSGIS },
  { "glMultiTexCoord4dv", "GL_VERSION_1_3", glMultiTexCoord4dv },
  { "glMultiTexCoord4dvARB", "GL_ARB_multitexture", glMultiTexCoord4dvARB },
  { "glMultiTexCoord4dvSGIS", "GL_SGIS_multitexture", glMultiTexCoord4dvSGIS },
  { "glMultiTexCoord4f", "GL_VERSION_1_3", glMultiTexCoord4f },
  { "glMultiTexCoord4fARB", "GL_ARB_multitexture", glMultiTexCoord4fARB },
  { "glMultiTexCoord4fSGIS", "GL_SGIS_multitexture", glMultiTexCoord4fSGIS },
  { "glMultiTexCoord4fv", "GL_VERSION_1_3", glMultiTexCoord4fv },
  { "glMultiTexCoord4fvARB", "GL_ARB_multitexture", glMultiTexCoord4fvARB },
  { "glMultiTexCoord4fvSGIS", "GL_SGIS_multitexture", glMultiTexCoord4fvSGIS },
  { "glMultiTexCoord4hNV", "GL_NV_half_float", glMultiTexCoord4hNV },
  { "glMultiTexCoord4hvNV", "GL_NV_half_float", glMultiTexCoord4hvNV },
  { "glMultiTexCoord4i", "GL_VERSION_1_3", glMultiTexCoord4i },
  { "glMultiTexCoord4iARB", "GL_ARB_multitexture", glMultiTexCoord4iARB },
  { "glMultiTexCoord4iSGIS", "GL_SGIS_multitexture", glMultiTexCoord4iSGIS },
  { "glMultiTexCoord4iv", "GL_VERSION_1_3", glMultiTexCoord4iv },
  { "glMultiTexCoord4ivARB", "GL_ARB_multitexture", glMultiTexCoord4ivARB },
  { "glMultiTexCoord4ivSGIS", "GL_SGIS_multitexture", glMultiTexCoord4ivSGIS },
  { "glMultiTexCoord4s", "GL_VERSION_1_3", glMultiTexCoord4s },
  { "glMultiTexCoord4sARB", "GL_ARB_multitexture", glMultiTexCoord4sARB },
  { "glMultiTexCoord4sSGIS", "GL_SGIS_multitexture", glMultiTexCoord4sSGIS },
  { "glMultiTexCoord4sv", "GL_VERSION_1_3", glMultiTexCoord4sv },
  { "glMultiTexCoord4svARB", "GL_ARB_multitexture", glMultiTexCoord4svARB },
  { "glMultiTexCoord4svSGIS", "GL_SGIS_multitexture", glMultiTexCoord4svSGIS },
  { "glMultiTexCoord4xOES", "GL_OES_fixed_point", glMultiTexCoord4xOES },
  { "glMultiTexCoord4xvOES", "GL_OES_fixed_point", glMultiTexCoord4xvOES },
  { "glMultiTexCoordP1ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP1ui },
  { "glMultiTexCoordP1uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP1uiv },
  { "glMultiTexCoordP2ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP2ui },
  { "glMultiTexCoordP2uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP2uiv },
  { "glMultiTexCoordP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP3ui },
  { "glMultiTexCoordP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP3uiv },
  { "glMultiTexCoordP4ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP4ui },
  { "glMultiTexCoordP4uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glMultiTexCoordP4uiv },
  { "glMultiTexCoordPointerEXT", "GL_EXT_direct_state_access", glMultiTexCoordPointerEXT },
  { "glMultiTexCoordPointerSGIS", "GL_SGIS_multitexture", glMultiTexCoordPointerSGIS },
  { "glMultiTexEnvfEXT", "GL_EXT_direct_state_access", glMultiTexEnvfEXT },
  { "glMultiTexEnvfvEXT", "GL_EXT_direct_state_access", glMultiTexEnvfvEXT },
  { "glMultiTexEnviEXT", "GL_EXT_direct_state_access", glMultiTexEnviEXT },
  { "glMultiTexEnvivEXT", "GL_EXT_direct_state_access", glMultiTexEnvivEXT },
  { "glMultiTexGendEXT", "GL_EXT_direct_state_access", glMultiTexGendEXT },
  { "glMultiTexGendvEXT", "GL_EXT_direct_state_access", glMultiTexGendvEXT },
  { "glMultiTexGenfEXT", "GL_EXT_direct_state_access", glMultiTexGenfEXT },
  { "glMultiTexGenfvEXT", "GL_EXT_direct_state_access", glMultiTexGenfvEXT },
  { "glMultiTexGeniEXT", "GL_EXT_direct_state_access", glMultiTexGeniEXT },
  { "glMultiTexGenivEXT", "GL_EXT_direct_state_access", glMultiTexGenivEXT },
  { "glMultiTexImage1DEXT", "GL_EXT_direct_state_access", glMultiTexImage1DEXT },
  { "glMultiTexImage2DEXT", "GL_EXT_direct_state_access", glMultiTexImage2DEXT },
  { "glMultiTexImage3DEXT", "GL_EXT_direct_state_access", glMultiTexImage3DEXT },
  { "glMultiTexParameterIivEXT", "GL_EXT_direct_state_access", glMultiTexParameterIivEXT },
  { "glMultiTexParameterIuivEXT", "GL_EXT_direct_state_access", glMultiTexParameterIuivEXT },
  { "glMultiTexParameterfEXT", "GL_EXT_direct_state_access", glMultiTexParameterfEXT },
  { "glMultiTexParameterfvEXT", "GL_EXT_direct_state_access", glMultiTexParameterfvEXT },
  { "glMultiTexParameteriEXT", "GL_EXT_direct_state_access", glMultiTexParameteriEXT },
  { "glMultiTexParameterivEXT", "GL_EXT_direct_state_access", glMultiTexParameterivEXT },
  { "glMultiTexRenderbufferEXT", "GL_EXT_direct_state_access", glMultiTexRenderbufferEXT },
  { "glMultiTexSubImage1DEXT", "GL_EXT_direct_state_access", glMultiTexSubImage1DEXT },
  { "glMultiTexSubImage2DEXT", "GL_EXT_direct_state_access", glMultiTexSubImage2DEXT },
  { "glMultiTexSubImage3DEXT", "GL_EXT_direct_state_access", glMultiTexSubImage3DEXT },
  { "glMulticastBarrierNV", "GL_NV_gpu_multicast", glMulticastBarrierNV },
  { "glMulticastBlitFramebufferNV", "GL_NV_gpu_multicast", glMulticastBlitFramebufferNV },
  { "glMulticastBufferSubDataNV", "GL_NV_gpu_multicast", glMulticastBufferSubDataNV },
  { "glMulticastCopyBufferSubDataNV", "GL_NV_gpu_multicast", glMulticastCopyBufferSubDataNV },
  { "glMulticastCopyImageSubDataNV", "GL_NV_gpu_multicast", glMulticastCopyImageSubDataNV },
  { "glMulticastFramebufferSampleLocationsfvNV", "GL_NV_gpu_multicast", glMulticastFramebufferSampleLocationsfvNV },
  { "glMulticastGetQueryObjecti64vNV", "GL_NV_gpu_multicast", glMulticastGetQueryObjecti64vNV },
  { "glMulticastGetQueryObjectivNV", "GL_NV_gpu_multicast", glMulticastGetQueryObjectivNV },
  { "glMulticastGetQueryObjectui64vNV", "GL_NV_gpu_multicast", glMulticastGetQueryObjectui64vNV },
  { "glMulticastGetQueryObjectuivNV", "GL_NV_gpu_multicast", glMulticastGetQueryObjectuivNV },
  { "glMulticastScissorArrayvNVX", "GL_NVX_gpu_multicast2", glMulticastScissorArrayvNVX },
  { "glMulticastViewportArrayvNVX", "GL_NVX_gpu_multicast2", glMulticastViewportArrayvNVX },
  { "glMulticastViewportPositionWScaleNVX", "GL_NVX_gpu_multicast2", glMulticastViewportPositionWScaleNVX },
  { "glMulticastWaitSyncNV", "GL_NV_gpu_multicast", glMulticastWaitSyncNV },
  { "glNamedBufferAttachMemoryNV", "GL_NV_memory_attachment", glNamedBufferAttachMemoryNV },
  { "glNamedBufferData", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedBufferData },
  { "glNamedBufferDataEXT", "GL_EXT_direct_state_access", glNamedBufferDataEXT },
  { "glNamedBufferPageCommitmentARB", "GL_ARB_sparse_buffer", glNamedBufferPageCommitmentARB },
  { "glNamedBufferPageCommitmentEXT", "GL_ARB_sparse_buffer", glNamedBufferPageCommitmentEXT },
  { "glNamedBufferStorage", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedBufferStorage },
  { "glNamedBufferStorageEXT", "GL_EXT_direct_state_access", glNamedBufferStorageEXT },
  { "glNamedBufferStorageExternalEXT", "GL_EXT_external_buffer", glNamedBufferStorageExternalEXT },
  { "glNamedBufferStorageMemEXT", "GL_EXT_memory_object", glNamedBufferStorageMemEXT },
  { "glNamedBufferSubData", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedBufferSubData },
  { "glNamedBufferSubDataEXT", "GL_EXT_direct_state_access", glNamedBufferSubDataEXT },
  { "glNamedCopyBufferSubDataEXT", "GL_EXT_direct_state_access", glNamedCopyBufferSubDataEXT },
  { "glNamedFramebufferDrawBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferDrawBuffer },
  { "glNamedFramebufferDrawBuffers", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferDrawBuffers },
  { "glNamedFramebufferParameteri", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferParameteri },
  { "glNamedFramebufferParameteriEXT", "GL_EXT_direct_state_access", glNamedFramebufferParameteriEXT },
  { "glNamedFramebufferReadBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferReadBuffer },
  { "glNamedFramebufferRenderbuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferRenderbuffer },
  { "glNamedFramebufferRenderbufferEXT", "GL_EXT_direct_state_access", glNamedFramebufferRenderbufferEXT },
  { "glNamedFramebufferSampleLocationsfvARB", "GL_ARB_sample_locations", glNamedFramebufferSampleLocationsfvARB },
  { "glNamedFramebufferSampleLocationsfvNV", "GL_NV_sample_locations", glNamedFramebufferSampleLocationsfvNV },
  { "glNamedFramebufferSamplePositionsfvAMD", "GL_AMD_framebuffer_sample_positions", glNamedFramebufferSamplePositionsfvAMD },
  { "glNamedFramebufferTexture", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferTexture },
  { "glNamedFramebufferTexture1DEXT", "GL_EXT_direct_state_access", glNamedFramebufferTexture1DEXT },
  { "glNamedFramebufferTexture2DEXT", "GL_EXT_direct_state_access", glNamedFramebufferTexture2DEXT },
  { "glNamedFramebufferTexture3DEXT", "GL_EXT_direct_state_access", glNamedFramebufferTexture3DEXT },
  { "glNamedFramebufferTextureEXT", "GL_EXT_direct_state_access", glNamedFramebufferTextureEXT },
  { "glNamedFramebufferTextureFaceEXT", "GL_EXT_direct_state_access", glNamedFramebufferTextureFaceEXT },
  { "glNamedFramebufferTextureLayer", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedFramebufferTextureLayer },
  { "glNamedFramebufferTextureLayerEXT", "GL_EXT_direct_state_access", glNamedFramebufferTextureLayerEXT },
  { "glNamedProgramLocalParameter4dEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameter4dEXT },
  { "glNamedProgramLocalParameter4dvEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameter4dvEXT },
  { "glNamedProgramLocalParameter4fEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameter4fEXT },
  { "glNamedProgramLocalParameter4fvEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameter4fvEXT },
  { "glNamedProgramLocalParameterI4iEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameterI4iEXT },
  { "glNamedProgramLocalParameterI4ivEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameterI4ivEXT },
  { "glNamedProgramLocalParameterI4uiEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameterI4uiEXT },
  { "glNamedProgramLocalParameterI4uivEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameterI4uivEXT },
  { "glNamedProgramLocalParameters4fvEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParameters4fvEXT },
  { "glNamedProgramLocalParametersI4ivEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParametersI4ivEXT },
  { "glNamedProgramLocalParametersI4uivEXT", "GL_EXT_direct_state_access", glNamedProgramLocalParametersI4uivEXT },
  { "glNamedProgramStringEXT", "GL_EXT_direct_state_access", glNamedProgramStringEXT },
  { "glNamedRenderbufferStorage", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedRenderbufferStorage },
  { "glNamedRenderbufferStorageEXT", "GL_EXT_direct_state_access", glNamedRenderbufferStorageEXT },
  { "glNamedRenderbufferStorageMultisample", "GL_ARB_direct_state_access GL_VERSION_4_5", glNamedRenderbufferStorageMultisample },
  { "glNamedRenderbufferStorageMultisampleAdvancedAMD", "GL_AMD_framebuffer_multisample_advanced", glNamedRenderbufferStorageMultisampleAdvancedAMD },
  { "glNamedRenderbufferStorageMultisampleCoverageEXT", "GL_EXT_direct_state_access", glNamedRenderbufferStorageMultisampleCoverageEXT },
  { "glNamedRenderbufferStorageMultisampleEXT", "GL_EXT_direct_state_access", glNamedRenderbufferStorageMultisampleEXT },
  { "glNamedStringARB", "GL_ARB_shading_language_include", glNamedStringARB },
  { "glNewBufferRegion", "GL_KTX_buffer_region", glNewBufferRegion },
  { "glNewObjectBufferATI", "GL_ATI_vertex_array_object", glNewObjectBufferATI },
  { "glNormal3fVertex3fSUN", "GL_SUN_vertex", glNormal3fVertex3fSUN },
  { "glNormal3fVertex3fvSUN", "GL_SUN_vertex", glNormal3fVertex3fvSUN },
  { "glNormal3hNV", "GL_NV_half_float", glNormal3hNV },
  { "glNormal3hvNV", "GL_NV_half_float", glNormal3hvNV },
  { "glNormal3xOES", "GL_OES_fixed_point", glNormal3xOES },
  { "glNormal3xvOES", "GL_OES_fixed_point", glNormal3xvOES },
  { "glNormalFormatNV", "GL_NV_vertex_buffer_unified_memory", glNormalFormatNV },
  { "glNormalP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glNormalP3ui },
  { "glNormalP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glNormalP3uiv },
  { "glNormalPointerEXT", "GL_EXT_vertex_array", glNormalPointerEXT },
  { "glNormalPointerListIBM", "GL_IBM_vertex_array_lists", glNormalPointerListIBM },
  { "glNormalPointervINTEL", "GL_INTEL_parallel_arrays", glNormalPointervINTEL },
  { "glNormalStream3bATI", "GL_ATI_vertex_streams", glNormalStream3bATI },
  { "glNormalStream3bvATI", "GL_ATI_vertex_streams", glNormalStream3bvATI },
  { "glNormalStream3dATI", "GL_ATI_vertex_streams", glNormalStream3dATI },
  { "glNormalStream3dvATI", "GL_ATI_vertex_streams", glNormalStream3dvATI },
  { "glNormalStream3fATI", "GL_ATI_vertex_streams", glNormalStream3fATI },
  { "glNormalStream3fvATI", "GL_ATI_vertex_streams", glNormalStream3fvATI },
  { "glNormalStream3iATI", "GL_ATI_vertex_streams", glNormalStream3iATI },
  { "glNormalStream3ivATI", "GL_ATI_vertex_streams", glNormalStream3ivATI },
  { "glNormalStream3sATI", "GL_ATI_vertex_streams", glNormalStream3sATI },
  { "glNormalStream3svATI", "GL_ATI_vertex_streams", glNormalStream3svATI },
  { "glObjectLabel", "GL_KHR_debug GL_VERSION_4_3", glObjectLabel },
  { "glObjectPtrLabel", "GL_KHR_debug GL_VERSION_4_3", glObjectPtrLabel },
  { "glObjectPurgeableAPPLE", "GL_APPLE_object_purgeable", glObjectPurgeableAPPLE },
  { "glObjectUnpurgeableAPPLE", "GL_APPLE_object_purgeable", glObjectUnpurgeableAPPLE },
  { "glOrthofOES", "GL_OES_single_precision", glOrthofOES },
  { "glOrthoxOES", "GL_OES_fixed_point", glOrthoxOES },
  { "glPNTrianglesfATI", "GL_ATI_pn_triangles", glPNTrianglesfATI },
  { "glPNTrianglesiATI", "GL_ATI_pn_triangles", glPNTrianglesiATI },
  { "glPassTexCoordATI", "GL_ATI_fragment_shader", glPassTexCoordATI },
  { "glPassThroughxOES", "GL_OES_fixed_point", glPassThroughxOES },
  { "glPatchParameterfv", "GL_ARB_tessellation_shader GL_VERSION_4_0", glPatchParameterfv },
  { "glPatchParameteri", "GL_ARB_tessellation_shader GL_VERSION_4_0", glPatchParameteri },
  { "glPathColorGenNV", "GL_NV_path_rendering", glPathColorGenNV },
  { "glPathCommandsNV", "GL_NV_path_rendering", glPathCommandsNV },
  { "glPathCoordsNV", "GL_NV_path_rendering", glPathCoordsNV },
  { "glPathCoverDepthFuncNV", "GL_NV_path_rendering", glPathCoverDepthFuncNV },
  { "glPathDashArrayNV", "GL_NV_path_rendering", glPathDashArrayNV },
  { "glPathFogGenNV", "GL_NV_path_rendering", glPathFogGenNV },
  { "glPathGlyphIndexArrayNV", "GL_NV_path_rendering", glPathGlyphIndexArrayNV },
  { "glPathGlyphIndexRangeNV", "GL_NV_path_rendering", glPathGlyphIndexRangeNV },
  { "glPathGlyphRangeNV", "GL_NV_path_rendering", glPathGlyphRangeNV },
  { "glPathGlyphsNV", "GL_NV_path_rendering", glPathGlyphsNV },
  { "glPathMemoryGlyphIndexArrayNV", "GL_NV_path_rendering", glPathMemoryGlyphIndexArrayNV },
  { "glPathParameterfNV", "GL_NV_path_rendering", glPathParameterfNV },
  { "glPathParameterfvNV", "GL_NV_path_rendering", glPathParameterfvNV },
  { "glPathParameteriNV", "GL_NV_path_rendering", glPathParameteriNV },
  { "glPathParameterivNV", "GL_NV_path_rendering", glPathParameterivNV },
  { "glPathStencilDepthOffsetNV", "GL_NV_path_rendering", glPathStencilDepthOffsetNV },
  { "glPathStencilFuncNV", "GL_NV_path_rendering", glPathStencilFuncNV },
  { "glPathStringNV", "GL_NV_path_rendering", glPathStringNV },
  { "glPathSubCommandsNV", "GL_NV_path_rendering", glPathSubCommandsNV },
  { "glPathSubCoordsNV", "GL_NV_path_rendering", glPathSubCoordsNV },
  { "glPathTexGenNV", "GL_NV_path_rendering", glPathTexGenNV },
  { "glPauseTransformFeedback", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glPauseTransformFeedback },
  { "glPauseTransformFeedbackNV", "GL_NV_transform_feedback2", glPauseTransformFeedbackNV },
  { "glPixelDataRangeNV", "GL_NV_pixel_data_range", glPixelDataRangeNV },
  { "glPixelMapx", "GL_OES_fixed_point", glPixelMapx },
  { "glPixelStorex", "GL_OES_fixed_point", glPixelStorex },
  { "glPixelTexGenParameterfSGIS", "GL_SGIS_pixel_texture", glPixelTexGenParameterfSGIS },
  { "glPixelTexGenParameterfvSGIS", "GL_SGIS_pixel_texture", glPixelTexGenParameterfvSGIS },
  { "glPixelTexGenParameteriSGIS", "GL_SGIS_pixel_texture", glPixelTexGenParameteriSGIS },
  { "glPixelTexGenParameterivSGIS", "GL_SGIS_pixel_texture", glPixelTexGenParameterivSGIS },
  { "glPixelTexGenSGIX", "GL_SGIX_pixel_texture", glPixelTexGenSGIX },
  { "glPixelTransferxOES", "GL_OES_fixed_point", glPixelTransferxOES },
  { "glPixelTransformParameterfEXT", "GL_EXT_pixel_transform", glPixelTransformParameterfEXT },
  { "glPixelTransformParameterfvEXT", "GL_EXT_pixel_transform", glPixelTransformParameterfvEXT },
  { "glPixelTransformParameteriEXT", "GL_EXT_pixel_transform", glPixelTransformParameteriEXT },
  { "glPixelTransformParameterivEXT", "GL_EXT_pixel_transform", glPixelTransformParameterivEXT },
  { "glPixelZoomxOES", "GL_OES_fixed_point", glPixelZoomxOES },
  { "glPointAlongPathNV", "GL_NV_path_rendering", glPointAlongPathNV },
  { "glPointParameterf", "GL_VERSION_1_4", glPointParameterf },
  { "glPointParameterfARB", "GL_ARB_point_parameters", glPointParameterfARB },
  { "glPointParameterfEXT", "GL_EXT_point_parameters", glPointParameterfEXT },
  { "glPointParameterfSGIS", "GL_SGIS_point_parameters", glPointParameterfSGIS },
  { "glPointParameterfv", "GL_VERSION_1_4", glPointParameterfv },
  { "glPointParameterfvARB", "GL_ARB_point_parameters", glPointParameterfvARB },
  { "glPointParameterfvEXT", "GL_EXT_point_parameters", glPointParameterfvEXT },
  { "glPointParameterfvSGIS", "GL_SGIS_point_parameters", glPointParameterfvSGIS },
  { "glPointParameteri", "GL_VERSION_1_4", glPointParameteri },
  { "glPointParameteriNV", "GL_NV_point_sprite", glPointParameteriNV },
  { "glPointParameteriv", "GL_VERSION_1_4", glPointParameteriv },
  { "glPointParameterivNV", "GL_NV_point_sprite", glPointParameterivNV },
  { "glPointParameterxvOES", "GL_OES_fixed_point", glPointParameterxvOES },
  { "glPointSizexOES", "GL_OES_fixed_point", glPointSizexOES },
  { "glPollAsyncSGIX", "GL_SGIX_async", glPollAsyncSGIX },
  { "glPollInstrumentsSGIX", "GL_SGIX_instruments", glPollInstrumentsSGIX },
  { "glPolygonOffsetClamp", "GL_ARB_polygon_offset_clamp GL_VERSION_4_6", glPolygonOffsetClamp },
  { "glPolygonOffsetClampEXT", "GL_EXT_polygon_offset_clamp", glPolygonOffsetClampEXT },
  { "glPolygonOffsetEXT", "GL_EXT_polygon_offset", glPolygonOffsetEXT },
  { "glPolygonOffsetxOES", "GL_OES_fixed_point", glPolygonOffsetxOES },
  { "glPopDebugGroup", "GL_KHR_debug GL_VERSION_4_3", glPopDebugGroup },
  { "glPopGroupMarkerEXT", "GL_EXT_debug_marker", glPopGroupMarkerEXT },
  { "glPresentFrameDualFillNV", "GL_NV_present_video", glPresentFrameDualFillNV },
  { "glPresentFrameKeyedNV", "GL_NV_present_video", glPresentFrameKeyedNV },
  { "glPrimitiveBoundingBoxARB", "GL_ARB_ES3_2_compatibility", glPrimitiveBoundingBoxARB },
  { "glPrimitiveRestartIndex", "GL_VERSION_3_1", glPrimitiveRestartIndex },
  { "glPrimitiveRestartIndexNV", "GL_NV_primitive_restart", glPrimitiveRestartIndexNV },
  { "glPrimitiveRestartNV", "GL_NV_primitive_restart", glPrimitiveRestartNV },
  { "glPrioritizeTexturesEXT", "GL_EXT_texture_object", glPrioritizeTexturesEXT },
  { "glPrioritizeTexturesxOES", "GL_OES_fixed_point", glPrioritizeTexturesxOES },
  { "glProgramBinary", "GL_ARB_get_program_binary GL_VERSION_4_1", glProgramBinary },
  { "glProgramBufferParametersIivNV", "GL_NV_parameter_buffer_object", glProgramBufferParametersIivNV },
  { "glProgramBufferParametersIuivNV", "GL_NV_parameter_buffer_object", glProgramBufferParametersIuivNV },
  { "glProgramBufferParametersfvNV", "GL_NV_parameter_buffer_object", glProgramBufferParametersfvNV },
  { "glProgramEnvParameter4dARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramEnvParameter4dARB },
  { "glProgramEnvParameter4dvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramEnvParameter4dvARB },
  { "glProgramEnvParameter4fARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramEnvParameter4fARB },
  { "glProgramEnvParameter4fvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramEnvParameter4fvARB },
  { "glProgramEnvParameterI4iNV", "GL_NV_gpu_program4", glProgramEnvParameterI4iNV },
  { "glProgramEnvParameterI4ivNV", "GL_NV_gpu_program4", glProgramEnvParameterI4ivNV },
  { "glProgramEnvParameterI4uiNV", "GL_NV_gpu_program4", glProgramEnvParameterI4uiNV },
  { "glProgramEnvParameterI4uivNV", "GL_NV_gpu_program4", glProgramEnvParameterI4uivNV },
  { "glProgramEnvParameters4fvEXT", "GL_EXT_gpu_program_parameters", glProgramEnvParameters4fvEXT },
  { "glProgramEnvParametersI4ivNV", "GL_NV_gpu_program4", glProgramEnvParametersI4ivNV },
  { "glProgramEnvParametersI4uivNV", "GL_NV_gpu_program4", glProgramEnvParametersI4uivNV },
  { "glProgramLocalParameter4dARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramLocalParameter4dARB },
  { "glProgramLocalParameter4dvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramLocalParameter4dvARB },
  { "glProgramLocalParameter4fARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramLocalParameter4fARB },
  { "glProgramLocalParameter4fvARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramLocalParameter4fvARB },
  { "glProgramLocalParameterI4iNV", "GL_NV_gpu_program4", glProgramLocalParameterI4iNV },
  { "glProgramLocalParameterI4ivNV", "GL_NV_gpu_program4", glProgramLocalParameterI4ivNV },
  { "glProgramLocalParameterI4uiNV", "GL_NV_gpu_program4", glProgramLocalParameterI4uiNV },
  { "glProgramLocalParameterI4uivNV", "GL_NV_gpu_program4", glProgramLocalParameterI4uivNV },
  { "glProgramLocalParameters4fvEXT", "GL_EXT_gpu_program_parameters", glProgramLocalParameters4fvEXT },
  { "glProgramLocalParametersI4ivNV", "GL_NV_gpu_program4", glProgramLocalParametersI4ivNV },
  { "glProgramLocalParametersI4uivNV", "GL_NV_gpu_program4", glProgramLocalParametersI4uivNV },
  { "glProgramNamedParameter4dNV", "GL_NV_fragment_program", glProgramNamedParameter4dNV },
  { "glProgramNamedParameter4dvNV", "GL_NV_fragment_program", glProgramNamedParameter4dvNV },
  { "glProgramNamedParameter4fNV", "GL_NV_fragment_program", glProgramNamedParameter4fNV },
  { "glProgramNamedParameter4fvNV", "GL_NV_fragment_program", glProgramNamedParameter4fvNV },
  { "glProgramParameter4dNV", "GL_NV_vertex_program", glProgramParameter4dNV },
  { "glProgramParameter4dvNV", "GL_NV_vertex_program", glProgramParameter4dvNV },
  { "glProgramParameter4fNV", "GL_NV_vertex_program", glProgramParameter4fNV },
  { "glProgramParameter4fvNV", "GL_NV_vertex_program", glProgramParameter4fvNV },
  { "glProgramParameteri", "GL_ARB_get_program_binary GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramParameteri },
  { "glProgramParameteriARB", "GL_ARB_geometry_shader4", glProgramParameteriARB },
  { "glProgramParameteriEXT", "GL_EXT_geometry_shader4", glProgramParameteriEXT },
  { "glProgramParameters4dvNV", "GL_NV_vertex_program", glProgramParameters4dvNV },
  { "glProgramParameters4fvNV", "GL_NV_vertex_program", glProgramParameters4fvNV },
  { "glProgramPathFragmentInputGenNV", "GL_NV_path_rendering", glProgramPathFragmentInputGenNV },
  { "glProgramStringARB", "GL_ARB_fragment_program GL_ARB_vertex_program", glProgramStringARB },
  { "glProgramSubroutineParametersuivNV", "GL_NV_gpu_program5", glProgramSubroutineParametersuivNV },
  { "glProgramUniform1d", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1d },
  { "glProgramUniform1dEXT", "GL_EXT_direct_state_access", glProgramUniform1dEXT },
  { "glProgramUniform1dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1dv },
  { "glProgramUniform1dvEXT", "GL_EXT_direct_state_access", glProgramUniform1dvEXT },
  { "glProgramUniform1f", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1f },
  { "glProgramUniform1fEXT", "GL_EXT_direct_state_access", glProgramUniform1fEXT },
  { "glProgramUniform1fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1fv },
  { "glProgramUniform1fvEXT", "GL_EXT_direct_state_access", glProgramUniform1fvEXT },
  { "glProgramUniform1i", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1i },
  { "glProgramUniform1i64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform1i64ARB },
  { "glProgramUniform1i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform1i64NV },
  { "glProgramUniform1i64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform1i64vARB },
  { "glProgramUniform1i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform1i64vNV },
  { "glProgramUniform1iEXT", "GL_EXT_direct_state_access", glProgramUniform1iEXT },
  { "glProgramUniform1iv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1iv },
  { "glProgramUniform1ivEXT", "GL_EXT_direct_state_access", glProgramUniform1ivEXT },
  { "glProgramUniform1ui", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1ui },
  { "glProgramUniform1ui64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform1ui64ARB },
  { "glProgramUniform1ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform1ui64NV },
  { "glProgramUniform1ui64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform1ui64vARB },
  { "glProgramUniform1ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform1ui64vNV },
  { "glProgramUniform1uiEXT", "GL_EXT_direct_state_access", glProgramUniform1uiEXT },
  { "glProgramUniform1uiv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform1uiv },
  { "glProgramUniform1uivEXT", "GL_EXT_direct_state_access", glProgramUniform1uivEXT },
  { "glProgramUniform2d", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2d },
  { "glProgramUniform2dEXT", "GL_EXT_direct_state_access", glProgramUniform2dEXT },
  { "glProgramUniform2dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2dv },
  { "glProgramUniform2dvEXT", "GL_EXT_direct_state_access", glProgramUniform2dvEXT },
  { "glProgramUniform2f", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2f },
  { "glProgramUniform2fEXT", "GL_EXT_direct_state_access", glProgramUniform2fEXT },
  { "glProgramUniform2fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2fv },
  { "glProgramUniform2fvEXT", "GL_EXT_direct_state_access", glProgramUniform2fvEXT },
  { "glProgramUniform2i", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2i },
  { "glProgramUniform2i64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform2i64ARB },
  { "glProgramUniform2i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform2i64NV },
  { "glProgramUniform2i64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform2i64vARB },
  { "glProgramUniform2i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform2i64vNV },
  { "glProgramUniform2iEXT", "GL_EXT_direct_state_access", glProgramUniform2iEXT },
  { "glProgramUniform2iv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2iv },
  { "glProgramUniform2ivEXT", "GL_EXT_direct_state_access", glProgramUniform2ivEXT },
  { "glProgramUniform2ui", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2ui },
  { "glProgramUniform2ui64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform2ui64ARB },
  { "glProgramUniform2ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform2ui64NV },
  { "glProgramUniform2ui64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform2ui64vARB },
  { "glProgramUniform2ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform2ui64vNV },
  { "glProgramUniform2uiEXT", "GL_EXT_direct_state_access", glProgramUniform2uiEXT },
  { "glProgramUniform2uiv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform2uiv },
  { "glProgramUniform2uivEXT", "GL_EXT_direct_state_access", glProgramUniform2uivEXT },
  { "glProgramUniform3d", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3d },
  { "glProgramUniform3dEXT", "GL_EXT_direct_state_access", glProgramUniform3dEXT },
  { "glProgramUniform3dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3dv },
  { "glProgramUniform3dvEXT", "GL_EXT_direct_state_access", glProgramUniform3dvEXT },
  { "glProgramUniform3f", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3f },
  { "glProgramUniform3fEXT", "GL_EXT_direct_state_access", glProgramUniform3fEXT },
  { "glProgramUniform3fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3fv },
  { "glProgramUniform3fvEXT", "GL_EXT_direct_state_access", glProgramUniform3fvEXT },
  { "glProgramUniform3i", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3i },
  { "glProgramUniform3i64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform3i64ARB },
  { "glProgramUniform3i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform3i64NV },
  { "glProgramUniform3i64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform3i64vARB },
  { "glProgramUniform3i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform3i64vNV },
  { "glProgramUniform3iEXT", "GL_EXT_direct_state_access", glProgramUniform3iEXT },
  { "glProgramUniform3iv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3iv },
  { "glProgramUniform3ivEXT", "GL_EXT_direct_state_access", glProgramUniform3ivEXT },
  { "glProgramUniform3ui", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3ui },
  { "glProgramUniform3ui64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform3ui64ARB },
  { "glProgramUniform3ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform3ui64NV },
  { "glProgramUniform3ui64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform3ui64vARB },
  { "glProgramUniform3ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform3ui64vNV },
  { "glProgramUniform3uiEXT", "GL_EXT_direct_state_access", glProgramUniform3uiEXT },
  { "glProgramUniform3uiv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform3uiv },
  { "glProgramUniform3uivEXT", "GL_EXT_direct_state_access", glProgramUniform3uivEXT },
  { "glProgramUniform4d", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4d },
  { "glProgramUniform4dEXT", "GL_EXT_direct_state_access", glProgramUniform4dEXT },
  { "glProgramUniform4dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4dv },
  { "glProgramUniform4dvEXT", "GL_EXT_direct_state_access", glProgramUniform4dvEXT },
  { "glProgramUniform4f", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4f },
  { "glProgramUniform4fEXT", "GL_EXT_direct_state_access", glProgramUniform4fEXT },
  { "glProgramUniform4fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4fv },
  { "glProgramUniform4fvEXT", "GL_EXT_direct_state_access", glProgramUniform4fvEXT },
  { "glProgramUniform4i", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4i },
  { "glProgramUniform4i64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform4i64ARB },
  { "glProgramUniform4i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform4i64NV },
  { "glProgramUniform4i64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform4i64vARB },
  { "glProgramUniform4i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform4i64vNV },
  { "glProgramUniform4iEXT", "GL_EXT_direct_state_access", glProgramUniform4iEXT },
  { "glProgramUniform4iv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4iv },
  { "glProgramUniform4ivEXT", "GL_EXT_direct_state_access", glProgramUniform4ivEXT },
  { "glProgramUniform4ui", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4ui },
  { "glProgramUniform4ui64ARB", "GL_ARB_gpu_shader_int64", glProgramUniform4ui64ARB },
  { "glProgramUniform4ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform4ui64NV },
  { "glProgramUniform4ui64vARB", "GL_ARB_gpu_shader_int64", glProgramUniform4ui64vARB },
  { "glProgramUniform4ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glProgramUniform4ui64vNV },
  { "glProgramUniform4uiEXT", "GL_EXT_direct_state_access", glProgramUniform4uiEXT },
  { "glProgramUniform4uiv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniform4uiv },
  { "glProgramUniform4uivEXT", "GL_EXT_direct_state_access", glProgramUniform4uivEXT },
  { "glProgramUniformHandleui64ARB", "GL_ARB_bindless_texture", glProgramUniformHandleui64ARB },
  { "glProgramUniformHandleui64NV", "GL_NV_bindless_texture", glProgramUniformHandleui64NV },
  { "glProgramUniformHandleui64vARB", "GL_ARB_bindless_texture", glProgramUniformHandleui64vARB },
  { "glProgramUniformHandleui64vNV", "GL_NV_bindless_texture", glProgramUniformHandleui64vNV },
  { "glProgramUniformMatrix2dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2dv },
  { "glProgramUniformMatrix2dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2dvEXT },
  { "glProgramUniformMatrix2fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2fv },
  { "glProgramUniformMatrix2fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2fvEXT },
  { "glProgramUniformMatrix2x3dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2x3dv },
  { "glProgramUniformMatrix2x3dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2x3dvEXT },
  { "glProgramUniformMatrix2x3fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2x3fv },
  { "glProgramUniformMatrix2x3fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2x3fvEXT },
  { "glProgramUniformMatrix2x4dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2x4dv },
  { "glProgramUniformMatrix2x4dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2x4dvEXT },
  { "glProgramUniformMatrix2x4fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix2x4fv },
  { "glProgramUniformMatrix2x4fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix2x4fvEXT },
  { "glProgramUniformMatrix3dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3dv },
  { "glProgramUniformMatrix3dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3dvEXT },
  { "glProgramUniformMatrix3fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3fv },
  { "glProgramUniformMatrix3fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3fvEXT },
  { "glProgramUniformMatrix3x2dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3x2dv },
  { "glProgramUniformMatrix3x2dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3x2dvEXT },
  { "glProgramUniformMatrix3x2fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3x2fv },
  { "glProgramUniformMatrix3x2fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3x2fvEXT },
  { "glProgramUniformMatrix3x4dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3x4dv },
  { "glProgramUniformMatrix3x4dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3x4dvEXT },
  { "glProgramUniformMatrix3x4fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix3x4fv },
  { "glProgramUniformMatrix3x4fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix3x4fvEXT },
  { "glProgramUniformMatrix4dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4dv },
  { "glProgramUniformMatrix4dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4dvEXT },
  { "glProgramUniformMatrix4fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4fv },
  { "glProgramUniformMatrix4fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4fvEXT },
  { "glProgramUniformMatrix4x2dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4x2dv },
  { "glProgramUniformMatrix4x2dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4x2dvEXT },
  { "glProgramUniformMatrix4x2fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4x2fv },
  { "glProgramUniformMatrix4x2fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4x2fvEXT },
  { "glProgramUniformMatrix4x3dv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4x3dv },
  { "glProgramUniformMatrix4x3dvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4x3dvEXT },
  { "glProgramUniformMatrix4x3fv", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glProgramUniformMatrix4x3fv },
  { "glProgramUniformMatrix4x3fvEXT", "GL_EXT_direct_state_access", glProgramUniformMatrix4x3fvEXT },
  { "glProgramUniformui64NV", "GL_NV_shader_buffer_load", glProgramUniformui64NV },
  { "glProgramUniformui64vNV", "GL_NV_shader_buffer_load", glProgramUniformui64vNV },
  { "glProgramVertexLimitNV", "GL_NV_geometry_program4", glProgramVertexLimitNV },
  { "glProvokingVertex", "GL_ARB_provoking_vertex GL_VERSION_3_2", glProvokingVertex },
  { "glProvokingVertexEXT", "GL_EXT_provoking_vertex", glProvokingVertexEXT },
  { "glPushClientAttribDefaultEXT", "GL_EXT_direct_state_access", glPushClientAttribDefaultEXT },
  { "glPushDebugGroup", "GL_KHR_debug GL_VERSION_4_3", glPushDebugGroup },
  { "glPushGroupMarkerEXT", "GL_EXT_debug_marker", glPushGroupMarkerEXT },
  { "glQueryCounter", "GL_ARB_timer_query GL_VERSION_3_3", glQueryCounter },
  { "glQueryMatrixxOES", "GL_OES_query_matrix", glQueryMatrixxOES },
  { "glQueryObjectParameteruiAMD", "GL_AMD_occlusion_query_event", glQueryObjectParameteruiAMD },
  { "glQueryResourceNV", "GL_NV_query_resource", glQueryResourceNV },
  { "glQueryResourceTagNV", "GL_NV_query_resource_tag", glQueryResourceTagNV },
  { "glRasterPos2xOES", "GL_OES_fixed_point", glRasterPos2xOES },
  { "glRasterPos2xvOES", "GL_OES_fixed_point", glRasterPos2xvOES },
  { "glRasterPos3xOES", "GL_OES_fixed_point", glRasterPos3xOES },
  { "glRasterPos3xvOES", "GL_OES_fixed_point", glRasterPos3xvOES },
  { "glRasterPos4xOES", "GL_OES_fixed_point", glRasterPos4xOES },
  { "glRasterPos4xvOES", "GL_OES_fixed_point", glRasterPos4xvOES },
  { "glRasterSamplesEXT", "GL_EXT_raster_multisample GL_NV_framebuffer_mixed_samples", glRasterSamplesEXT },
  { "glReadBufferRegion", "GL_KTX_buffer_region", glReadBufferRegion },
  { "glReadInstrumentsSGIX", "GL_SGIX_instruments", glReadInstrumentsSGIX },
  { "glReadnPixels", "GL_KHR_robustness GL_VERSION_4_5", glReadnPixels },
  { "glReadnPixelsARB", "GL_ARB_robustness", glReadnPixelsARB },
  { "glRectxOES", "GL_OES_fixed_point", glRectxOES },
  { "glRectxvOES", "GL_OES_fixed_point", glRectxvOES },
  { "glReferencePlaneSGIX", "GL_SGIX_reference_plane", glReferencePlaneSGIX },
  { "glReleaseKeyedMutexWin32EXT", "GL_EXT_win32_keyed_mutex", glReleaseKeyedMutexWin32EXT },
  { "glReleaseShaderCompiler", "GL_ARB_ES2_compatibility GL_VERSION_4_1", glReleaseShaderCompiler },
  { "glRenderGpuMaskNV", "GL_NV_gpu_multicast", glRenderGpuMaskNV },
  { "glRenderbufferStorage", "GL_ARB_framebuffer_object GL_VERSION_3_0", glRenderbufferStorage },
  { "glRenderbufferStorageEXT", "GL_EXT_framebuffer_object", glRenderbufferStorageEXT },
  { "glRenderbufferStorageMultisample", "GL_ARB_framebuffer_object GL_VERSION_3_0", glRenderbufferStorageMultisample },
  { "glRenderbufferStorageMultisampleAdvancedAMD", "GL_AMD_framebuffer_multisample_advanced", glRenderbufferStorageMultisampleAdvancedAMD },
  { "glRenderbufferStorageMultisampleCoverageNV", "GL_NV_framebuffer_multisample_coverage", glRenderbufferStorageMultisampleCoverageNV },
  { "glRenderbufferStorageMultisampleEXT", "GL_EXT_framebuffer_multisample", glRenderbufferStorageMultisampleEXT },
  { "glReplacementCodePointerSUN", "GL_SUN_triangle_list", glReplacementCodePointerSUN },
  { "glReplacementCodeubSUN", "GL_SUN_triangle_list", glReplacementCodeubSUN },
  { "glReplacementCodeubvSUN", "GL_SUN_triangle_list", glReplacementCodeubvSUN },
  { "glReplacementCodeuiColor3fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiColor3fVertex3fSUN },
  { "glReplacementCodeuiColor3fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiColor3fVertex3fvSUN },
  { "glReplacementCodeuiColor4fNormal3fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiColor4fNormal3fVertex3fSUN },
  { "glReplacementCodeuiColor4fNormal3fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiColor4fNormal3fVertex3fvSUN },
  { "glReplacementCodeuiColor4ubVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiColor4ubVertex3fSUN },
  { "glReplacementCodeuiColor4ubVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiColor4ubVertex3fvSUN },
  { "glReplacementCodeuiNormal3fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiNormal3fVertex3fSUN },
  { "glReplacementCodeuiNormal3fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiNormal3fVertex3fvSUN },
  { "glReplacementCodeuiSUN", "GL_SUN_triangle_list", glReplacementCodeuiSUN },
  { "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN },
  { "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN },
  { "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN },
  { "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN },
  { "glReplacementCodeuiTexCoord2fVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fVertex3fSUN },
  { "glReplacementCodeuiTexCoord2fVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiTexCoord2fVertex3fvSUN },
  { "glReplacementCodeuiVertex3fSUN", "GL_SUN_vertex", glReplacementCodeuiVertex3fSUN },
  { "glReplacementCodeuiVertex3fvSUN", "GL_SUN_vertex", glReplacementCodeuiVertex3fvSUN },
  { "glReplacementCodeuivSUN", "GL_SUN_triangle_list", glReplacementCodeuivSUN },
  { "glReplacementCodeusSUN", "GL_SUN_triangle_list", glReplacementCodeusSUN },
  { "glReplacementCodeusvSUN", "GL_SUN_triangle_list", glReplacementCodeusvSUN },
  { "glRequestResidentProgramsNV", "GL_NV_vertex_program", glRequestResidentProgramsNV },
  { "glResetHistogram", "GL_ARB_imaging", glResetHistogram },
  { "glResetHistogramEXT", "GL_EXT_histogram", glResetHistogramEXT },
  { "glResetMemoryObjectParameterNV", "GL_NV_memory_attachment", glResetMemoryObjectParameterNV },
  { "glResetMinmax", "GL_ARB_imaging", glResetMinmax },
  { "glResetMinmaxEXT", "GL_EXT_histogram", glResetMinmaxEXT },
  { "glResizeBuffersMESA", "GL_MESA_resize_buffers", glResizeBuffersMESA },
  { "glResolveDepthValuesNV", "GL_NV_sample_locations", glResolveDepthValuesNV },
  { "glResumeTransformFeedback", "GL_ARB_transform_feedback2 GL_VERSION_4_0", glResumeTransformFeedback },
  { "glResumeTransformFeedbackNV", "GL_NV_transform_feedback2", glResumeTransformFeedbackNV },
  { "glRotatexOES", "GL_OES_fixed_point", glRotatexOES },
  { "glSampleCoverage", "GL_VERSION_1_3", glSampleCoverage },
  { "glSampleCoverageARB", "GL_ARB_multisample", glSampleCoverageARB },
  { "glSampleMapATI", "GL_ATI_fragment_shader", glSampleMapATI },
  { "glSampleMaskEXT", "GL_EXT_multisample", glSampleMaskEXT },
  { "glSampleMaskIndexedNV", "GL_NV_explicit_multisample", glSampleMaskIndexedNV },
  { "glSampleMaskSGIS", "GL_SGIS_multisample", glSampleMaskSGIS },
  { "glSampleMaski", "GL_ARB_texture_multisample GL_VERSION_3_2", glSampleMaski },
  { "glSamplePatternEXT", "GL_EXT_multisample", glSamplePatternEXT },
  { "glSamplePatternSGIS", "GL_SGIS_multisample", glSamplePatternSGIS },
  { "glSamplerParameterIiv", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameterIiv },
  { "glSamplerParameterIuiv", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameterIuiv },
  { "glSamplerParameterf", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameterf },
  { "glSamplerParameterfv", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameterfv },
  { "glSamplerParameteri", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameteri },
  { "glSamplerParameteriv", "GL_ARB_sampler_objects GL_VERSION_3_3", glSamplerParameteriv },
  { "glScalexOES", "GL_OES_fixed_point", glScalexOES },
  { "glScissorArrayv", "GL_ARB_viewport_array GL_VERSION_4_1", glScissorArrayv },
  { "glScissorExclusiveArrayvNV", "GL_NV_scissor_exclusive", glScissorExclusiveArrayvNV },
  { "glScissorExclusiveNV", "GL_NV_scissor_exclusive", glScissorExclusiveNV },
  { "glScissorIndexed", "GL_ARB_viewport_array GL_VERSION_4_1", glScissorIndexed },
  { "glScissorIndexedv", "GL_ARB_viewport_array GL_VERSION_4_1", glScissorIndexedv },
  { "glSecondaryColor3b", "GL_VERSION_1_4", glSecondaryColor3b },
  { "glSecondaryColor3bEXT", "GL_EXT_secondary_color", glSecondaryColor3bEXT },
  { "glSecondaryColor3bv", "GL_VERSION_1_4", glSecondaryColor3bv },
  { "glSecondaryColor3bvEXT", "GL_EXT_secondary_color", glSecondaryColor3bvEXT },
  { "glSecondaryColor3d", "GL_VERSION_1_4", glSecondaryColor3d },
  { "glSecondaryColor3dEXT", "GL_EXT_secondary_color", glSecondaryColor3dEXT },
  { "glSecondaryColor3dv", "GL_VERSION_1_4", glSecondaryColor3dv },
  { "glSecondaryColor3dvEXT", "GL_EXT_secondary_color", glSecondaryColor3dvEXT },
  { "glSecondaryColor3f", "GL_VERSION_1_4", glSecondaryColor3f },
  { "glSecondaryColor3fEXT", "GL_EXT_secondary_color", glSecondaryColor3fEXT },
  { "glSecondaryColor3fv", "GL_VERSION_1_4", glSecondaryColor3fv },
  { "glSecondaryColor3fvEXT", "GL_EXT_secondary_color", glSecondaryColor3fvEXT },
  { "glSecondaryColor3hNV", "GL_NV_half_float", glSecondaryColor3hNV },
  { "glSecondaryColor3hvNV", "GL_NV_half_float", glSecondaryColor3hvNV },
  { "glSecondaryColor3i", "GL_VERSION_1_4", glSecondaryColor3i },
  { "glSecondaryColor3iEXT", "GL_EXT_secondary_color", glSecondaryColor3iEXT },
  { "glSecondaryColor3iv", "GL_VERSION_1_4", glSecondaryColor3iv },
  { "glSecondaryColor3ivEXT", "GL_EXT_secondary_color", glSecondaryColor3ivEXT },
  { "glSecondaryColor3s", "GL_VERSION_1_4", glSecondaryColor3s },
  { "glSecondaryColor3sEXT", "GL_EXT_secondary_color", glSecondaryColor3sEXT },
  { "glSecondaryColor3sv", "GL_VERSION_1_4", glSecondaryColor3sv },
  { "glSecondaryColor3svEXT", "GL_EXT_secondary_color", glSecondaryColor3svEXT },
  { "glSecondaryColor3ub", "GL_VERSION_1_4", glSecondaryColor3ub },
  { "glSecondaryColor3ubEXT", "GL_EXT_secondary_color", glSecondaryColor3ubEXT },
  { "glSecondaryColor3ubv", "GL_VERSION_1_4", glSecondaryColor3ubv },
  { "glSecondaryColor3ubvEXT", "GL_EXT_secondary_color", glSecondaryColor3ubvEXT },
  { "glSecondaryColor3ui", "GL_VERSION_1_4", glSecondaryColor3ui },
  { "glSecondaryColor3uiEXT", "GL_EXT_secondary_color", glSecondaryColor3uiEXT },
  { "glSecondaryColor3uiv", "GL_VERSION_1_4", glSecondaryColor3uiv },
  { "glSecondaryColor3uivEXT", "GL_EXT_secondary_color", glSecondaryColor3uivEXT },
  { "glSecondaryColor3us", "GL_VERSION_1_4", glSecondaryColor3us },
  { "glSecondaryColor3usEXT", "GL_EXT_secondary_color", glSecondaryColor3usEXT },
  { "glSecondaryColor3usv", "GL_VERSION_1_4", glSecondaryColor3usv },
  { "glSecondaryColor3usvEXT", "GL_EXT_secondary_color", glSecondaryColor3usvEXT },
  { "glSecondaryColorFormatNV", "GL_NV_vertex_buffer_unified_memory", glSecondaryColorFormatNV },
  { "glSecondaryColorP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glSecondaryColorP3ui },
  { "glSecondaryColorP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glSecondaryColorP3uiv },
  { "glSecondaryColorPointer", "GL_VERSION_1_4", glSecondaryColorPointer },
  { "glSecondaryColorPointerEXT", "GL_EXT_secondary_color", glSecondaryColorPointerEXT },
  { "glSecondaryColorPointerListIBM", "GL_IBM_vertex_array_lists", glSecondaryColorPointerListIBM },
  { "glSelectPerfMonitorCountersAMD", "GL_AMD_performance_monitor", glSelectPerfMonitorCountersAMD },
  { "glSelectTextureCoordSetSGIS", "GL_SGIS_multitexture", glSelectTextureCoordSetSGIS },
  { "glSelectTextureSGIS", "GL_SGIS_multitexture", glSelectTextureSGIS },
  { "glSemaphoreParameterui64vEXT", "GL_EXT_semaphore", glSemaphoreParameterui64vEXT },
  { "glSeparableFilter2D", "GL_ARB_imaging", glSeparableFilter2D },
  { "glSeparableFilter2DEXT", "GL_EXT_convolution", glSeparableFilter2DEXT },
  { "glSetFenceAPPLE", "GL_APPLE_fence", glSetFenceAPPLE },
  { "glSetFenceNV", "GL_NV_fence", glSetFenceNV },
  { "glSetFragmentShaderConstantATI", "GL_ATI_fragment_shader", glSetFragmentShaderConstantATI },
  { "glSetInvariantEXT", "GL_EXT_vertex_shader", glSetInvariantEXT },
  { "glSetLocalConstantEXT", "GL_EXT_vertex_shader", glSetLocalConstantEXT },
  { "glSetMultisamplefvAMD", "GL_AMD_sample_positions", glSetMultisamplefvAMD },
  { "glShaderBinary", "GL_ARB_ES2_compatibility GL_VERSION_4_1", glShaderBinary },
  { "glShaderOp1EXT", "GL_EXT_vertex_shader", glShaderOp1EXT },
  { "glShaderOp2EXT", "GL_EXT_vertex_shader", glShaderOp2EXT },
  { "glShaderOp3EXT", "GL_EXT_vertex_shader", glShaderOp3EXT },
  { "glShaderSource", "GL_VERSION_2_0", glShaderSource },
  { "glShaderSourceARB", "GL_ARB_shader_objects", glShaderSourceARB },
  { "glShaderStorageBlockBinding", "GL_ARB_shader_storage_buffer_object GL_VERSION_4_3", glShaderStorageBlockBinding },
  { "glShadingRateImageBarrierNV", "GL_NV_shading_rate_image GL_NV_shading_rate_image", glShadingRateImageBarrierNV },
  { "glShadingRateImagePaletteNV", "GL_NV_shading_rate_image", glShadingRateImagePaletteNV },
  { "glShadingRateSampleOrderCustomNV", "GL_NV_shading_rate_image", glShadingRateSampleOrderCustomNV },
  { "glShadingRateSampleOrderNV", "GL_NV_shading_rate_image", glShadingRateSampleOrderNV },
  { "glSharpenTexFuncSGIS", "GL_SGIS_sharpen_texture", glSharpenTexFuncSGIS },
  { "glSignalSemaphoreEXT", "GL_EXT_semaphore", glSignalSemaphoreEXT },
  { "glSignalSemaphoreui64NVX", "GL_NVX_progress_fence", glSignalSemaphoreui64NVX },
  { "glSignalVkFenceNV", "GL_NV_draw_vulkan_image", glSignalVkFenceNV },
  { "glSignalVkSemaphoreNV", "GL_NV_draw_vulkan_image", glSignalVkSemaphoreNV },
  { "glSpecializeShader", "GL_VERSION_4_6", glSpecializeShader },
  { "glSpecializeShaderARB", "GL_ARB_gl_spirv", glSpecializeShaderARB },
  { "glSpriteParameterfSGIX", "GL_SGIX_sprite", glSpriteParameterfSGIX },
  { "glSpriteParameterfvSGIX", "GL_SGIX_sprite", glSpriteParameterfvSGIX },
  { "glSpriteParameteriSGIX", "GL_SGIX_sprite", glSpriteParameteriSGIX },
  { "glSpriteParameterivSGIX", "GL_SGIX_sprite", glSpriteParameterivSGIX },
  { "glStartInstrumentsSGIX", "GL_SGIX_instruments", glStartInstrumentsSGIX },
  { "glStateCaptureNV", "GL_NV_command_list", glStateCaptureNV },
  { "glStencilClearTagEXT", "GL_EXT_stencil_clear_tag", glStencilClearTagEXT },
  { "glStencilFillPathInstancedNV", "GL_NV_path_rendering", glStencilFillPathInstancedNV },
  { "glStencilFillPathNV", "GL_NV_path_rendering", glStencilFillPathNV },
  { "glStencilFuncSeparate", "GL_VERSION_2_0", glStencilFuncSeparate },
  { "glStencilFuncSeparateATI", "GL_ATI_separate_stencil", glStencilFuncSeparateATI },
  { "glStencilMaskSeparate", "GL_VERSION_2_0", glStencilMaskSeparate },
  { "glStencilOpSeparate", "GL_VERSION_2_0", glStencilOpSeparate },
  { "glStencilOpSeparateATI", "GL_ATI_separate_stencil", glStencilOpSeparateATI },
  { "glStencilOpValueAMD", "GL_AMD_stencil_operation_extended", glStencilOpValueAMD },
  { "glStencilStrokePathInstancedNV", "GL_NV_path_rendering", glStencilStrokePathInstancedNV },
  { "glStencilStrokePathNV", "GL_NV_path_rendering", glStencilStrokePathNV },
  { "glStencilThenCoverFillPathInstancedNV", "GL_NV_path_rendering", glStencilThenCoverFillPathInstancedNV },
  { "glStencilThenCoverFillPathNV", "GL_NV_path_rendering", glStencilThenCoverFillPathNV },
  { "glStencilThenCoverStrokePathInstancedNV", "GL_NV_path_rendering", glStencilThenCoverStrokePathInstancedNV },
  { "glStencilThenCoverStrokePathNV", "GL_NV_path_rendering", glStencilThenCoverStrokePathNV },
  { "glStopInstrumentsSGIX", "GL_SGIX_instruments", glStopInstrumentsSGIX },
  { "glStringMarkerGREMEDY", "GL_GREMEDY_string_marker", glStringMarkerGREMEDY },
  { "glSubpixelPrecisionBiasNV", "GL_NV_conservative_raster", glSubpixelPrecisionBiasNV },
  { "glSwizzleEXT", "GL_EXT_vertex_shader", glSwizzleEXT },
  { "glSyncTextureINTEL", "GL_INTEL_map_texture", glSyncTextureINTEL },
  { "glTagSampleBufferSGIX", "GL_SGIX_tag_sample_buffer", glTagSampleBufferSGIX },
  { "glTangent3bEXT", "GL_EXT_coordinate_frame", glTangent3bEXT },
  { "glTangent3bvEXT", "GL_EXT_coordinate_frame", glTangent3bvEXT },
  { "glTangent3dEXT", "GL_EXT_coordinate_frame", glTangent3dEXT },
  { "glTangent3dvEXT", "GL_EXT_coordinate_frame", glTangent3dvEXT },
  { "glTangent3fEXT", "GL_EXT_coordinate_frame", glTangent3fEXT },
  { "glTangent3fvEXT", "GL_EXT_coordinate_frame", glTangent3fvEXT },
  { "glTangent3iEXT", "GL_EXT_coordinate_frame", glTangent3iEXT },
  { "glTangent3ivEXT", "GL_EXT_coordinate_frame", glTangent3ivEXT },
  { "glTangent3sEXT", "GL_EXT_coordinate_frame", glTangent3sEXT },
  { "glTangent3svEXT", "GL_EXT_coordinate_frame", glTangent3svEXT },
  { "glTangentPointerEXT", "GL_EXT_coordinate_frame", glTangentPointerEXT },
  { "glTbufferMask3DFX", "GL_3DFX_tbuffer", glTbufferMask3DFX },
  { "glTessellationFactorAMD", "GL_AMD_vertex_shader_tessellator", glTessellationFactorAMD },
  { "glTessellationModeAMD", "GL_AMD_vertex_shader_tessellator", glTessellationModeAMD },
  { "glTestFenceAPPLE", "GL_APPLE_fence", glTestFenceAPPLE },
  { "glTestFenceNV", "GL_NV_fence", glTestFenceNV },
  { "glTestObjectAPPLE", "GL_APPLE_fence", glTestObjectAPPLE },
  { "glTexAttachMemoryNV", "GL_NV_memory_attachment", glTexAttachMemoryNV },
  { "glTexBuffer", "GL_VERSION_3_1", glTexBuffer },
  { "glTexBufferARB", "GL_ARB_texture_buffer_object", glTexBufferARB },
  { "glTexBufferEXT", "GL_EXT_texture_buffer_object", glTexBufferEXT },
  { "glTexBufferRange", "GL_ARB_texture_buffer_range GL_VERSION_4_3", glTexBufferRange },
  { "glTexBumpParameterfvATI", "GL_ATI_envmap_bumpmap", glTexBumpParameterfvATI },
  { "glTexBumpParameterivATI", "GL_ATI_envmap_bumpmap", glTexBumpParameterivATI },
  { "glTexCoord1bOES", "GL_OES_byte_coordinates", glTexCoord1bOES },
  { "glTexCoord1bvOES", "GL_OES_byte_coordinates", glTexCoord1bvOES },
  { "glTexCoord1hNV", "GL_NV_half_float", glTexCoord1hNV },
  { "glTexCoord1hvNV", "GL_NV_half_float", glTexCoord1hvNV },
  { "glTexCoord1xOES", "GL_OES_fixed_point", glTexCoord1xOES },
  { "glTexCoord1xvOES", "GL_OES_fixed_point", glTexCoord1xvOES },
  { "glTexCoord2bOES", "GL_OES_byte_coordinates", glTexCoord2bOES },
  { "glTexCoord2bvOES", "GL_OES_byte_coordinates", glTexCoord2bvOES },
  { "glTexCoord2fColor3fVertex3fSUN", "GL_SUN_vertex", glTexCoord2fColor3fVertex3fSUN },
  { "glTexCoord2fColor3fVertex3fvSUN", "GL_SUN_vertex", glTexCoord2fColor3fVertex3fvSUN },
  { "glTexCoord2fColor4fNormal3fVertex3fSUN", "GL_SUN_vertex", glTexCoord2fColor4fNormal3fVertex3fSUN },
  { "glTexCoord2fColor4fNormal3fVertex3fvSUN", "GL_SUN_vertex", glTexCoord2fColor4fNormal3fVertex3fvSUN },
  { "glTexCoord2fColor4ubVertex3fSUN", "GL_SUN_vertex", glTexCoord2fColor4ubVertex3fSUN },
  { "glTexCoord2fColor4ubVertex3fvSUN", "GL_SUN_vertex", glTexCoord2fColor4ubVertex3fvSUN },
  { "glTexCoord2fNormal3fVertex3fSUN", "GL_SUN_vertex", glTexCoord2fNormal3fVertex3fSUN },
  { "glTexCoord2fNormal3fVertex3fvSUN", "GL_SUN_vertex", glTexCoord2fNormal3fVertex3fvSUN },
  { "glTexCoord2fVertex3fSUN", "GL_SUN_vertex", glTexCoord2fVertex3fSUN },
  { "glTexCoord2fVertex3fvSUN", "GL_SUN_vertex", glTexCoord2fVertex3fvSUN },
  { "glTexCoord2hNV", "GL_NV_half_float", glTexCoord2hNV },
  { "glTexCoord2hvNV", "GL_NV_half_float", glTexCoord2hvNV },
  { "glTexCoord2xOES", "GL_OES_fixed_point", glTexCoord2xOES },
  { "glTexCoord2xvOES", "GL_OES_fixed_point", glTexCoord2xvOES },
  { "glTexCoord3bOES", "GL_OES_byte_coordinates", glTexCoord3bOES },
  { "glTexCoord3bvOES", "GL_OES_byte_coordinates", glTexCoord3bvOES },
  { "glTexCoord3hNV", "GL_NV_half_float", glTexCoord3hNV },
  { "glTexCoord3hvNV", "GL_NV_half_float", glTexCoord3hvNV },
  { "glTexCoord3xOES", "GL_OES_fixed_point", glTexCoord3xOES },
  { "glTexCoord3xvOES", "GL_OES_fixed_point", glTexCoord3xvOES },
  { "glTexCoord4bOES", "GL_OES_byte_coordinates", glTexCoord4bOES },
  { "glTexCoord4bvOES", "GL_OES_byte_coordinates", glTexCoord4bvOES },
  { "glTexCoord4fColor4fNormal3fVertex4fSUN", "GL_SUN_vertex", glTexCoord4fColor4fNormal3fVertex4fSUN },
  { "glTexCoord4fColor4fNormal3fVertex4fvSUN", "GL_SUN_vertex", glTexCoord4fColor4fNormal3fVertex4fvSUN },
  { "glTexCoord4fVertex4fSUN", "GL_SUN_vertex", glTexCoord4fVertex4fSUN },
  { "glTexCoord4fVertex4fvSUN", "GL_SUN_vertex", glTexCoord4fVertex4fvSUN },
  { "glTexCoord4hNV", "GL_NV_half_float", glTexCoord4hNV },
  { "glTexCoord4hvNV", "GL_NV_half_float", glTexCoord4hvNV },
  { "glTexCoord4xOES", "GL_OES_fixed_point", glTexCoord4xOES },
  { "glTexCoord4xvOES", "GL_OES_fixed_point", glTexCoord4xvOES },
  { "glTexCoordFormatNV", "GL_NV_vertex_buffer_unified_memory", glTexCoordFormatNV },
  { "glTexCoordP1ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP1ui },
  { "glTexCoordP1uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP1uiv },
  { "glTexCoordP2ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP2ui },
  { "glTexCoordP2uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP2uiv },
  { "glTexCoordP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP3ui },
  { "glTexCoordP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP3uiv },
  { "glTexCoordP4ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP4ui },
  { "glTexCoordP4uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glTexCoordP4uiv },
  { "glTexCoordPointerEXT", "GL_EXT_vertex_array", glTexCoordPointerEXT },
  { "glTexCoordPointerListIBM", "GL_IBM_vertex_array_lists", glTexCoordPointerListIBM },
  { "glTexCoordPointervINTEL", "GL_INTEL_parallel_arrays", glTexCoordPointervINTEL },
  { "glTexEnvxOES", "GL_OES_fixed_point", glTexEnvxOES },
  { "glTexEnvxvOES", "GL_OES_fixed_point", glTexEnvxvOES },
  { "glTexFilterFuncSGIS", "GL_SGIS_texture_filter4", glTexFilterFuncSGIS },
  { "glTexGenxOES", "GL_OES_fixed_point", glTexGenxOES },
  { "glTexGenxvOES", "GL_OES_fixed_point", glTexGenxvOES },
  { "glTexImage2DMultisample", "GL_ARB_texture_multisample GL_VERSION_3_2", glTexImage2DMultisample },
  { "glTexImage2DMultisampleCoverageNV", "GL_NV_texture_multisample", glTexImage2DMultisampleCoverageNV },
  { "glTexImage3D", "GL_VERSION_1_2", glTexImage3D },
  { "glTexImage3DEXT", "GL_EXT_texture3D", glTexImage3DEXT },
  { "glTexImage3DMultisample", "GL_ARB_texture_multisample GL_VERSION_3_2", glTexImage3DMultisample },
  { "glTexImage3DMultisampleCoverageNV", "GL_NV_texture_multisample", glTexImage3DMultisampleCoverageNV },
  { "glTexImage4DSGIS", "GL_SGIS_texture4D", glTexImage4DSGIS },
  { "glTexPageCommitmentARB", "GL_ARB_sparse_texture", glTexPageCommitmentARB },
  { "glTexParameterIiv", "GL_VERSION_3_0", glTexParameterIiv },
  { "glTexParameterIivEXT", "GL_EXT_texture_integer", glTexParameterIivEXT },
  { "glTexParameterIuiv", "GL_VERSION_3_0", glTexParameterIuiv },
  { "glTexParameterIuivEXT", "GL_EXT_texture_integer", glTexParameterIuivEXT },
  { "glTexParameterxOES", "GL_OES_fixed_point", glTexParameterxOES },
  { "glTexParameterxvOES", "GL_OES_fixed_point", glTexParameterxvOES },
  { "glTexRenderbufferNV", "GL_NV_explicit_multisample", glTexRenderbufferNV },
  { "glTexStorage1D", "GL_ARB_texture_storage GL_VERSION_4_2", glTexStorage1D },
  { "glTexStorage2D", "GL_ARB_texture_storage GL_VERSION_4_2", glTexStorage2D },
  { "glTexStorage2DMultisample", "GL_ARB_texture_storage_multisample GL_VERSION_4_3", glTexStorage2DMultisample },
  { "glTexStorage3D", "GL_ARB_texture_storage GL_VERSION_4_2", glTexStorage3D },
  { "glTexStorage3DMultisample", "GL_ARB_texture_storage_multisample GL_VERSION_4_3", glTexStorage3DMultisample },
  { "glTexStorageMem1DEXT", "GL_EXT_memory_object", glTexStorageMem1DEXT },
  { "glTexStorageMem2DEXT", "GL_EXT_memory_object", glTexStorageMem2DEXT },
  { "glTexStorageMem2DMultisampleEXT", "GL_EXT_memory_object", glTexStorageMem2DMultisampleEXT },
  { "glTexStorageMem3DEXT", "GL_EXT_memory_object", glTexStorageMem3DEXT },
  { "glTexStorageMem3DMultisampleEXT", "GL_EXT_memory_object", glTexStorageMem3DMultisampleEXT },
  { "glTexStorageSparseAMD", "GL_AMD_sparse_texture", glTexStorageSparseAMD },
  { "glTexSubImage1DEXT", "GL_EXT_subtexture", glTexSubImage1DEXT },
  { "glTexSubImage2DEXT", "GL_EXT_subtexture", glTexSubImage2DEXT },
  { "glTexSubImage3D", "GL_VERSION_1_2", glTexSubImage3D },
  { "glTexSubImage3DEXT", "GL_EXT_texture3D", glTexSubImage3DEXT },
  { "glTexSubImage4DSGIS", "GL_SGIS_texture4D", glTexSubImage4DSGIS },
  { "glTextureAttachMemoryNV", "GL_NV_memory_attachment", glTextureAttachMemoryNV },
  { "glTextureBarrier", "GL_ARB_texture_barrier GL_VERSION_4_5", glTextureBarrier },
  { "glTextureBarrierNV", "GL_NV_texture_barrier", glTextureBarrierNV },
  { "glTextureBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureBuffer },
  { "glTextureBufferEXT", "GL_EXT_direct_state_access", glTextureBufferEXT },
  { "glTextureBufferRange", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureBufferRange },
  { "glTextureBufferRangeEXT", "GL_EXT_direct_state_access", glTextureBufferRangeEXT },
  { "glTextureColorMaskSGIS", "GL_SGIS_texture_color_mask", glTextureColorMaskSGIS },
  { "glTextureImage1DEXT", "GL_EXT_direct_state_access", glTextureImage1DEXT },
  { "glTextureImage2DEXT", "GL_EXT_direct_state_access", glTextureImage2DEXT },
  { "glTextureImage2DMultisampleCoverageNV", "GL_NV_texture_multisample", glTextureImage2DMultisampleCoverageNV },
  { "glTextureImage2DMultisampleNV", "GL_NV_texture_multisample", glTextureImage2DMultisampleNV },
  { "glTextureImage3DEXT", "GL_EXT_direct_state_access", glTextureImage3DEXT },
  { "glTextureImage3DMultisampleCoverageNV", "GL_NV_texture_multisample", glTextureImage3DMultisampleCoverageNV },
  { "glTextureImage3DMultisampleNV", "GL_NV_texture_multisample", glTextureImage3DMultisampleNV },
  { "glTextureLightEXT", "GL_EXT_light_texture", glTextureLightEXT },
  { "glTextureMaterialEXT", "GL_EXT_light_texture", glTextureMaterialEXT },
  { "glTextureNormalEXT", "GL_EXT_texture_perturb_normal", glTextureNormalEXT },
  { "glTexturePageCommitmentEXT", "GL_EXT_direct_state_access", glTexturePageCommitmentEXT },
  { "glTextureParameterIiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameterIiv },
  { "glTextureParameterIivEXT", "GL_EXT_direct_state_access", glTextureParameterIivEXT },
  { "glTextureParameterIuiv", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameterIuiv },
  { "glTextureParameterIuivEXT", "GL_EXT_direct_state_access", glTextureParameterIuivEXT },
  { "glTextureParameterf", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameterf },
  { "glTextureParameterfEXT", "GL_EXT_direct_state_access", glTextureParameterfEXT },
  { "glTextureParameterfv", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameterfv },
  { "glTextureParameterfvEXT", "GL_EXT_direct_state_access", glTextureParameterfvEXT },
  { "glTextureParameteri", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameteri },
  { "glTextureParameteriEXT", "GL_EXT_direct_state_access", glTextureParameteriEXT },
  { "glTextureParameteriv", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureParameteriv },
  { "glTextureParameterivEXT", "GL_EXT_direct_state_access", glTextureParameterivEXT },
  { "glTextureRangeAPPLE", "GL_APPLE_texture_range", glTextureRangeAPPLE },
  { "glTextureRenderbufferEXT", "GL_EXT_direct_state_access", glTextureRenderbufferEXT },
  { "glTextureStorage1D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureStorage1D },
  { "glTextureStorage1DEXT", "GL_EXT_direct_state_access", glTextureStorage1DEXT },
  { "glTextureStorage2D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureStorage2D },
  { "glTextureStorage2DEXT", "GL_EXT_direct_state_access", glTextureStorage2DEXT },
  { "glTextureStorage2DMultisample", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureStorage2DMultisample },
  { "glTextureStorage2DMultisampleEXT", "GL_EXT_direct_state_access", glTextureStorage2DMultisampleEXT },
  { "glTextureStorage3D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureStorage3D },
  { "glTextureStorage3DEXT", "GL_EXT_direct_state_access", glTextureStorage3DEXT },
  { "glTextureStorage3DMultisample", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureStorage3DMultisample },
  { "glTextureStorage3DMultisampleEXT", "GL_EXT_direct_state_access", glTextureStorage3DMultisampleEXT },
  { "glTextureStorageMem1DEXT", "GL_EXT_memory_object", glTextureStorageMem1DEXT },
  { "glTextureStorageMem2DEXT", "GL_EXT_memory_object", glTextureStorageMem2DEXT },
  { "glTextureStorageMem2DMultisampleEXT", "GL_EXT_memory_object", glTextureStorageMem2DMultisampleEXT },
  { "glTextureStorageMem3DEXT", "GL_EXT_memory_object", glTextureStorageMem3DEXT },
  { "glTextureStorageMem3DMultisampleEXT", "GL_EXT_memory_object", glTextureStorageMem3DMultisampleEXT },
  { "glTextureStorageSparseAMD", "GL_AMD_sparse_texture", glTextureStorageSparseAMD },
  { "glTextureSubImage1D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureSubImage1D },
  { "glTextureSubImage1DEXT", "GL_EXT_direct_state_access", glTextureSubImage1DEXT },
  { "glTextureSubImage2D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureSubImage2D },
  { "glTextureSubImage2DEXT", "GL_EXT_direct_state_access", glTextureSubImage2DEXT },
  { "glTextureSubImage3D", "GL_ARB_direct_state_access GL_VERSION_4_5", glTextureSubImage3D },
  { "glTextureSubImage3DEXT", "GL_EXT_direct_state_access", glTextureSubImage3DEXT },
  { "glTextureView", "GL_ARB_texture_view GL_VERSION_4_3", glTextureView },
  { "glTrackMatrixNV", "GL_NV_vertex_program", glTrackMatrixNV },
  { "glTransformFeedbackAttribsNV", "GL_NV_transform_feedback", glTransformFeedbackAttribsNV },
  { "glTransformFeedbackBufferBase", "GL_ARB_direct_state_access GL_VERSION_4_5", glTransformFeedbackBufferBase },
  { "glTransformFeedbackBufferRange", "GL_ARB_direct_state_access GL_VERSION_4_5", glTransformFeedbackBufferRange },
  { "glTransformFeedbackStreamAttribsNV", "GL_NV_transform_feedback", glTransformFeedbackStreamAttribsNV },
  { "glTransformFeedbackVaryings", "GL_VERSION_3_0", glTransformFeedbackVaryings },
  { "glTransformFeedbackVaryingsEXT", "GL_EXT_transform_feedback", glTransformFeedbackVaryingsEXT },
  { "glTransformFeedbackVaryingsNV", "GL_NV_transform_feedback", glTransformFeedbackVaryingsNV },
  { "glTransformPathNV", "GL_NV_path_rendering", glTransformPathNV },
  { "glTranslatexOES", "GL_OES_fixed_point", glTranslatexOES },
  { "glUniform1d", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform1d },
  { "glUniform1dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform1dv },
  { "glUniform1f", "GL_VERSION_2_0", glUniform1f },
  { "glUniform1fARB", "GL_ARB_shader_objects", glUniform1fARB },
  { "glUniform1fv", "GL_VERSION_2_0", glUniform1fv },
  { "glUniform1fvARB", "GL_ARB_shader_objects", glUniform1fvARB },
  { "glUniform1i", "GL_VERSION_2_0", glUniform1i },
  { "glUniform1i64ARB", "GL_ARB_gpu_shader_int64", glUniform1i64ARB },
  { "glUniform1i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform1i64NV },
  { "glUniform1i64vARB", "GL_ARB_gpu_shader_int64", glUniform1i64vARB },
  { "glUniform1i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform1i64vNV },
  { "glUniform1iARB", "GL_ARB_shader_objects", glUniform1iARB },
  { "glUniform1iv", "GL_VERSION_2_0", glUniform1iv },
  { "glUniform1ivARB", "GL_ARB_shader_objects", glUniform1ivARB },
  { "glUniform1ui", "GL_VERSION_3_0", glUniform1ui },
  { "glUniform1ui64ARB", "GL_ARB_gpu_shader_int64", glUniform1ui64ARB },
  { "glUniform1ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform1ui64NV },
  { "glUniform1ui64vARB", "GL_ARB_gpu_shader_int64", glUniform1ui64vARB },
  { "glUniform1ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform1ui64vNV },
  { "glUniform1uiEXT", "GL_EXT_gpu_shader4", glUniform1uiEXT },
  { "glUniform1uiv", "GL_VERSION_3_0", glUniform1uiv },
  { "glUniform1uivEXT", "GL_EXT_gpu_shader4", glUniform1uivEXT },
  { "glUniform2d", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform2d },
  { "glUniform2dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform2dv },
  { "glUniform2f", "GL_VERSION_2_0", glUniform2f },
  { "glUniform2fARB", "GL_ARB_shader_objects", glUniform2fARB },
  { "glUniform2fv", "GL_VERSION_2_0", glUniform2fv },
  { "glUniform2fvARB", "GL_ARB_shader_objects", glUniform2fvARB },
  { "glUniform2i", "GL_VERSION_2_0", glUniform2i },
  { "glUniform2i64ARB", "GL_ARB_gpu_shader_int64", glUniform2i64ARB },
  { "glUniform2i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform2i64NV },
  { "glUniform2i64vARB", "GL_ARB_gpu_shader_int64", glUniform2i64vARB },
  { "glUniform2i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform2i64vNV },
  { "glUniform2iARB", "GL_ARB_shader_objects", glUniform2iARB },
  { "glUniform2iv", "GL_VERSION_2_0", glUniform2iv },
  { "glUniform2ivARB", "GL_ARB_shader_objects", glUniform2ivARB },
  { "glUniform2ui", "GL_VERSION_3_0", glUniform2ui },
  { "glUniform2ui64ARB", "GL_ARB_gpu_shader_int64", glUniform2ui64ARB },
  { "glUniform2ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform2ui64NV },
  { "glUniform2ui64vARB", "GL_ARB_gpu_shader_int64", glUniform2ui64vARB },
  { "glUniform2ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform2ui64vNV },
  { "glUniform2uiEXT", "GL_EXT_gpu_shader4", glUniform2uiEXT },
  { "glUniform2uiv", "GL_VERSION_3_0", glUniform2uiv },
  { "glUniform2uivEXT", "GL_EXT_gpu_shader4", glUniform2uivEXT },
  { "glUniform3d", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform3d },
  { "glUniform3dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform3dv },
  { "glUniform3f", "GL_VERSION_2_0", glUniform3f },
  { "glUniform3fARB", "GL_ARB_shader_objects", glUniform3fARB },
  { "glUniform3fv", "GL_VERSION_2_0", glUniform3fv },
  { "glUniform3fvARB", "GL_ARB_shader_objects", glUniform3fvARB },
  { "glUniform3i", "GL_VERSION_2_0", glUniform3i },
  { "glUniform3i64ARB", "GL_ARB_gpu_shader_int64", glUniform3i64ARB },
  { "glUniform3i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform3i64NV },
  { "glUniform3i64vARB", "GL_ARB_gpu_shader_int64", glUniform3i64vARB },
  { "glUniform3i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform3i64vNV },
  { "glUniform3iARB", "GL_ARB_shader_objects", glUniform3iARB },
  { "glUniform3iv", "GL_VERSION_2_0", glUniform3iv },
  { "glUniform3ivARB", "GL_ARB_shader_objects", glUniform3ivARB },
  { "glUniform3ui", "GL_VERSION_3_0", glUniform3ui },
  { "glUniform3ui64ARB", "GL_ARB_gpu_shader_int64", glUniform3ui64ARB },
  { "glUniform3ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform3ui64NV },
  { "glUniform3ui64vARB", "GL_ARB_gpu_shader_int64", glUniform3ui64vARB },
  { "glUniform3ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform3ui64vNV },
  { "glUniform3uiEXT", "GL_EXT_gpu_shader4", glUniform3uiEXT },
  { "glUniform3uiv", "GL_VERSION_3_0", glUniform3uiv },
  { "glUniform3uivEXT", "GL_EXT_gpu_shader4", glUniform3uivEXT },
  { "glUniform4d", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform4d },
  { "glUniform4dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniform4dv },
  { "glUniform4f", "GL_VERSION_2_0", glUniform4f },
  { "glUniform4fARB", "GL_ARB_shader_objects", glUniform4fARB },
  { "glUniform4fv", "GL_VERSION_2_0", glUniform4fv },
  { "glUniform4fvARB", "GL_ARB_shader_objects", glUniform4fvARB },
  { "glUniform4i", "GL_VERSION_2_0", glUniform4i },
  { "glUniform4i64ARB", "GL_ARB_gpu_shader_int64", glUniform4i64ARB },
  { "glUniform4i64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform4i64NV },
  { "glUniform4i64vARB", "GL_ARB_gpu_shader_int64", glUniform4i64vARB },
  { "glUniform4i64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform4i64vNV },
  { "glUniform4iARB", "GL_ARB_shader_objects", glUniform4iARB },
  { "glUniform4iv", "GL_VERSION_2_0", glUniform4iv },
  { "glUniform4ivARB", "GL_ARB_shader_objects", glUniform4ivARB },
  { "glUniform4ui", "GL_VERSION_3_0", glUniform4ui },
  { "glUniform4ui64ARB", "GL_ARB_gpu_shader_int64", glUniform4ui64ARB },
  { "glUniform4ui64NV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform4ui64NV },
  { "glUniform4ui64vARB", "GL_ARB_gpu_shader_int64", glUniform4ui64vARB },
  { "glUniform4ui64vNV", "GL_AMD_gpu_shader_int64 GL_NV_gpu_shader5", glUniform4ui64vNV },
  { "glUniform4uiEXT", "GL_EXT_gpu_shader4", glUniform4uiEXT },
  { "glUniform4uiv", "GL_VERSION_3_0", glUniform4uiv },
  { "glUniform4uivEXT", "GL_EXT_gpu_shader4", glUniform4uivEXT },
  { "glUniformBlockBinding", "GL_ARB_uniform_buffer_object GL_VERSION_3_1", glUniformBlockBinding },
  { "glUniformBufferEXT", "GL_EXT_bindable_uniform", glUniformBufferEXT },
  { "glUniformHandleui64ARB", "GL_ARB_bindless_texture", glUniformHandleui64ARB },
  { "glUniformHandleui64NV", "GL_NV_bindless_texture", glUniformHandleui64NV },
  { "glUniformHandleui64vARB", "GL_ARB_bindless_texture", glUniformHandleui64vARB },
  { "glUniformHandleui64vNV", "GL_NV_bindless_texture", glUniformHandleui64vNV },
  { "glUniformMatrix2dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix2dv },
  { "glUniformMatrix2fv", "GL_VERSION_2_0", glUniformMatrix2fv },
  { "glUniformMatrix2fvARB", "GL_ARB_shader_objects", glUniformMatrix2fvARB },
  { "glUniformMatrix2x3dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix2x3dv },
  { "glUniformMatrix2x3fv", "GL_VERSION_2_1", glUniformMatrix2x3fv },
  { "glUniformMatrix2x4dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix2x4dv },
  { "glUniformMatrix2x4fv", "GL_VERSION_2_1", glUniformMatrix2x4fv },
  { "glUniformMatrix3dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix3dv },
  { "glUniformMatrix3fv", "GL_VERSION_2_0", glUniformMatrix3fv },
  { "glUniformMatrix3fvARB", "GL_ARB_shader_objects", glUniformMatrix3fvARB },
  { "glUniformMatrix3x2dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix3x2dv },
  { "glUniformMatrix3x2fv", "GL_VERSION_2_1", glUniformMatrix3x2fv },
  { "glUniformMatrix3x4dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix3x4dv },
  { "glUniformMatrix3x4fv", "GL_VERSION_2_1", glUniformMatrix3x4fv },
  { "glUniformMatrix4dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix4dv },
  { "glUniformMatrix4fv", "GL_VERSION_2_0", glUniformMatrix4fv },
  { "glUniformMatrix4fvARB", "GL_ARB_shader_objects", glUniformMatrix4fvARB },
  { "glUniformMatrix4x2dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix4x2dv },
  { "glUniformMatrix4x2fv", "GL_VERSION_2_1", glUniformMatrix4x2fv },
  { "glUniformMatrix4x3dv", "GL_ARB_gpu_shader_fp64 GL_VERSION_4_0", glUniformMatrix4x3dv },
  { "glUniformMatrix4x3fv", "GL_VERSION_2_1", glUniformMatrix4x3fv },
  { "glUniformSubroutinesuiv", "GL_ARB_shader_subroutine GL_VERSION_4_0", glUniformSubroutinesuiv },
  { "glUniformui64NV", "GL_NV_shader_buffer_load", glUniformui64NV },
  { "glUniformui64vNV", "GL_NV_shader_buffer_load", glUniformui64vNV },
  { "glUnlockArraysEXT", "GL_EXT_compiled_vertex_array", glUnlockArraysEXT },
  { "glUnmapBuffer", "GL_VERSION_1_5", glUnmapBuffer },
  { "glUnmapBufferARB", "GL_ARB_vertex_buffer_object", glUnmapBufferARB },
  { "glUnmapNamedBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glUnmapNamedBuffer },
  { "glUnmapNamedBufferEXT", "GL_EXT_direct_state_access", glUnmapNamedBufferEXT },
  { "glUnmapObjectBufferATI", "GL_ATI_map_object_buffer", glUnmapObjectBufferATI },
  { "glUnmapTexture2DINTEL", "GL_INTEL_map_texture", glUnmapTexture2DINTEL },
  { "glUpdateObjectBufferATI", "GL_ATI_vertex_array_object", glUpdateObjectBufferATI },
  { "glUploadGpuMaskNVX", "GL_NVX_gpu_multicast2", glUploadGpuMaskNVX },
  { "glUseProgram", "GL_VERSION_2_0", glUseProgram },
  { "glUseProgramObjectARB", "GL_ARB_shader_objects", glUseProgramObjectARB },
  { "glUseProgramStages", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glUseProgramStages },
  { "glUseShaderProgramEXT", "GL_EXT_separate_shader_objects", glUseShaderProgramEXT },
  { "glVDPAUFiniNV", "GL_NV_vdpau_interop", glVDPAUFiniNV },
  { "glVDPAUGetSurfaceivNV", "GL_NV_vdpau_interop", glVDPAUGetSurfaceivNV },
  { "glVDPAUInitNV", "GL_NV_vdpau_interop", glVDPAUInitNV },
  { "glVDPAUIsSurfaceNV", "GL_NV_vdpau_interop", glVDPAUIsSurfaceNV },
  { "glVDPAUMapSurfacesNV", "GL_NV_vdpau_interop", glVDPAUMapSurfacesNV },
  { "glVDPAURegisterOutputSurfaceNV", "GL_NV_vdpau_interop", glVDPAURegisterOutputSurfaceNV },
  { "glVDPAURegisterVideoSurfaceNV", "GL_NV_vdpau_interop", glVDPAURegisterVideoSurfaceNV },
  { "glVDPAURegisterVideoSurfaceWithPictureStructureNV", "GL_NV_vdpau_interop2", glVDPAURegisterVideoSurfaceWithPictureStructureNV },
  { "glVDPAUSurfaceAccessNV", "GL_NV_vdpau_interop", glVDPAUSurfaceAccessNV },
  { "glVDPAUUnmapSurfacesNV", "GL_NV_vdpau_interop", glVDPAUUnmapSurfacesNV },
  { "glVDPAUUnregisterSurfaceNV", "GL_NV_vdpau_interop", glVDPAUUnregisterSurfaceNV },
  { "glValidateProgram", "GL_VERSION_2_0", glValidateProgram },
  { "glValidateProgramARB", "GL_ARB_shader_objects", glValidateProgramARB },
  { "glValidateProgramPipeline", "GL_ARB_separate_shader_objects GL_VERSION_4_1", glValidateProgramPipeline },
  { "glVariantArrayObjectATI", "GL_ATI_vertex_array_object", glVariantArrayObjectATI },
  { "glVariantPointerEXT", "GL_EXT_vertex_shader", glVariantPointerEXT },
  { "glVariantbvEXT", "GL_EXT_vertex_shader", glVariantbvEXT },
  { "glVariantdvEXT", "GL_EXT_vertex_shader", glVariantdvEXT },
  { "glVariantfvEXT", "GL_EXT_vertex_shader", glVariantfvEXT },
  { "glVariantivEXT", "GL_EXT_vertex_shader", glVariantivEXT },
  { "glVariantsvEXT", "GL_EXT_vertex_shader", glVariantsvEXT },
  { "glVariantubvEXT", "GL_EXT_vertex_shader", glVariantubvEXT },
  { "glVariantuivEXT", "GL_EXT_vertex_shader", glVariantuivEXT },
  { "glVariantusvEXT", "GL_EXT_vertex_shader", glVariantusvEXT },
  { "glVertex2bOES", "GL_OES_byte_coordinates", glVertex2bOES },
  { "glVertex2bvOES", "GL_OES_byte_coordinates", glVertex2bvOES },
  { "glVertex2hNV", "GL_NV_half_float", glVertex2hNV },
  { "glVertex2hvNV", "GL_NV_half_float", glVertex2hvNV },
  { "glVertex2xOES", "GL_OES_fixed_point", glVertex2xOES },
  { "glVertex2xvOES", "GL_OES_fixed_point", glVertex2xvOES },
  { "glVertex3bOES", "GL_OES_byte_coordinates", glVertex3bOES },
  { "glVertex3bvOES", "GL_OES_byte_coordinates", glVertex3bvOES },
  { "glVertex3hNV", "GL_NV_half_float", glVertex3hNV },
  { "glVertex3hvNV", "GL_NV_half_float", glVertex3hvNV },
  { "glVertex3xOES", "GL_OES_fixed_point", glVertex3xOES },
  { "glVertex3xvOES", "GL_OES_fixed_point", glVertex3xvOES },
  { "glVertex4bOES", "GL_OES_byte_coordinates", glVertex4bOES },
  { "glVertex4bvOES", "GL_OES_byte_coordinates", glVertex4bvOES },
  { "glVertex4hNV", "GL_NV_half_float", glVertex4hNV },
  { "glVertex4hvNV", "GL_NV_half_float", glVertex4hvNV },
  { "glVertex4xOES", "GL_OES_fixed_point", glVertex4xOES },
  { "glVertex4xvOES", "GL_OES_fixed_point", glVertex4xvOES },
  { "glVertexArrayAttribBinding", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayAttribBinding },
  { "glVertexArrayAttribFormat", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayAttribFormat },
  { "glVertexArrayAttribIFormat", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayAttribIFormat },
  { "glVertexArrayAttribLFormat", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayAttribLFormat },
  { "glVertexArrayBindVertexBufferEXT", "GL_EXT_direct_state_access", glVertexArrayBindVertexBufferEXT },
  { "glVertexArrayBindingDivisor", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayBindingDivisor },
  { "glVertexArrayColorOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayColorOffsetEXT },
  { "glVertexArrayEdgeFlagOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayEdgeFlagOffsetEXT },
  { "glVertexArrayElementBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayElementBuffer },
  { "glVertexArrayFogCoordOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayFogCoordOffsetEXT },
  { "glVertexArrayIndexOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayIndexOffsetEXT },
  { "glVertexArrayMultiTexCoordOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayMultiTexCoordOffsetEXT },
  { "glVertexArrayNormalOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayNormalOffsetEXT },
  { "glVertexArrayParameteriAPPLE", "GL_APPLE_vertex_array_range", glVertexArrayParameteriAPPLE },
  { "glVertexArrayRangeAPPLE", "GL_APPLE_vertex_array_range", glVertexArrayRangeAPPLE },
  { "glVertexArrayRangeNV", "GL_NV_vertex_array_range", glVertexArrayRangeNV },
  { "glVertexArraySecondaryColorOffsetEXT", "GL_EXT_direct_state_access", glVertexArraySecondaryColorOffsetEXT },
  { "glVertexArrayTexCoordOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayTexCoordOffsetEXT },
  { "glVertexArrayVertexAttribBindingEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribBindingEXT },
  { "glVertexArrayVertexAttribDivisorEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribDivisorEXT },
  { "glVertexArrayVertexAttribFormatEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribFormatEXT },
  { "glVertexArrayVertexAttribIFormatEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribIFormatEXT },
  { "glVertexArrayVertexAttribIOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribIOffsetEXT },
  { "glVertexArrayVertexAttribLFormatEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribLFormatEXT },
  { "glVertexArrayVertexAttribLOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribLOffsetEXT },
  { "glVertexArrayVertexAttribOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayVertexAttribOffsetEXT },
  { "glVertexArrayVertexBindingDivisorEXT", "GL_EXT_direct_state_access", glVertexArrayVertexBindingDivisorEXT },
  { "glVertexArrayVertexBuffer", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayVertexBuffer },
  { "glVertexArrayVertexBuffers", "GL_ARB_direct_state_access GL_VERSION_4_5", glVertexArrayVertexBuffers },
  { "glVertexArrayVertexOffsetEXT", "GL_EXT_direct_state_access", glVertexArrayVertexOffsetEXT },
  { "glVertexAttrib1d", "GL_VERSION_2_0", glVertexAttrib1d },
  { "glVertexAttrib1dARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1dARB },
  { "glVertexAttrib1dNV", "GL_NV_vertex_program", glVertexAttrib1dNV },
  { "glVertexAttrib1dv", "GL_VERSION_2_0", glVertexAttrib1dv },
  { "glVertexAttrib1dvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1dvARB },
  { "glVertexAttrib1dvNV", "GL_NV_vertex_program", glVertexAttrib1dvNV },
  { "glVertexAttrib1f", "GL_VERSION_2_0", glVertexAttrib1f },
  { "glVertexAttrib1fARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1fARB },
  { "glVertexAttrib1fNV", "GL_NV_vertex_program", glVertexAttrib1fNV },
  { "glVertexAttrib1fv", "GL_VERSION_2_0", glVertexAttrib1fv },
  { "glVertexAttrib1fvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1fvARB },
  { "glVertexAttrib1fvNV", "GL_NV_vertex_program", glVertexAttrib1fvNV },
  { "glVertexAttrib1hNV", "GL_NV_half_float", glVertexAttrib1hNV },
  { "glVertexAttrib1hvNV", "GL_NV_half_float", glVertexAttrib1hvNV },
  { "glVertexAttrib1s", "GL_VERSION_2_0", glVertexAttrib1s },
  { "glVertexAttrib1sARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1sARB },
  { "glVertexAttrib1sNV", "GL_NV_vertex_program", glVertexAttrib1sNV },
  { "glVertexAttrib1sv", "GL_VERSION_2_0", glVertexAttrib1sv },
  { "glVertexAttrib1svARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib1svARB },
  { "glVertexAttrib1svNV", "GL_NV_vertex_program", glVertexAttrib1svNV },
  { "glVertexAttrib2d", "GL_VERSION_2_0", glVertexAttrib2d },
  { "glVertexAttrib2dARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2dARB },
  { "glVertexAttrib2dNV", "GL_NV_vertex_program", glVertexAttrib2dNV },
  { "glVertexAttrib2dv", "GL_VERSION_2_0", glVertexAttrib2dv },
  { "glVertexAttrib2dvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2dvARB },
  { "glVertexAttrib2dvNV", "GL_NV_vertex_program", glVertexAttrib2dvNV },
  { "glVertexAttrib2f", "GL_VERSION_2_0", glVertexAttrib2f },
  { "glVertexAttrib2fARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2fARB },
  { "glVertexAttrib2fNV", "GL_NV_vertex_program", glVertexAttrib2fNV },
  { "glVertexAttrib2fv", "GL_VERSION_2_0", glVertexAttrib2fv },
  { "glVertexAttrib2fvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2fvARB },
  { "glVertexAttrib2fvNV", "GL_NV_vertex_program", glVertexAttrib2fvNV },
  { "glVertexAttrib2hNV", "GL_NV_half_float", glVertexAttrib2hNV },
  { "glVertexAttrib2hvNV", "GL_NV_half_float", glVertexAttrib2hvNV },
  { "glVertexAttrib2s", "GL_VERSION_2_0", glVertexAttrib2s },
  { "glVertexAttrib2sARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2sARB },
  { "glVertexAttrib2sNV", "GL_NV_vertex_program", glVertexAttrib2sNV },
  { "glVertexAttrib2sv", "GL_VERSION_2_0", glVertexAttrib2sv },
  { "glVertexAttrib2svARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib2svARB },
  { "glVertexAttrib2svNV", "GL_NV_vertex_program", glVertexAttrib2svNV },
  { "glVertexAttrib3d", "GL_VERSION_2_0", glVertexAttrib3d },
  { "glVertexAttrib3dARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3dARB },
  { "glVertexAttrib3dNV", "GL_NV_vertex_program", glVertexAttrib3dNV },
  { "glVertexAttrib3dv", "GL_VERSION_2_0", glVertexAttrib3dv },
  { "glVertexAttrib3dvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3dvARB },
  { "glVertexAttrib3dvNV", "GL_NV_vertex_program", glVertexAttrib3dvNV },
  { "glVertexAttrib3f", "GL_VERSION_2_0", glVertexAttrib3f },
  { "glVertexAttrib3fARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3fARB },
  { "glVertexAttrib3fNV", "GL_NV_vertex_program", glVertexAttrib3fNV },
  { "glVertexAttrib3fv", "GL_VERSION_2_0", glVertexAttrib3fv },
  { "glVertexAttrib3fvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3fvARB },
  { "glVertexAttrib3fvNV", "GL_NV_vertex_program", glVertexAttrib3fvNV },
  { "glVertexAttrib3hNV", "GL_NV_half_float", glVertexAttrib3hNV },
  { "glVertexAttrib3hvNV", "GL_NV_half_float", glVertexAttrib3hvNV },
  { "glVertexAttrib3s", "GL_VERSION_2_0", glVertexAttrib3s },
  { "glVertexAttrib3sARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3sARB },
  { "glVertexAttrib3sNV", "GL_NV_vertex_program", glVertexAttrib3sNV },
  { "glVertexAttrib3sv", "GL_VERSION_2_0", glVertexAttrib3sv },
  { "glVertexAttrib3svARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib3svARB },
  { "glVertexAttrib3svNV", "GL_NV_vertex_program", glVertexAttrib3svNV },
  { "glVertexAttrib4Nbv", "GL_VERSION_2_0", glVertexAttrib4Nbv },
  { "glVertexAttrib4NbvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NbvARB },
  { "glVertexAttrib4Niv", "GL_VERSION_2_0", glVertexAttrib4Niv },
  { "glVertexAttrib4NivARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NivARB },
  { "glVertexAttrib4Nsv", "GL_VERSION_2_0", glVertexAttrib4Nsv },
  { "glVertexAttrib4NsvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NsvARB },
  { "glVertexAttrib4Nub", "GL_VERSION_2_0", glVertexAttrib4Nub },
  { "glVertexAttrib4NubARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NubARB },
  { "glVertexAttrib4Nubv", "GL_VERSION_2_0", glVertexAttrib4Nubv },
  { "glVertexAttrib4NubvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NubvARB },
  { "glVertexAttrib4Nuiv", "GL_VERSION_2_0", glVertexAttrib4Nuiv },
  { "glVertexAttrib4NuivARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NuivARB },
  { "glVertexAttrib4Nusv", "GL_VERSION_2_0", glVertexAttrib4Nusv },
  { "glVertexAttrib4NusvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4NusvARB },
  { "glVertexAttrib4bv", "GL_VERSION_2_0", glVertexAttrib4bv },
  { "glVertexAttrib4bvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4bvARB },
  { "glVertexAttrib4d", "GL_VERSION_2_0", glVertexAttrib4d },
  { "glVertexAttrib4dARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4dARB },
  { "glVertexAttrib4dNV", "GL_NV_vertex_program", glVertexAttrib4dNV },
  { "glVertexAttrib4dv", "GL_VERSION_2_0", glVertexAttrib4dv },
  { "glVertexAttrib4dvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4dvARB },
  { "glVertexAttrib4dvNV", "GL_NV_vertex_program", glVertexAttrib4dvNV },
  { "glVertexAttrib4f", "GL_VERSION_2_0", glVertexAttrib4f },
  { "glVertexAttrib4fARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4fARB },
  { "glVertexAttrib4fNV", "GL_NV_vertex_program", glVertexAttrib4fNV },
  { "glVertexAttrib4fv", "GL_VERSION_2_0", glVertexAttrib4fv },
  { "glVertexAttrib4fvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4fvARB },
  { "glVertexAttrib4fvNV", "GL_NV_vertex_program", glVertexAttrib4fvNV },
  { "glVertexAttrib4hNV", "GL_NV_half_float", glVertexAttrib4hNV },
  { "glVertexAttrib4hvNV", "GL_NV_half_float", glVertexAttrib4hvNV },
  { "glVertexAttrib4iv", "GL_VERSION_2_0", glVertexAttrib4iv },
  { "glVertexAttrib4ivARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4ivARB },
  { "glVertexAttrib4s", "GL_VERSION_2_0", glVertexAttrib4s },
  { "glVertexAttrib4sARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4sARB },
  { "glVertexAttrib4sNV", "GL_NV_vertex_program", glVertexAttrib4sNV },
  { "glVertexAttrib4sv", "GL_VERSION_2_0", glVertexAttrib4sv },
  { "glVertexAttrib4svARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4svARB },
  { "glVertexAttrib4svNV", "GL_NV_vertex_program", glVertexAttrib4svNV },
  { "glVertexAttrib4ubNV", "GL_NV_vertex_program", glVertexAttrib4ubNV },
  { "glVertexAttrib4ubv", "GL_VERSION_2_0", glVertexAttrib4ubv },
  { "glVertexAttrib4ubvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4ubvARB },
  { "glVertexAttrib4ubvNV", "GL_NV_vertex_program", glVertexAttrib4ubvNV },
  { "glVertexAttrib4uiv", "GL_VERSION_2_0", glVertexAttrib4uiv },
  { "glVertexAttrib4uivARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4uivARB },
  { "glVertexAttrib4usv", "GL_VERSION_2_0", glVertexAttrib4usv },
  { "glVertexAttrib4usvARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttrib4usvARB },
  { "glVertexAttribArrayObjectATI", "GL_ATI_vertex_attrib_array_object", glVertexAttribArrayObjectATI },
  { "glVertexAttribBinding", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glVertexAttribBinding },
  { "glVertexAttribDivisor", "GL_VERSION_3_3", glVertexAttribDivisor },
  { "glVertexAttribDivisorARB", "GL_ARB_instanced_arrays", glVertexAttribDivisorARB },
  { "glVertexAttribFormat", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glVertexAttribFormat },
  { "glVertexAttribFormatNV", "GL_NV_vertex_buffer_unified_memory", glVertexAttribFormatNV },
  { "glVertexAttribI1i", "GL_VERSION_3_0", glVertexAttribI1i },
  { "glVertexAttribI1iEXT", "GL_NV_vertex_program4", glVertexAttribI1iEXT },
  { "glVertexAttribI1iv", "GL_VERSION_3_0", glVertexAttribI1iv },
  { "glVertexAttribI1ivEXT", "GL_NV_vertex_program4", glVertexAttribI1ivEXT },
  { "glVertexAttribI1ui", "GL_VERSION_3_0", glVertexAttribI1ui },
  { "glVertexAttribI1uiEXT", "GL_NV_vertex_program4", glVertexAttribI1uiEXT },
  { "glVertexAttribI1uiv", "GL_VERSION_3_0", glVertexAttribI1uiv },
  { "glVertexAttribI1uivEXT", "GL_NV_vertex_program4", glVertexAttribI1uivEXT },
  { "glVertexAttribI2i", "GL_VERSION_3_0", glVertexAttribI2i },
  { "glVertexAttribI2iEXT", "GL_NV_vertex_program4", glVertexAttribI2iEXT },
  { "glVertexAttribI2iv", "GL_VERSION_3_0", glVertexAttribI2iv },
  { "glVertexAttribI2ivEXT", "GL_NV_vertex_program4", glVertexAttribI2ivEXT },
  { "glVertexAttribI2ui", "GL_VERSION_3_0", glVertexAttribI2ui },
  { "glVertexAttribI2uiEXT", "GL_NV_vertex_program4", glVertexAttribI2uiEXT },
  { "glVertexAttribI2uiv", "GL_VERSION_3_0", glVertexAttribI2uiv },
  { "glVertexAttribI2uivEXT", "GL_NV_vertex_program4", glVertexAttribI2uivEXT },
  { "glVertexAttribI3i", "GL_VERSION_3_0", glVertexAttribI3i },
  { "glVertexAttribI3iEXT", "GL_NV_vertex_program4", glVertexAttribI3iEXT },
  { "glVertexAttribI3iv", "GL_VERSION_3_0", glVertexAttribI3iv },
  { "glVertexAttribI3ivEXT", "GL_NV_vertex_program4", glVertexAttribI3ivEXT },
  { "glVertexAttribI3ui", "GL_VERSION_3_0", glVertexAttribI3ui },
  { "glVertexAttribI3uiEXT", "GL_NV_vertex_program4", glVertexAttribI3uiEXT },
  { "glVertexAttribI3uiv", "GL_VERSION_3_0", glVertexAttribI3uiv },
  { "glVertexAttribI3uivEXT", "GL_NV_vertex_program4", glVertexAttribI3uivEXT },
  { "glVertexAttribI4bv", "GL_VERSION_3_0", glVertexAttribI4bv },
  { "glVertexAttribI4bvEXT", "GL_NV_vertex_program4", glVertexAttribI4bvEXT },
  { "glVertexAttribI4i", "GL_VERSION_3_0", glVertexAttribI4i },
  { "glVertexAttribI4iEXT", "GL_NV_vertex_program4", glVertexAttribI4iEXT },
  { "glVertexAttribI4iv", "GL_VERSION_3_0", glVertexAttribI4iv },
  { "glVertexAttribI4ivEXT", "GL_NV_vertex_program4", glVertexAttribI4ivEXT },
  { "glVertexAttribI4sv", "GL_VERSION_3_0", glVertexAttribI4sv },
  { "glVertexAttribI4svEXT", "GL_NV_vertex_program4", glVertexAttribI4svEXT },
  { "glVertexAttribI4ubv", "GL_VERSION_3_0", glVertexAttribI4ubv },
  { "glVertexAttribI4ubvEXT", "GL_NV_vertex_program4", glVertexAttribI4ubvEXT },
  { "glVertexAttribI4ui", "GL_VERSION_3_0", glVertexAttribI4ui },
  { "glVertexAttribI4uiEXT", "GL_NV_vertex_program4", glVertexAttribI4uiEXT },
  { "glVertexAttribI4uiv", "GL_VERSION_3_0", glVertexAttribI4uiv },
  { "glVertexAttribI4uivEXT", "GL_NV_vertex_program4", glVertexAttribI4uivEXT },
  { "glVertexAttribI4usv", "GL_VERSION_3_0", glVertexAttribI4usv },
  { "glVertexAttribI4usvEXT", "GL_NV_vertex_program4", glVertexAttribI4usvEXT },
  { "glVertexAttribIFormat", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glVertexAttribIFormat },
  { "glVertexAttribIFormatNV", "GL_NV_vertex_buffer_unified_memory", glVertexAttribIFormatNV },
  { "glVertexAttribIPointer", "GL_VERSION_3_0", glVertexAttribIPointer },
  { "glVertexAttribIPointerEXT", "GL_NV_vertex_program4", glVertexAttribIPointerEXT },
  { "glVertexAttribL1d", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL1d },
  { "glVertexAttribL1dEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL1dEXT },
  { "glVertexAttribL1dv", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL1dv },
  { "glVertexAttribL1dvEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL1dvEXT },
  { "glVertexAttribL1i64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL1i64NV },
  { "glVertexAttribL1i64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL1i64vNV },
  { "glVertexAttribL1ui64ARB", "GL_ARB_bindless_texture", glVertexAttribL1ui64ARB },
  { "glVertexAttribL1ui64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL1ui64NV },
  { "glVertexAttribL1ui64vARB", "GL_ARB_bindless_texture", glVertexAttribL1ui64vARB },
  { "glVertexAttribL1ui64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL1ui64vNV },
  { "glVertexAttribL2d", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL2d },
  { "glVertexAttribL2dEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL2dEXT },
  { "glVertexAttribL2dv", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL2dv },
  { "glVertexAttribL2dvEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL2dvEXT },
  { "glVertexAttribL2i64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL2i64NV },
  { "glVertexAttribL2i64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL2i64vNV },
  { "glVertexAttribL2ui64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL2ui64NV },
  { "glVertexAttribL2ui64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL2ui64vNV },
  { "glVertexAttribL3d", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL3d },
  { "glVertexAttribL3dEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL3dEXT },
  { "glVertexAttribL3dv", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL3dv },
  { "glVertexAttribL3dvEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL3dvEXT },
  { "glVertexAttribL3i64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL3i64NV },
  { "glVertexAttribL3i64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL3i64vNV },
  { "glVertexAttribL3ui64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL3ui64NV },
  { "glVertexAttribL3ui64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL3ui64vNV },
  { "glVertexAttribL4d", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL4d },
  { "glVertexAttribL4dEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL4dEXT },
  { "glVertexAttribL4dv", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribL4dv },
  { "glVertexAttribL4dvEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribL4dvEXT },
  { "glVertexAttribL4i64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL4i64NV },
  { "glVertexAttribL4i64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL4i64vNV },
  { "glVertexAttribL4ui64NV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL4ui64NV },
  { "glVertexAttribL4ui64vNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribL4ui64vNV },
  { "glVertexAttribLFormat", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glVertexAttribLFormat },
  { "glVertexAttribLFormatNV", "GL_NV_vertex_attrib_integer_64bit", glVertexAttribLFormatNV },
  { "glVertexAttribLPointer", "GL_ARB_vertex_attrib_64bit GL_VERSION_4_1", glVertexAttribLPointer },
  { "glVertexAttribLPointerEXT", "GL_EXT_vertex_attrib_64bit", glVertexAttribLPointerEXT },
  { "glVertexAttribP1ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP1ui },
  { "glVertexAttribP1uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP1uiv },
  { "glVertexAttribP2ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP2ui },
  { "glVertexAttribP2uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP2uiv },
  { "glVertexAttribP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP3ui },
  { "glVertexAttribP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP3uiv },
  { "glVertexAttribP4ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP4ui },
  { "glVertexAttribP4uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexAttribP4uiv },
  { "glVertexAttribParameteriAMD", "GL_AMD_interleaved_elements", glVertexAttribParameteriAMD },
  { "glVertexAttribPointer", "GL_VERSION_2_0", glVertexAttribPointer },
  { "glVertexAttribPointerARB", "GL_ARB_vertex_program GL_ARB_vertex_shader", glVertexAttribPointerARB },
  { "glVertexAttribPointerNV", "GL_NV_vertex_program", glVertexAttribPointerNV },
  { "glVertexAttribs1dvNV", "GL_NV_vertex_program", glVertexAttribs1dvNV },
  { "glVertexAttribs1fvNV", "GL_NV_vertex_program", glVertexAttribs1fvNV },
  { "glVertexAttribs1hvNV", "GL_NV_half_float", glVertexAttribs1hvNV },
  { "glVertexAttribs1svNV", "GL_NV_vertex_program", glVertexAttribs1svNV },
  { "glVertexAttribs2dvNV", "GL_NV_vertex_program", glVertexAttribs2dvNV },
  { "glVertexAttribs2fvNV", "GL_NV_vertex_program", glVertexAttribs2fvNV },
  { "glVertexAttribs2hvNV", "GL_NV_half_float", glVertexAttribs2hvNV },
  { "glVertexAttribs2svNV", "GL_NV_vertex_program", glVertexAttribs2svNV },
  { "glVertexAttribs3dvNV", "GL_NV_vertex_program", glVertexAttribs3dvNV },
  { "glVertexAttribs3fvNV", "GL_NV_vertex_program", glVertexAttribs3fvNV },
  { "glVertexAttribs3hvNV", "GL_NV_half_float", glVertexAttribs3hvNV },
  { "glVertexAttribs3svNV", "GL_NV_vertex_program", glVertexAttribs3svNV },
  { "glVertexAttribs4dvNV", "GL_NV_vertex_program", glVertexAttribs4dvNV },
  { "glVertexAttribs4fvNV", "GL_NV_vertex_program", glVertexAttribs4fvNV },
  { "glVertexAttribs4hvNV", "GL_NV_half_float", glVertexAttribs4hvNV },
  { "glVertexAttribs4svNV", "GL_NV_vertex_program", glVertexAttribs4svNV },
  { "glVertexAttribs4ubvNV", "GL_NV_vertex_program", glVertexAttribs4ubvNV },
  { "glVertexBindingDivisor", "GL_ARB_vertex_attrib_binding GL_VERSION_4_3", glVertexBindingDivisor },
  { "glVertexBlendARB", "GL_ARB_vertex_blend", glVertexBlendARB },
  { "glVertexBlendEnvfATI", "GL_ATI_vertex_streams", glVertexBlendEnvfATI },
  { "glVertexBlendEnviATI", "GL_ATI_vertex_streams", glVertexBlendEnviATI },
  { "glVertexFormatNV", "GL_NV_vertex_buffer_unified_memory", glVertexFormatNV },
  { "glVertexP2ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP2ui },
  { "glVertexP2uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP2uiv },
  { "glVertexP3ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP3ui },
  { "glVertexP3uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP3uiv },
  { "glVertexP4ui", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP4ui },
  { "glVertexP4uiv", "GL_ARB_vertex_type_2_10_10_10_rev GL_VERSION_3_3", glVertexP4uiv },
  { "glVertexPointerEXT", "GL_EXT_vertex_array", glVertexPointerEXT },
  { "glVertexPointerListIBM", "GL_IBM_vertex_array_lists", glVertexPointerListIBM },
  { "glVertexPointervINTEL", "GL_INTEL_parallel_arrays", glVertexPointervINTEL },
  { "glVertexStream1dATI", "GL_ATI_vertex_streams", glVertexStream1dATI },
  { "glVertexStream1dvATI", "GL_ATI_vertex_streams", glVertexStream1dvATI },
  { "glVertexStream1fATI", "GL_ATI_vertex_streams", glVertexStream1fATI },
  { "glVertexStream1fvATI", "GL_ATI_vertex_streams", glVertexStream1fvATI },
  { "glVertexStream1iATI", "GL_ATI_vertex_streams", glVertexStream1iATI },
  { "glVertexStream1ivATI", "GL_ATI_vertex_streams", glVertexStream1ivATI },
  { "glVertexStream1sATI", "GL_ATI_vertex_streams", glVertexStream1sATI },
  { "glVertexStream1svATI", "GL_ATI_vertex_streams", glVertexStream1svATI },
  { "glVertexStream2dATI", "GL_ATI_vertex_streams", glVertexStream2dATI },
  { "glVertexStream2dvATI", "GL_ATI_vertex_streams", glVertexStream2dvATI },
  { "glVertexStream2fATI", "GL_ATI_vertex_streams", glVertexStream2fATI },
  { "glVertexStream2fvATI", "GL_ATI_vertex_streams", glVertexStream2fvATI },
  { "glVertexStream2iATI", "GL_ATI_vertex_streams", glVertexStream2iATI },
  { "glVertexStream2ivATI", "GL_ATI_vertex_streams", glVertexStream2ivATI },
  { "glVertexStream2sATI", "GL_ATI_vertex_streams", glVertexStream2sATI },
  { "glVertexStream2svATI", "GL_ATI_vertex_streams", glVertexStream2svATI },
  { "glVertexStream3dATI", "GL_ATI_vertex_streams", glVertexStream3dATI },
  { "glVertexStream3dvATI", "GL_ATI_vertex_streams", glVertexStream3dvATI },
  { "glVertexStream3fATI", "GL_ATI_vertex_streams", glVertexStream3fATI },
  { "glVertexStream3fvATI", "GL_ATI_vertex_streams", glVertexStream3fvATI },
  { "glVertexStream3iATI", "GL_ATI_vertex_streams", glVertexStream3iATI },
  { "glVertexStream3ivATI", "GL_ATI_vertex_streams", glVertexStream3ivATI },
  { "glVertexStream3sATI", "GL_ATI_vertex_streams", glVertexStream3sATI },
  { "glVertexStream3svATI", "GL_ATI_vertex_streams", glVertexStream3svATI },
  { "glVertexStream4dATI", "GL_ATI_vertex_streams", glVertexStream4dATI },
  { "glVertexStream4dvATI", "GL_ATI_vertex_streams", glVertexStream4dvATI },
  { "glVertexStream4fATI", "GL_ATI_vertex_streams", glVertexStream4fATI },
  { "glVertexStream4fvATI", "GL_ATI_vertex_streams", glVertexStream4fvATI },
  { "glVertexStream4iATI", "GL_ATI_vertex_streams", glVertexStream4iATI },
  { "glVertexStream4ivATI", "GL_ATI_vertex_streams", glVertexStream4ivATI },
  { "glVertexStream4sATI", "GL_ATI_vertex_streams", glVertexStream4sATI },
  { "glVertexStream4svATI", "GL_ATI_vertex_streams", glVertexStream4svATI },
  { "glVertexWeightPointerEXT", "GL_EXT_vertex_weighting", glVertexWeightPointerEXT },
  { "glVertexWeightfEXT", "GL_EXT_vertex_weighting", glVertexWeightfEXT },
  { "glVertexWeightfvEXT", "GL_EXT_vertex_weighting", glVertexWeightfvEXT },
  { "glVertexWeighthNV", "GL_NV_half_float", glVertexWeighthNV },
  { "glVertexWeighthvNV", "GL_NV_half_float", glVertexWeighthvNV },
  { "glVideoCaptureNV", "GL_NV_video_capture", glVideoCaptureNV },
  { "glVideoCaptureStreamParameterdvNV", "GL_NV_video_capture", glVideoCaptureStreamParameterdvNV },
  { "glVideoCaptureStreamParameterfvNV", "GL_NV_video_capture", glVideoCaptureStreamParameterfvNV },
  { "glVideoCaptureStreamParameterivNV", "GL_NV_video_capture", glVideoCaptureStreamParameterivNV },
  { "glViewportArrayv", "GL_ARB_viewport_array GL_VERSION_4_1", glViewportArrayv },
  { "glViewportIndexedf", "GL_ARB_viewport_array GL_VERSION_4_1", glViewportIndexedf },
  { "glViewportIndexedfv", "GL_ARB_viewport_array GL_VERSION_4_1", glViewportIndexedfv },
  { "glViewportPositionWScaleNV", "GL_NV_clip_space_w_scaling", glViewportPositionWScaleNV },
  { "glViewportSwizzleNV", "GL_NV_viewport_swizzle", glViewportSwizzleNV },
  { "glWaitSemaphoreEXT", "GL_EXT_semaphore", glWaitSemaphoreEXT },
  { "glWaitSemaphoreui64NVX", "GL_NVX_progress_fence", glWaitSemaphoreui64NVX },
  { "glWaitSync", "GL_ARB_sync GL_VERSION_3_2", glWaitSync },
  { "glWaitVkSemaphoreNV", "GL_NV_draw_vulkan_image", glWaitVkSemaphoreNV },
  { "glWeightPathsNV", "GL_NV_path_rendering", glWeightPathsNV },
  { "glWeightPointerARB", "GL_ARB_vertex_blend", glWeightPointerARB },
  { "glWeightbvARB", "GL_ARB_vertex_blend", glWeightbvARB },
  { "glWeightdvARB", "GL_ARB_vertex_blend", glWeightdvARB },
  { "glWeightfvARB", "GL_ARB_vertex_blend", glWeightfvARB },
  { "glWeightivARB", "GL_ARB_vertex_blend", glWeightivARB },
  { "glWeightsvARB", "GL_ARB_vertex_blend", glWeightsvARB },
  { "glWeightubvARB", "GL_ARB_vertex_blend", glWeightubvARB },
  { "glWeightuivARB", "GL_ARB_vertex_blend", glWeightuivARB },
  { "glWeightusvARB", "GL_ARB_vertex_blend", glWeightusvARB },
  { "glWindowPos2d", "GL_VERSION_1_4", glWindowPos2d },
  { "glWindowPos2dARB", "GL_ARB_window_pos", glWindowPos2dARB },
  { "glWindowPos2dMESA", "GL_MESA_window_pos", glWindowPos2dMESA },
  { "glWindowPos2dv", "GL_VERSION_1_4", glWindowPos2dv },
  { "glWindowPos2dvARB", "GL_ARB_window_pos", glWindowPos2dvARB },
  { "glWindowPos2dvMESA", "GL_MESA_window_pos", glWindowPos2dvMESA },
  { "glWindowPos2f", "GL_VERSION_1_4", glWindowPos2f },
  { "glWindowPos2fARB", "GL_ARB_window_pos", glWindowPos2fARB },
  { "glWindowPos2fMESA", "GL_MESA_window_pos", glWindowPos2fMESA },
  { "glWindowPos2fv", "GL_VERSION_1_4", glWindowPos2fv },
  { "glWindowPos2fvARB", "GL_ARB_window_pos", glWindowPos2fvARB },
  { "glWindowPos2fvMESA", "GL_MESA_window_pos", glWindowPos2fvMESA },
  { "glWindowPos2i", "GL_VERSION_1_4", glWindowPos2i },
  { "glWindowPos2iARB", "GL_ARB_window_pos", glWindowPos2iARB },
  { "glWindowPos2iMESA", "GL_MESA_window_pos", glWindowPos2iMESA },
  { "glWindowPos2iv", "GL_VERSION_1_4", glWindowPos2iv },
  { "glWindowPos2ivARB", "GL_ARB_window_pos", glWindowPos2ivARB },
  { "glWindowPos2ivMESA", "GL_MESA_window_pos", glWindowPos2ivMESA },
  { "glWindowPos2s", "GL_VERSION_1_4", glWindowPos2s },
  { "glWindowPos2sARB", "GL_ARB_window_pos", glWindowPos2sARB },
  { "glWindowPos2sMESA", "GL_MESA_window_pos", glWindowPos2sMESA },
  { "glWindowPos2sv", "GL_VERSION_1_4", glWindowPos2sv },
  { "glWindowPos2svARB", "GL_ARB_window_pos", glWindowPos2svARB },
  { "glWindowPos2svMESA", "GL_MESA_window_pos", glWindowPos2svMESA },
  { "glWindowPos3d", "GL_VERSION_1_4", glWindowPos3d },
  { "glWindowPos3dARB", "GL_ARB_window_pos", glWindowPos3dARB },
  { "glWindowPos3dMESA", "GL_MESA_window_pos", glWindowPos3dMESA },
  { "glWindowPos3dv", "GL_VERSION_1_4", glWindowPos3dv },
  { "glWindowPos3dvARB", "GL_ARB_window_pos", glWindowPos3dvARB },
  { "glWindowPos3dvMESA", "GL_MESA_window_pos", glWindowPos3dvMESA },
  { "glWindowPos3f", "GL_VERSION_1_4", glWindowPos3f },
  { "glWindowPos3fARB", "GL_ARB_window_pos", glWindowPos3fARB },
  { "glWindowPos3fMESA", "GL_MESA_window_pos", glWindowPos3fMESA },
  { "glWindowPos3fv", "GL_VERSION_1_4", glWindowPos3fv },
  { "glWindowPos3fvARB", "GL_ARB_window_pos", glWindowPos3fvARB },
  { "glWindowPos3fvMESA", "GL_MESA_window_pos", glWindowPos3fvMESA },
  { "glWindowPos3i", "GL_VERSION_1_4", glWindowPos3i },
  { "glWindowPos3iARB", "GL_ARB_window_pos", glWindowPos3iARB },
  { "glWindowPos3iMESA", "GL_MESA_window_pos", glWindowPos3iMESA },
  { "glWindowPos3iv", "GL_VERSION_1_4", glWindowPos3iv },
  { "glWindowPos3ivARB", "GL_ARB_window_pos", glWindowPos3ivARB },
  { "glWindowPos3ivMESA", "GL_MESA_window_pos", glWindowPos3ivMESA },
  { "glWindowPos3s", "GL_VERSION_1_4", glWindowPos3s },
  { "glWindowPos3sARB", "GL_ARB_window_pos", glWindowPos3sARB },
  { "glWindowPos3sMESA", "GL_MESA_window_pos", glWindowPos3sMESA },
  { "glWindowPos3sv", "GL_VERSION_1_4", glWindowPos3sv },
  { "glWindowPos3svARB", "GL_ARB_window_pos", glWindowPos3svARB },
  { "glWindowPos3svMESA", "GL_MESA_window_pos", glWindowPos3svMESA },
  { "glWindowPos4dMESA", "GL_MESA_window_pos", glWindowPos4dMESA },
  { "glWindowPos4dvMESA", "GL_MESA_window_pos", glWindowPos4dvMESA },
  { "glWindowPos4fMESA", "GL_MESA_window_pos", glWindowPos4fMESA },
  { "glWindowPos4fvMESA", "GL_MESA_window_pos", glWindowPos4fvMESA },
  { "glWindowPos4iMESA", "GL_MESA_window_pos", glWindowPos4iMESA },
  { "glWindowPos4ivMESA", "GL_MESA_window_pos", glWindowPos4ivMESA },
  { "glWindowPos4sMESA", "GL_MESA_window_pos", glWindowPos4sMESA },
  { "glWindowPos4svMESA", "GL_MESA_window_pos", glWindowPos4svMESA },
  { "glWindowRectanglesEXT", "GL_EXT_window_rectangles", glWindowRectanglesEXT },
  { "glWriteMaskEXT", "GL_EXT_vertex_shader", glWriteMaskEXT },
  { "wglAllocateMemoryNV", "WGL_NV_vertex_array_range", wglAllocateMemoryNV },
  { "wglBindTexImageARB", "WGL_ARB_render_texture", wglBindTexImageARB },
  { "wglChoosePixelFormatARB", "WGL_ARB_pixel_format", wglChoosePixelFormatARB },
  { "wglCreateContextAttribsARB", "WGL_ARB_create_context", wglCreateContextAttribsARB },
  { "wglCreatePbufferARB", "WGL_ARB_pbuffer", wglCreatePbufferARB },
  { "wglDestroyPbufferARB", "WGL_ARB_pbuffer", wglDestroyPbufferARB },
  { "wglFreeMemoryNV", "WGL_NV_vertex_array_range", wglFreeMemoryNV },
  { "wglGetCurrentReadDCARB", "WGL_ARB_make_current_read", wglGetCurrentReadDCARB },
  { "wglGetExtensionsStringARB", "WGL_ARB_extensions_string", wglGetExtensionsStringARB },
  { "wglGetExtensionsStringEXT", "WGL_EXT_extensions_string", wglGetExtensionsStringEXT },
  { "wglGetPbufferDCARB", "WGL_ARB_pbuffer", wglGetPbufferDCARB },
  { "wglGetPixelFormatAttribfvARB", "WGL_ARB_pixel_format", wglGetPixelFormatAttribfvARB },
  { "wglGetPixelFormatAttribivARB", "WGL_ARB_pixel_format", wglGetPixelFormatAttribivARB },
  { "wglGetSwapIntervalEXT", "WGL_EXT_swap_control", wglGetSwapIntervalEXT },
  { "wglMakeContextCurrentARB", "WGL_ARB_make_current_read", wglMakeContextCurrentARB },
  { "wglQueryCurrentRendererIntegerWINE", "WGL_WINE_query_renderer", wglQueryCurrentRendererIntegerWINE },
  { "wglQueryCurrentRendererStringWINE", "WGL_WINE_query_renderer", wglQueryCurrentRendererStringWINE },
  { "wglQueryPbufferARB", "WGL_ARB_pbuffer", wglQueryPbufferARB },
  { "wglQueryRendererIntegerWINE", "WGL_WINE_query_renderer", wglQueryRendererIntegerWINE },
  { "wglQueryRendererStringWINE", "WGL_WINE_query_renderer", wglQueryRendererStringWINE },
  { "wglReleasePbufferDCARB", "WGL_ARB_pbuffer", wglReleasePbufferDCARB },
  { "wglReleaseTexImageARB", "WGL_ARB_render_texture", wglReleaseTexImageARB },
  { "wglSetPbufferAttribARB", "WGL_ARB_render_texture", wglSetPbufferAttribARB },
  { "wglSetPixelFormatWINE", "WGL_WINE_pixel_format_passthrough", wglSetPixelFormatWINE },
  { "wglSwapIntervalEXT", "WGL_EXT_swap_control", wglSwapIntervalEXT }
};
#endif /* QEMU_DLL_GUEST */
